"use strict";(self.webpackChunkjeongyong_park_github_io=self.webpackChunkjeongyong_park_github_io||[]).push([[9362],{2767:n=>{n.exports=JSON.parse('{"permalink":"/blog/csharp-thread-parallel-foreach-safe-cancellation","source":"@site/blog/2025-06-02/index.md","title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","description":"C#에서 Thread.Abort() 없이 Thread와 Parallel.ForEach를 안전하게 중단하는 방법을 CancellationToken과 플래그 패턴으로 알아봅니다.","date":"2025-06-02T09:00:00.000Z","tags":[{"inline":true,"label":"csharp","permalink":"/blog/tags/csharp"},{"inline":true,"label":"dotnet","permalink":"/blog/tags/dotnet"},{"inline":true,"label":"threading","permalink":"/blog/tags/threading"},{"inline":true,"label":"parallel","permalink":"/blog/tags/parallel"}],"readingTime":8.04,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2025-06-02T09:00:00","authors":["jypark"],"image":"/img/blog/safe-thread-cancellation-in-csharp.webp","tags":["csharp","dotnet","threading","parallel"],"description":"C#에서 Thread.Abort() 없이 Thread와 Parallel.ForEach를 안전하게 중단하는 방법을 CancellationToken과 플래그 패턴으로 알아봅니다.","slug":"csharp-thread-parallel-foreach-safe-cancellation"},"unlisted":false,"prevItem":{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","permalink":"/blog/lm-studio-local-ai-guide"},"nextItem":{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","permalink":"/blog/supabase-complete-guide-firebase-alternative"}}')},4829:(n,e,a)=>{a.d(e,{A:()=>l});const l=a.p+"assets/images/safe-thread-cancellation-in-csharp-94ea6ded89c3d51ff7639164920a117d.webp"},8453:(n,e,a)=>{a.d(e,{R:()=>t,x:()=>i});var l=a(6540);const r={},o=l.createContext(r);function t(n){const e=l.useContext(o);return l.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),l.createElement(o.Provider,{value:e},n.children)}},9362:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>s});var l=a(2767),r=a(4848),o=a(8453);const t={title:"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법",date:"2025-06-02T09:00:00",authors:["jypark"],image:"/img/blog/safe-thread-cancellation-in-csharp.webp",tags:["csharp","dotnet","threading","parallel"],description:"C#에서 Thread.Abort() 없이 Thread와 Parallel.ForEach를 안전하게 중단하는 방법을 CancellationToken과 플래그 패턴으로 알아봅니다.",slug:"csharp-thread-parallel-foreach-safe-cancellation"},i=void 0,c={authorsImageUrls:[void 0]},s=[{value:"Thread.Abort()를 사용하면 안 되는 이유",id:"threadabort를-사용하면-안-되는-이유",level:2},{value:"Thread 안전하게 중단하기",id:"thread-안전하게-중단하기",level:2},{value:"1. 플래그 패턴 사용",id:"1-플래그-패턴-사용",level:3},{value:"2. CancellationToken 사용 (권장)",id:"2-cancellationtoken-사용-권장",level:3},{value:"Parallel.ForEach 안전하게 중단하기",id:"parallelforeach-안전하게-중단하기",level:2},{value:"외부에서 수동으로 취소하기",id:"외부에서-수동으로-취소하기",level:3},{value:".NET Framework 4.8 호환 버전",id:"net-framework-48-호환-버전",level:2},{value:".NET Framework 4.8에서 Parallel.ForEach 사용",id:"net-framework-48에서-parallelforeach-사용",level:3},{value:".NET Framework 4.8에서 Task 기반 접근",id:"net-framework-48에서-task-기반-접근",level:3},{value:"Thread와 Parallel.ForEach 조합하기",id:"thread와-parallelforeach-조합하기",level:2},{value:".NET Framework vs .NET 5+ 차이점",id:"net-framework-vs-net-5-차이점",level:2},{value:"API 차이점 요약",id:"api-차이점-요약",level:3},{value:".NET Framework 4.8 권장 패턴",id:"net-framework-48-권장-패턴",level:3},{value:"성능 고려사항",id:"성능-고려사항",level:2},{value:"취소 확인 빈도",id:"취소-확인-빈도",level:3},{value:"리소스 정리",id:"리소스-정리",level:3},{value:"결론",id:"결론",level:2},{value:"참고 자료",id:"참고-자료",level:2},{value:"공식 문서",id:"공식-문서",level:3},{value:"관련 기술 문서",id:"관련-기술-문서",level:3},{value:"추가 학습 자료",id:"추가-학습-자료",level:3}];function d(n){const e={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.img,{alt:"safe-thread-cancellation-in-csharp",src:a(4829).A+"",width:"1200",height:"800"}),"\n멀티스레딩 환경에서 작업을 안전하게 중단하는 것은 중요한 과제입니다. 특히 C#에서 Thread.Abort()가 .NET 5 이상에서 지원되지 않으면서, 안전한 중단 방법에 대한 이해가 더욱 중요해졌습니다."]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"TL;DR"}),": Thread.Abort() 대신 CancellationToken이나 플래그 패턴을 사용하여 Thread와 Parallel.ForEach를 안전하게 중단할 수 있습니다. 이 방법들은 리소스 누수와 데이터 손상을 방지하며 .NET의 표준 취소 패턴을 따릅니다."]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["이 글은 2016년도에 C#(.NET Framework 4.5 기반) 프로젝트를 진행하면서 작성했던 ",(0,r.jsx)(e.a,{href:"https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-cancellation",children:"멀티스레드 중단 처리 포스트"}),"의 업데이트 버전입니다. .NET 5부터 Thread.Abort()가 공식적으로 obsolete되면서 기존 내용이 현재 환경에 맞지 않게 되어, .NET Framework 4.8부터 최신 .NET까지 모든 환경에서 사용할 수 있는 안전한 중단 방법들을 정리했습니다."]}),"\n",(0,r.jsx)(e.h2,{id:"threadabort를-사용하면-안-되는-이유",children:"Thread.Abort()를 사용하면 안 되는 이유"}),"\n",(0,r.jsx)(e.p,{children:"Thread.Abort()는 여러 심각한 문제를 야기할 수 있습니다:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:".NET 5 이상에서 지원 중단"}),": 더 이상 사용할 수 없는 방법입니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"리소스 누수"}),": 파일 핸들, 데이터베이스 연결 등이 제대로 해제되지 않을 수 있습니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"데이터 손상"}),": 작업 중간에 강제 종료되어 일관성이 깨질 수 있습니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"예측 불가능한 동작"}),": ThreadAbortException이 예상치 못한 곳에서 발생할 수 있습니다"]}),"\n"]}),"\n",(0,r.jsx)(e.admonition,{title:"Thread.Abort() 사용 금지",type:"danger",children:(0,r.jsx)(e.p,{children:"Thread.Abort()는 .NET 5 이상에서 지원되지 않으며, 이전 버전에서도 안전하지 않습니다. 절대 사용하지 마세요."})}),"\n",(0,r.jsx)(e.h2,{id:"thread-안전하게-중단하기",children:"Thread 안전하게 중단하기"}),"\n",(0,r.jsx)(e.h3,{id:"1-플래그-패턴-사용",children:"1. 플래그 패턴 사용"}),"\n",(0,r.jsx)(e.p,{children:"가장 간단한 방법은 boolean 플래그를 사용하는 것입니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="플래그 패턴을 사용한 Thread 중단" showLineNumbers',children:'public class SafeThread\n{\n    private volatile bool _stopRequested = false;\n    private Thread _thread;\n\n    public void Start()\n    {\n        _thread = new Thread(DoWork);\n        _thread.Start();\n    }\n\n    public void Stop()\n    {\n        _stopRequested = true;\n        _thread?.Join(); // 스레드가 완전히 종료될 때까지 대기\n    }\n\n    private void DoWork()\n    {\n        while (!_stopRequested)\n        {\n            // 실제 작업 수행\n            ProcessItem();\n            \n            // 주기적으로 중단 요청 확인\n            if (_stopRequested)\n                break;\n                \n            Thread.Sleep(100); // 예시: 100ms 대기\n        }\n        \n        Console.WriteLine("스레드가 안전하게 종료되었습니다.");\n    }\n\n    private void ProcessItem()\n    {\n        // 실제 작업 로직\n        Console.WriteLine($"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"2-cancellationtoken-사용-권장",children:"2. CancellationToken 사용 (권장)"}),"\n",(0,r.jsx)(e.p,{children:".NET의 표준 취소 패턴인 CancellationToken을 사용하는 방법입니다 (.NET Framework 4.0 이상):"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="CancellationToken을 사용한 Thread 중단" showLineNumbers',children:'public class CancellableThread\n{\n    private Thread _thread;\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public void Start()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        _thread = new Thread(() => DoWork(_cancellationTokenSource.Token));\n        _thread.Start();\n    }\n\n    public void Stop()\n    {\n        _cancellationTokenSource?.Cancel();\n        _thread?.Join();\n        _cancellationTokenSource?.Dispose();\n    }\n\n    private void DoWork(CancellationToken cancellationToken)\n    {\n        try\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                ProcessItem();\n                \n                // 취소 요청 확인 및 예외 발생\n                cancellationToken.ThrowIfCancellationRequested();\n                \n                // 취소 가능한 대기 (.NET Framework 4.8에서는 Thread.Sleep 사용)\n                if (cancellationToken.WaitHandle.WaitOne(100))\n                {\n                    break; // 취소 요청됨\n                }\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("작업이 취소되었습니다.");\n        }\n        finally\n        {\n            Console.WriteLine("스레드가 안전하게 종료되었습니다.");\n        }\n    }\n\n    private void ProcessItem()\n    {\n        Console.WriteLine($"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"parallelforeach-안전하게-중단하기",children:"Parallel.ForEach 안전하게 중단하기"}),"\n",(0,r.jsx)(e.p,{children:"Parallel.ForEach는 ParallelOptions를 통해 CancellationToken을 지원합니다 (.NET Framework 4.0 이상):"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="CancellationToken을 사용한 Parallel.ForEach 중단" showLineNumbers',children:'public class ParallelProcessor\n{\n    public async Task ProcessItemsAsync(IEnumerable<int> items)\n    {\n        var cancellationTokenSource = new CancellationTokenSource();\n        \n        // 5초 후 자동 취소 (예시)\n        cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(5));\n        \n        var parallelOptions = new ParallelOptions\n        {\n            CancellationToken = cancellationTokenSource.Token,\n            MaxDegreeOfParallelism = Environment.ProcessorCount\n        };\n\n        try\n        {\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\n            {\n                // 각 반복에서 취소 요청 확인\n                parallelOptions.CancellationToken.ThrowIfCancellationRequested();\n                \n                ProcessSingleItem(item, parallelOptions.CancellationToken);\n            });\n            \n            Console.WriteLine("모든 작업이 완료되었습니다.");\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("병렬 작업이 취소되었습니다.");\n        }\n        finally\n        {\n            cancellationTokenSource.Dispose();\n        }\n    }\n\n    private void ProcessSingleItem(int item, CancellationToken cancellationToken)\n    {\n        // 긴 작업 시뮬레이션\n        for (int i = 0; i < 10; i++)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n            \n            Thread.Sleep(100); // 실제 작업 시뮬레이션\n            Console.WriteLine($"Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"외부에서-수동으로-취소하기",children:"외부에서 수동으로 취소하기"}),"\n",(0,r.jsx)(e.p,{children:"사용자 입력이나 다른 조건에 따라 수동으로 취소하는 예시입니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="수동 취소가 가능한 병렬 처리" showLineNumbers',children:'public class ManualCancellationExample\n{\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public async Task StartProcessingAsync()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        var items = Enumerable.Range(1, 1000);\n\n        var parallelOptions = new ParallelOptions\n        {\n            CancellationToken = _cancellationTokenSource.Token,\n            MaxDegreeOfParallelism = 4\n        };\n\n        try\n        {\n            await Task.Run(() =>\n            {\n                Parallel.ForEach(items, parallelOptions, (item, loopState) =>\n                {\n                    parallelOptions.CancellationToken.ThrowIfCancellationRequested();\n                    \n                    // 무거운 작업 시뮬레이션\n                    Thread.Sleep(200);\n                    Console.WriteLine($"처리 완료: {item}");\n                });\n            });\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("사용자에 의해 작업이 취소되었습니다.");\n        }\n    }\n\n    public void CancelProcessing()\n    {\n        _cancellationTokenSource?.Cancel();\n        Console.WriteLine("취소 요청이 전송되었습니다.");\n    }\n}\n\n// 사용 예시\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        var processor = new ManualCancellationExample();\n        \n        // 백그라운드에서 처리 시작\n        var processingTask = processor.StartProcessingAsync();\n        \n        Console.WriteLine("Enter 키를 누르면 작업을 취소합니다...");\n        Console.ReadLine();\n        \n        // 사용자 입력으로 취소\n        processor.CancelProcessing();\n        \n        await processingTask;\n        Console.WriteLine("프로그램이 종료되었습니다.");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"net-framework-48-호환-버전",children:".NET Framework 4.8 호환 버전"}),"\n",(0,r.jsx)(e.p,{children:".NET Framework 4.8에서는 일부 최신 API가 없어서 약간 다른 접근이 필요합니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title=".NET Framework 4.8 호환 CancellationToken 사용" showLineNumbers',children:'public class NetFramework48Thread\n{\n    private Thread _thread;\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public void Start()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        _thread = new Thread(() => DoWork(_cancellationTokenSource.Token));\n        _thread.Start();\n    }\n\n    public void Stop()\n    {\n        _cancellationTokenSource?.Cancel();\n        _thread?.Join();\n        _cancellationTokenSource?.Dispose();\n    }\n\n    private void DoWork(CancellationToken cancellationToken)\n    {\n        try\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                ProcessItem();\n                \n                // 취소 요청 확인\n                cancellationToken.ThrowIfCancellationRequested();\n                \n                // .NET Framework 4.8에서 취소 가능한 대기\n                // Task.Delay 대신 WaitHandle 사용\n                if (cancellationToken.WaitHandle.WaitOne(100))\n                {\n                    break; // 취소 요청됨\n                }\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("작업이 취소되었습니다.");\n        }\n        finally\n        {\n            Console.WriteLine("스레드가 안전하게 종료되었습니다.");\n        }\n    }\n\n    private void ProcessItem()\n    {\n        Console.WriteLine($"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"net-framework-48에서-parallelforeach-사용",children:".NET Framework 4.8에서 Parallel.ForEach 사용"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title=".NET Framework 4.8 Parallel.ForEach 예제" showLineNumbers',children:'public class NetFramework48ParallelProcessor\n{\n    public void ProcessItems(IEnumerable<int> items)\n    {\n        var cancellationTokenSource = new CancellationTokenSource();\n        \n        // 5초 후 자동 취소\n        var timer = new System.Threading.Timer(_ => cancellationTokenSource.Cancel(), \n                                               null, 5000, Timeout.Infinite);\n        \n        var parallelOptions = new ParallelOptions\n        {\n            CancellationToken = cancellationTokenSource.Token,\n            MaxDegreeOfParallelism = Environment.ProcessorCount\n        };\n\n        try\n        {\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\n            {\n                parallelOptions.CancellationToken.ThrowIfCancellationRequested();\n                \n                ProcessSingleItem(item, parallelOptions.CancellationToken);\n            });\n            \n            Console.WriteLine("모든 작업이 완료되었습니다.");\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("병렬 작업이 취소되었습니다.");\n        }\n        finally\n        {\n            timer?.Dispose();\n            cancellationTokenSource.Dispose();\n        }\n    }\n\n    private void ProcessSingleItem(int item, CancellationToken cancellationToken)\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n            \n            Thread.Sleep(100);\n            Console.WriteLine($"Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"net-framework-48에서-task-기반-접근",children:".NET Framework 4.8에서 Task 기반 접근"}),"\n",(0,r.jsx)(e.p,{children:".NET Framework 4.8에서는 Task를 사용한 접근도 가능합니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title=".NET Framework 4.8 Task 기반 처리" showLineNumbers',children:'public class NetFramework48TaskProcessor\n{\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public async Task StartProcessingAsync()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        var items = Enumerable.Range(1, 1000);\n\n        try\n        {\n            // .NET Framework 4.8에서는 Task.Run 대신 Task.Factory.StartNew 사용 권장\n            await Task.Factory.StartNew(() =>\n            {\n                var parallelOptions = new ParallelOptions\n                {\n                    CancellationToken = _cancellationTokenSource.Token,\n                    MaxDegreeOfParallelism = 4\n                };\n\n                Parallel.ForEach(items, parallelOptions, (item, loopState) =>\n                {\n                    parallelOptions.CancellationToken.ThrowIfCancellationRequested();\n                    \n                    Thread.Sleep(200);\n                    Console.WriteLine($"처리 완료: {item}");\n                });\n            }, _cancellationTokenSource.Token);\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("사용자에 의해 작업이 취소되었습니다.");\n        }\n    }\n\n    public void CancelProcessing()\n    {\n        _cancellationTokenSource?.Cancel();\n        Console.WriteLine("취소 요청이 전송되었습니다.");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"thread와-parallelforeach-조합하기",children:"Thread와 Parallel.ForEach 조합하기"}),"\n",(0,r.jsx)(e.p,{children:"별도 스레드에서 Parallel.ForEach를 실행하고 전체를 안전하게 중단하는 방법입니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="Thread 내에서 Parallel.ForEach 사용" showLineNumbers',children:'public class ThreadedParallelProcessor\n{\n    private Thread _workerThread;\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public void Start(IEnumerable<int> items)\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        _workerThread = new Thread(() => ProcessInBackground(items, _cancellationTokenSource.Token));\n        _workerThread.Start();\n    }\n\n    public void Stop()\n    {\n        _cancellationTokenSource?.Cancel();\n        _workerThread?.Join(TimeSpan.FromSeconds(10)); // 최대 10초 대기\n        _cancellationTokenSource?.Dispose();\n    }\n\n    private void ProcessInBackground(IEnumerable<int> items, CancellationToken cancellationToken)\n    {\n        try\n        {\n            var parallelOptions = new ParallelOptions\n            {\n                CancellationToken = cancellationToken,\n                MaxDegreeOfParallelism = Environment.ProcessorCount / 2\n            };\n\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                \n                // 실제 작업 처리\n                ProcessItem(item, cancellationToken);\n            });\n            \n            Console.WriteLine("백그라운드 처리가 완료되었습니다.");\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("백그라운드 작업이 취소되었습니다.");\n        }\n    }\n\n    private void ProcessItem(int item, CancellationToken cancellationToken)\n    {\n        // 긴 작업 중간중간 취소 확인\n        for (int i = 0; i < 5; i++)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n            Thread.Sleep(100);\n        }\n        \n        Console.WriteLine($"Item {item} 처리 완료");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"net-framework-vs-net-5-차이점",children:".NET Framework vs .NET 5+ 차이점"}),"\n",(0,r.jsx)(e.h3,{id:"api-차이점-요약",children:"API 차이점 요약"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"기능"}),(0,r.jsx)(e.th,{children:".NET Framework 4.8"}),(0,r.jsx)(e.th,{children:".NET 5+"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"CancellationToken"}),(0,r.jsx)(e.td,{children:"✅ 지원"}),(0,r.jsx)(e.td,{children:"✅ 지원"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Task.Delay with CancellationToken"}),(0,r.jsx)(e.td,{children:"❌ 제한적"}),(0,r.jsx)(e.td,{children:"✅ 완전 지원"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Task.Run"}),(0,r.jsx)(e.td,{children:"❌ 없음"}),(0,r.jsx)(e.td,{children:"✅ 지원"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"CancellationTokenSource.CancelAfter"}),(0,r.jsx)(e.td,{children:"❌ 없음"}),(0,r.jsx)(e.td,{children:"✅ 지원"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Thread.Abort"}),(0,r.jsx)(e.td,{children:"⚠️ 사용 가능하지만 위험"}),(0,r.jsx)(e.td,{children:"❌ Obsolete"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"net-framework-48-권장-패턴",children:".NET Framework 4.8 권장 패턴"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title=".NET Framework 4.8 권장 패턴" showLineNumbers',children:'public class RecommendedNetFramework48Pattern\n{\n    private readonly CancellationTokenSource _cancellationTokenSource;\n    private readonly ManualResetEventSlim _completedEvent;\n\n    public RecommendedNetFramework48Pattern()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        _completedEvent = new ManualResetEventSlim(false);\n    }\n\n    public void StartWork()\n    {\n        Task.Factory.StartNew(() => DoWork(_cancellationTokenSource.Token), \n                             _cancellationTokenSource.Token,\n                             TaskCreationOptions.LongRunning,\n                             TaskScheduler.Default);\n    }\n\n    public void StopWork(int timeoutMs = 5000)\n    {\n        _cancellationTokenSource.Cancel();\n        \n        if (!_completedEvent.Wait(timeoutMs))\n        {\n            Console.WriteLine("작업이 제한 시간 내에 완료되지 않았습니다.");\n        }\n    }\n\n    private void DoWork(CancellationToken cancellationToken)\n    {\n        try\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                // 실제 작업 수행\n                ProcessWorkItem();\n                \n                // 주기적 취소 확인 (.NET Framework 4.8 호환)\n                if (cancellationToken.WaitHandle.WaitOne(100))\n                {\n                    break;\n                }\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine("작업이 취소되었습니다.");\n        }\n        finally\n        {\n            _completedEvent.Set();\n            Console.WriteLine("작업이 완료되었습니다.");\n        }\n    }\n\n    private void ProcessWorkItem()\n    {\n        // 실제 작업 로직\n        Thread.Sleep(50);\n        Console.WriteLine($"작업 처리 중... (Thread: {Thread.CurrentThread.ManagedThreadId})");\n    }\n\n    public void Dispose()\n    {\n        _cancellationTokenSource?.Dispose();\n        _completedEvent?.Dispose();\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"성능-고려사항",children:"성능 고려사항"}),"\n",(0,r.jsx)(e.h3,{id:"취소-확인-빈도",children:"취소 확인 빈도"}),"\n",(0,r.jsx)(e.p,{children:"취소 확인을 너무 자주 하면 성능에 영향을 줄 수 있습니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="효율적인 취소 확인" showLineNumbers',children:"private void OptimizedWork(CancellationToken cancellationToken)\n{\n    const int checkInterval = 100; // 100번 작업마다 한 번씩 확인\n    int counter = 0;\n\n    while (true)\n    {\n        // 실제 작업\n        DoSomeWork();\n        \n        // 주기적으로만 취소 확인\n        if (++counter % checkInterval == 0)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"리소스-정리",children:"리소스 정리"}),"\n",(0,r.jsx)(e.p,{children:"취소 시에도 리소스가 제대로 정리되도록 해야 합니다:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",metastring:'title="리소스 안전 정리" showLineNumbers',children:'private void SafeResourceHandling(CancellationToken cancellationToken)\n{\n    using var fileStream = new FileStream("data.txt", FileMode.Open);\n    using var reader = new StreamReader(fileStream);\n    \n    try\n    {\n        while (!reader.EndOfStream)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n            \n            var line = reader.ReadLine();\n            ProcessLine(line);\n        }\n    }\n    catch (OperationCanceledException)\n    {\n        Console.WriteLine("파일 처리가 취소되었습니다.");\n        // using 문에 의해 자동으로 리소스 정리됨\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"결론",children:"결론"}),"\n",(0,r.jsx)(e.p,{children:"C#에서 Thread와 Parallel.ForEach를 안전하게 중단하는 핵심은 다음과 같습니다:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Thread.Abort() 사용 금지"}),": .NET 5 이상에서 지원되지 않으며, .NET Framework에서도 안전하지 않습니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"CancellationToken 활용"}),": .NET Framework 4.0부터 지원되는 표준 취소 패턴으로 가장 권장되는 방법입니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"플래그 패턴"}),": 간단한 시나리오에서 사용할 수 있는 대안입니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"프레임워크별 차이점 고려"}),": .NET Framework 4.8과 .NET 5+ 간의 API 차이를 이해해야 합니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"적절한 취소 확인"}),": 성능과 반응성의 균형을 맞춰야 합니다"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"리소스 정리"}),": 취소 시에도 모든 리소스가 안전하게 해제되도록 해야 합니다"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"이러한 패턴들을 사용하면 리소스 누수나 데이터 손상 없이 멀티스레딩 작업을 안전하게 제어할 수 있습니다. 특히 장시간 실행되는 백그라운드 작업이나 사용자가 중단할 수 있는 작업에서는 반드시 이런 안전한 중단 메커니즘을 구현해야 합니다."}),"\n",(0,r.jsx)(e.h2,{id:"참고-자료",children:"참고 자료"}),"\n",(0,r.jsx)(e.h3,{id:"공식-문서",children:"공식 문서"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.abort",children:"Thread.Abort Method - Microsoft Docs"})," - Thread.Abort() 메서드 공식 문서 및 지원 중단 안내"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken",children:"CancellationToken Struct - Microsoft Docs"})," - CancellationToken 구조체 공식 문서"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreach",children:"Parallel.ForEach Method - Microsoft Docs"})," - Parallel.ForEach 메서드 공식 문서"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads",children:"Cancellation in Managed Threads - Microsoft Docs"})," - 관리되는 스레드에서의 취소 패턴 가이드"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"관련-기술-문서",children:"관련 기술 문서"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap",children:"Task-based Asynchronous Pattern (TAP) - Microsoft Docs"})," - 비동기 프로그래밍 패턴"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/",children:"Parallel Programming in .NET - Microsoft Docs"})," - .NET 병렬 프로그래밍 가이드"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices",children:"Best Practices for Managed Threading - Microsoft Docs"})," - 관리되는 스레딩 모범 사례"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"추가-학습-자료",children:"추가 학습 자료"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html",children:"Stephen Cleary's Blog - Async/Await Best Practices"})," - 비동기 코드 모범 사례"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/",children:"Eric Lippert's Blog - Cancellation"})," - 취소 패턴에 대한 심화 설명"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);