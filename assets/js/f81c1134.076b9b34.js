"use strict";(self.webpackChunkjeongyong_park_github_io=self.webpackChunkjeongyong_park_github_io||[]).push([[8130],{7735:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"diffx-next-generation-extensible-diff-format","metadata":{"permalink":"/blog/diffx-next-generation-extensible-diff-format","source":"@site/blog/2025-06-04-post/index.md","title":"DiffX: 확장 가능한 차세대 Diff 형식","description":"기존 Unified Diff의 한계를 극복한 새로운 구조화된 차이점 비교 형식 DiffX를 소개합니다. 메타데이터 지원, 멀티 커밋, 바이너리 패치 등 현대적 기능을 제공합니다.","date":"2025-06-04T10:00:00.000Z","tags":[{"inline":true,"label":"diffx","permalink":"/blog/tags/diffx"},{"inline":true,"label":"diff","permalink":"/blog/tags/diff"},{"inline":true,"label":"git","permalink":"/blog/tags/git"},{"inline":true,"label":"version-control","permalink":"/blog/tags/version-control"}],"readingTime":4.81,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"DiffX: 확장 가능한 차세대 Diff 형식","date":"2025-06-04T10:00:00","authors":["jypark"],"image":"/img/blog/diffx.png","tags":["diffx","diff","git","version-control"],"description":"기존 Unified Diff의 한계를 극복한 새로운 구조화된 차이점 비교 형식 DiffX를 소개합니다. 메타데이터 지원, 멀티 커밋, 바이너리 패치 등 현대적 기능을 제공합니다.","slug":"diffx-next-generation-extensible-diff-format","hide_table_of_contents":false,"hide_reading_time":false},"unlisted":false,"nextItem":{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","permalink":"/blog/lm-studio-local-ai-guide"}},"content":"![DiffX](/img/blog/diffx.webp)\\n\\n소프트웨어 개발자라면 diff 파일을 다뤄본 경험이 있을 것입니다. Git diff, Subversion diff, CVS diff... 어떤 형태든 말이죠. 변경사항을 만들고, 명령어를 실행하면 diff가 출력됩니다. 이를 다른 사람에게 전달하거나, 다른 곳에 적용하거나, 리뷰를 위해 업로드하죠.\\n\\n> **TL;DR**: DiffX는 기존 Unified Diff의 한계를 극복한 새로운 구조화된 차이점 비교 형식입니다. 표준화된 메타데이터, 멀티 커밋 지원, 바이너리 패치 등 현대적 기능을 제공하면서도 기존 도구와 완전히 호환됩니다.\\n\\n하지만 현재의 diff 형식들은 현대적 개발 요구사항을 충족하지 못하고 있습니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n## 현재 Diff 형식들의 모습\\n\\n대부분의 사람과 도구는 Unified Diff를 사용합니다. 다음과 같은 형태들이죠:\\n\\n```diff\\n--- readme    2016-01-26 16:29:12.000000000 -0800\\n+++ readme    2016-01-31 11:54:32.000000000 -0800\\n@@ -1 +1,3 @@\\n Hello there\\n+\\n+Oh hi!\\n```\\n\\nGit diff:\\n```diff\\ndiff --git a/readme b/readme\\nindex d6613f5..5b50866 100644\\n--- a/readme\\n+++ b/readme\\n@@ -1 +1,3 @@\\n Hello there\\n+\\n+Oh hi!\\n```\\n\\nSVN diff:\\n```diff\\nIndex: readme\\n===================================================================\\n--- (revision 123)\\n+++ (working copy)\\nProperty changes on: .\\n-------------------------------------------------------------------\\nModified: myproperty\\n## -1 +1 ##\\n-old value\\n+new value\\n```\\n\\n## 기존 Diff의 근본적 문제점\\n\\n### 1. 표준화 부족\\n\\nUnified Diff는 diff의 일부만 표준화합니다:\\n- `---`/`+++` 라인 (파일 식별용)\\n- `@@ ... @@` 라인 (hunk 오프셋/크기)  \\n- `-`/`+` (삭제/추가된 라인)\\n\\n> \\"Unified format은 가장 널리 사용되는 diff 형식이지만, 표준화되지 않은 메타데이터 처리로 인해 도구 간 호환성 문제가 지속적으로 발생하고 있습니다.\\" - DiffX 문제점 분석 문서[^5]\\n\\n하지만 다음은 표준화되지 않았습니다:\\n- 인코딩\\n- 리비전 정보\\n- 메타데이터\\n- 파일명이나 경로 표현 방식\\n\\n### 2. 현대적 요구사항 미충족\\n\\n- **단일 diff에 여러 커밋 표현 불가**\\n- **바이너리 패치 표준 형식 없음**\\n- **텍스트 인코딩 정보 없음** (생각보다 큰 문제)\\n- **메타데이터를 위한 표준 형식 없음** (각자 다른 방식으로 구현)\\n\\n### 3. 파싱의 어려움\\n\\n패치 도구, 코드 리뷰 도구, 코드 분석 도구들이 다양한 소스 컨트롤 시스템의 diff를 안정적으로 파싱하기 매우 어렵습니다. 변경된 라인 외의 유용한 정보를 추출하는 것은 더욱 어렵죠.\\n\\nGNU Patch가 처리해야 하는 복잡성을 보면 이 문제의 심각성을 알 수 있습니다[^1].\\n\\n## DiffX: 해결책\\n\\nDiffX(Extensible Diffs)는 이러한 문제들을 해결하기 위해 설계된 새로운 형식입니다[^2]. 기존 도구와 완전히 호환되면서도 미래 지향적이고 사람이 읽을 수 있는 형태를 유지합니다.\\n\\n### DiffX 파일 예시\\n\\n다음은 DiffX 공식 문서에서 제공하는 실제 예시입니다[^2]:\\n\\n```diffx\\n#diffx: encoding=utf-8, version=1.0\\n#.change:\\n#..preamble: indent=4, length=319, mimetype=text/markdown\\n    Convert legacy header building code to Python 3.\\n    \\n    Header building for messages used old Python 2.6-era list comprehensions\\n    with tuples rather than modern dictionary comprehensions in order to build\\n    a message list. This change modernizes that, and swaps out six for a\\n    3-friendly `.items()` call.\\n#..meta: format=json, length=270\\n{\\n    \\"author\\": \\"Christian Hammond <christian@example.com>\\",\\n    \\"committer\\": \\"Christian Hammond <christian@example.com>\\",\\n    \\"committer date\\": \\"2021-06-02T13:12:06-07:00\\",\\n    \\"date\\": \\"2021-06-01T19:26:31-07:00\\",\\n    \\"id\\": \\"a25e7b28af5e3184946068f432122c68c1a30b23\\"\\n}\\n#..file:\\n#...meta: format=json, length=176\\n{\\n    \\"path\\": \\"/src/message.py\\",\\n    \\"revision\\": {\\n        \\"new\\": \\"f814cf74766ba3e6d175254996072233ca18a690\\",\\n        \\"old\\": \\"9f6a412b3aee0a55808928b43f848202b4ee0f8d\\"\\n    }\\n}\\n#...diff: length=629\\n--- /src/message.py\\n+++ /src/message.py\\n@@ -164,10 +164,10 @@\\n             not isinstance(headers, MultiValueDict)):\\n             # Instantiating a MultiValueDict from a dict does not ensure that\\n             # values are lists, so we have to ensure that ourselves.\\n-            headers = MultiValueDict(dict(\\n-                (key, [value])\\n-                for key, value in six.iteritems(headers)\\n-            ))\\n+            headers = MultiValueDict({\\n+                key: [value]\\n+                for key, value in headers.items()\\n+            })\\n\\n         if in_reply_to:\\n             headers[\'In-Reply-To\'] = in_reply_to\\n```\\n\\n## DiffX의 주요 특징\\n\\n### 1. 구조화된 메타데이터\\n- diff와 각 커밋, 파일에 대한 메타데이터를 표준화된 방식으로 저장\\n- JSON 형식으로 구조화된 정보 제공\\n\\n### 2. 다중 커밋 지원\\n- 하나의 diff 파일에 여러 커밋 표현 가능\\n- 복잡한 변경사항의 히스토리 보존\\n\\n### 3. 바이너리 지원\\n- Git 호환 바이너리 콘텐츠 diff 지원\\n- 이미지, 실행파일 등의 변경사항도 처리\\n\\n### 4. 인코딩 인식\\n- 파일과 diff 메타데이터의 텍스트 인코딩 정보 포함\\n- 다국어 프로젝트에서 중요한 기능\\n\\n### 5. 완전한 호환성\\n- 기존 파서와 패처에서 모든 표준 diff 기능 동작\\n- 새로운 기능은 추가 도구 지원 필요하지만 파싱은 가능\\n\\n### 6. 확장성\\n- 기존 파서를 깨뜨리지 않고 형식 확장 가능\\n- 미래의 요구사항에 대비\\n\\n### 7. 변경 가능성\\n- 도구가 diff를 쉽게 열고, 새 데이터를 기록하고, 다시 저장 가능\\n- 메타데이터 수정과 업데이트가 간단\\n\\n## DiffX가 제공하는 것\\n\\n### ✅ 포함되는 기능\\n- diff 파싱을 위한 표준화된 규칙\\n- diff, 커밋, 파일별 메타데이터의 공식적 저장 및 명명\\n- 기존 파서를 깨뜨리지 않는 형식 확장 능력\\n- 하나의 diff 파일에 다중 커밋 표현\\n- Git 호환 바이너리 콘텐츠 diff\\n- 파일과 diff 메타데이터의 텍스트 인코딩 정보\\n- 모든 기존 파서 및 패처와의 호환성\\n- diff 내용의 변경 및 수정 가능성\\n\\n### ❌ DiffX의 목표가 아닌 것\\n- 모든 도구가 새로운 파일 형식을 지원하도록 강제\\n- 기존 diff를 새 도구에서 깨뜨리거나 도구 재작성 요구\\n- 벤더 락인 생성\\n\\n:::warning[호환성 주의사항]\\nDiffX의 새로운 기능들은 해당 기능을 지원하는 도구에서만 완전히 활용할 수 있습니다. 하지만 기본적인 diff 기능은 모든 기존 도구에서 정상 동작합니다[^2].\\n:::\\n\\n## 현재 상황과 향후 계획\\n\\n### 구현체\\n- **Python**: [pydiffx](https://github.com/beanbaginc/pydiffx) - 공식 Python 구현체[^3]\\n\\n### 사용 중인 제품\\n- **Review Board** (Beanbag): DiffX로 기존 diff 관련 문제들을 해결하고 모든 제품에 지원 추가 예정[^4]\\n\\n### 개발 현황\\n현재 DiffX는 활발히 개발되고 있는 오픈소스 프로젝트입니다. Beanbag에서 주도하고 있으며, Review Board의 실제 운영 환경에서 검증되고 있습니다.\\n\\n## 참고 자료\\n\\n### 공식 문서\\n- [DiffX 공식 웹사이트](https://diffx.org/) - 프로젝트 홈페이지\\n- [DiffX 파일 형식 사양서](https://diffx.org/spec/) - 기술 사양 상세 문서\\n- [DiffX 예제 파일들](https://diffx.org/examples/) - 실제 사용 예시\\n- [FAQ](https://diffx.org/faq/) - 자주 묻는 질문\\n\\n### 배경 자료\\n- [Diff의 문제점 상세 분석](https://diffx.org/problems/) - 기존 diff 형식의 문제점\\n- [GNU diff 문서](https://www.gnu.org/software/diffutils/) - 전통적인 diff 도구\\n- [Git diff 형식 문서](https://git-scm.com/docs/git-diff) - Git diff 형식 설명\\n\\n### 관련 프로젝트\\n- [Review Board](https://www.reviewboard.org/) - 코드 리뷰 도구\\n- [Beanbag, Inc.](https://www.beanbaginc.com/) - DiffX 개발사\\n\\n## 결론\\n\\nDiffX는 현대적 소프트웨어 개발의 요구사항을 충족하면서도 기존 생태계와의 호환성을 유지하는 차세대 diff 형식입니다. 구조화된 메타데이터, 다중 커밋 지원, 바이너리 처리 등의 기능을 통해 개발 도구들이 더 풍부한 정보를 활용할 수 있게 해줍니다.\\n\\n기존 Unified Diff의 관용적 특성을 활용하여 점진적 채택이 가능하며, 도구 개발자와 사용자 모두에게 이익을 제공하는 실용적인 해결책입니다.\\n\\n---\\n\\n## 각주\\n\\n[^1]: GNU diff utilities - https://www.gnu.org/software/diffutils/\\n[^2]: DiffX 공식 사양서 - https://diffx.org/spec/\\n[^3]: pydiffx GitHub 저장소 - https://github.com/beanbaginc/pydiffx\\n[^4]: Review Board 공식 웹사이트 - https://www.reviewboard.org/\\n[^5]: The Problems with Diffs - https://diffx.org/problems/"},{"id":"lm-studio-local-ai-guide","metadata":{"permalink":"/blog/lm-studio-local-ai-guide","source":"@site/blog/2025-06-02-post-2/index.md","title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","description":"LM Studio를 사용해 로컬 PC에서 AI 언어모델을 안전하고 비용 효율적으로 실행하는 완벽 가이드. 설치부터 활용까지 모든 과정을 상세히 소개합니다.","date":"2025-06-02T13:00:00.000Z","tags":[{"inline":true,"label":"ai","permalink":"/blog/tags/ai"},{"inline":true,"label":"llm","permalink":"/blog/tags/llm"},{"inline":true,"label":"lm-studio","permalink":"/blog/tags/lm-studio"},{"inline":true,"label":"local-ai","permalink":"/blog/tags/local-ai"},{"inline":true,"label":"machine-learning","permalink":"/blog/tags/machine-learning"}],"readingTime":5,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","date":"2025-06-02T13:00:00","authors":["jypark"],"image":"/img/blog/lm-studio-hero.png","tags":["ai","llm","lm-studio","local-ai","machine-learning"],"description":"LM Studio를 사용해 로컬 PC에서 AI 언어모델을 안전하고 비용 효율적으로 실행하는 완벽 가이드. 설치부터 활용까지 모든 과정을 상세히 소개합니다.","slug":"lm-studio-local-ai-guide","hide_table_of_contents":false,"hide_reading_time":false},"unlisted":false,"prevItem":{"title":"DiffX: 확장 가능한 차세대 Diff 형식","permalink":"/blog/diffx-next-generation-extensible-diff-format"},"nextItem":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","permalink":"/blog/csharp-thread-parallel-foreach-safe-cancellation"}},"content":"![LM Studio Hero](/img/blog/lm-studio-hero.webp)\\n\\nAI와 LLM(대규모 언어 모델)에 관심이 있지만, 클라우드 서비스의 비용이나 개인정보 유출이 걱정된다면? **LM Studio**는 로컬 컴퓨터에서 직접 LLM을 실행하고 실험할 수 있게 해주는 강력한 데스크탑 애플리케이션입니다.\\n\\n> **TL;DR**: LM Studio는 내 PC에서 오프라인으로 AI 언어모델을 실행할 수 있는 사용자 친화적인 데스크탑 앱입니다. 개인정보 보호와 비용 절약을 동시에 해결하며, 복잡한 설정 없이 다양한 오픈소스 AI 모델을 쉽게 체험할 수 있습니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n## LM Studio란?\\n\\nLM Studio는 Windows, macOS, Linux 등 다양한 운영체제에서 동작하며, 인터넷 연결 없이도 LLM을 내 PC에서 실행할 수 있는 프로그램입니다. Hugging Face 등에서 공개된 다양한 오픈소스 AI 모델(Llama, MPT, StarCoder 등)을 쉽게 다운로드하고, 설치와 구동까지 한 번에 처리할 수 있습니다.\\n\\nChatGPT처럼 대화형 인터페이스를 제공해 누구나 쉽게 AI와 채팅하거나 실험해볼 수 있으며, 개발자라면 OpenAI API와 호환되는 로컬 서버 기능도 활용할 수 있습니다.\\n\\n## 주요 특징과 장점\\n\\n### 🔒 완전 오프라인 사용\\n모델 다운로드 후에는 인터넷 없이도 AI를 사용할 수 있어 개인정보 보호에 탁월합니다. 민감한 데이터나 기업 내부 정보를 다룰 때 특히 유용합니다.\\n\\n### 🎨 사용자 친화적 UI\\n복잡한 명령어나 설정 없이도 직관적인 그래픽 인터페이스에서 모델 검색, 다운로드, 실행, 채팅이 가능합니다. 기술적 배경이 없어도 쉽게 시작할 수 있습니다.\\n\\n### 🤖 다양한 모델 지원\\nHugging Face의 다양한 GGML/GGUF 포맷 모델을 지원하며, 여러 모델을 동시에 로드해 비교하거나 용도별로 활용할 수 있습니다.\\n\\n### 🌐 로컬 서버 기능\\nOpenAI API와 호환되는 로컬 HTTP 서버를 제공해, 기존 OpenAI API를 사용하는 애플리케이션과도 쉽게 연동할 수 있습니다.\\n\\n### 💰 비용 효율성\\n클라우드 기반 AI 서비스 대비 훨씬 저렴하게, 혹은 무료로 LLM을 활용할 수 있습니다. 초기 하드웨어 투자 후에는 추가 비용이 거의 발생하지 않습니다.\\n\\n## 설치 및 시작 방법\\n\\n### 1. 다운로드 및 설치\\nLM Studio 공식 홈페이지([lmstudio.ai](https://lmstudio.ai))에서 자신의 OS에 맞는 설치 파일을 다운로드합니다. 설치 과정은 일반적인 데스크탑 애플리케이션과 동일하게 간단합니다.\\n\\n![LM Studio 실행 화면](./lm-studio-ui.webp)\\n\\n### 2. 모델 다운로드\\n프로그램을 실행하면 인기 모델을 추천받거나 직접 검색해 다운로드할 수 있습니다. 처음 사용자라면 Llama 2 7B 모델부터 시작하는 것을 권장합니다.\\n\\n:::warning[시스템 메모리 확인 필수]\\n사용하는 시스템의 비디오 메모리에 따라 실행할 수 있는 모델의 용량이 제한됩니다. 모델을 다운로드하기 전에 시스템의 VRAM을 먼저 확인하세요.\\n:::\\n\\n![모델 다운로드 화면](./model-download.webp)\\n\\n### 3. 모델 실행 및 채팅\\n모델을 다운로드한 후에는 채팅 UI에서 바로 AI와 대화하거나, 로컬 서버를 시작해 API로도 활용할 수 있습니다.\\n\\n## 실제 테스트 결과\\n\\n### 첫 번째 테스트: DeepSeek R1-distill-qwen-7b\\n\\n4.68GB 크기의 DeepSeek R1-distill-qwen-7b 모델로 첫 테스트를 진행했습니다.\\n\\n![첫 번째 채팅 테스트](./try-chat.webp)\\n\\n한국어로 \\"안녕\\"을 입력했으나, 모델에서는 한국어 \\"안녕!\\"과 함께 알 수 없는 문자가 추가로 출력되었습니다. 한국어 처리에 한계가 있는 것으로 보입니다.\\n\\n### 두 번째 테스트: DeepSeek R1-0528\\n\\n더 최신 버전인 DeepSeek R1-0528 모델로 재테스트를 진행했습니다.\\n\\n![두 번째 채팅 테스트](./try-chat-2.webp)\\n\\n간단한 질문에 28.31초가 소요되었지만, 정상적인 한글 문장으로 답변이 생성되었습니다. 오프라인 환경에서 로컬 노트북이 AI 답변을 생성한다는 점은 놀랍지만, 응답 속도는 아쉬운 부분입니다.\\n\\n### 테스트 환경\\n\\n![하드웨어 사양](./hardware.webp)\\n\\n테스트에 사용된 노트북은 100만원대의 평범한 AMD CPU 계열 내장그래픽으로, VRAM이 512MB에 불과해 원활한 테스트에는 한계가 있었습니다. \\n\\n하지만 고성능 하드웨어를 보유한 사용자라면 인터넷 서비스를 거치지 않고 자체 장비에서 AI 모델을 구동하여 채팅은 물론, Cursor나 다른 Llama 계열 API를 사용하는 프로그램과도 연동할 수 있을 것입니다.\\n\\n## 시스템 요구사항\\n\\n### 최소 사양\\n- **macOS**: M1/M2/M3 칩, macOS 13.6 이상\\n- **Windows/Linux**: AVX2 지원 CPU, 8GB RAM, 4GB 이상 VRAM\\n\\n### 권장 사양\\n- **RAM**: 16GB 이상 (큰 모델의 경우 32GB 권장)\\n- **GPU**: NVIDIA RTX 시리즈 또는 Apple Silicon 칩\\n- **저장공간**: 모델 크기에 따라 10GB~100GB 이상\\n\\n더 큰 모델이나 빠른 응답을 원한다면 고성능 GPU와 충분한 메모리가 필수입니다.\\n\\n## LM Studio가 적합한 사용자\\n\\n### 🔬 AI 연구자/개발자\\n다양한 LLM을 실험하고, API 연동을 통해 애플리케이션에 통합하고 싶은 개발자에게 이상적입니다.\\n\\n### 🛡️ 프라이버시 중시 사용자\\n내 데이터가 외부로 전송되지 않는 완전한 오프라인 환경이 필요한 사용자에게 적합합니다.\\n\\n### 🎓 AI 입문자/취미 개발자\\n복잡한 설정 없이 쉽게 LLM을 체험하고 학습하고 싶은 분들에게 훌륭한 시작점이 됩니다.\\n\\n## Ollama와의 비교\\n\\n| 특징           | LM Studio                         | Ollama                |\\n|----------------|-----------------------------------|-----------------------|\\n| 인터페이스     | 그래픽(GUI)                       | 명령줄(CLI)           |\\n| 모델 지원      | 다양한 GGML/GGUF 모델             | 특정 모델 최적화      |\\n| 오픈소스 여부  | 비오픈소스                        | 완전 오픈소스         |\\n| API            | OpenAI 호환 API 제공              | REST API 제공         |\\n| 플랫폼         | Windows, Mac, Linux               | Mac, Linux, Windows   |\\n| 사용 편의성    | 초보자 친화적                     | 개발자 중심           |\\n| 모델 관리      | GUI 기반 직관적 관리              | CLI 명령어 기반       |\\n\\nLM Studio는 GUI를 선호하는 사용자에게, Ollama는 CLI 환경에 익숙한 개발자에게 더 적합합니다.\\n\\n## 실제 활용 사례\\n\\n### 💻 코드 리뷰 및 생성\\nStarCoder나 CodeLlama 모델을 사용해 코드 리뷰, 버그 찾기, 코드 생성 등의 작업을 로컬에서 안전하게 수행할 수 있습니다.\\n\\n### 📝 문서 작성 지원\\n기술 문서, 블로그 포스트, 이메일 등의 작성을 도와주는 개인 AI 어시스턴트로 활용할 수 있습니다.\\n\\n### 🌍 언어 학습 및 번역\\n다양한 언어로 대화하며 언어 학습을 지원하거나, 번역 작업을 수행할 수 있습니다.\\n\\n### 🎯 맞춤형 AI 어시스턴트\\n특정 도메인에 특화된 모델을 사용해 전문 분야의 질문 답변이나 분석 작업을 수행할 수 있습니다.\\n\\n## 성능 최적화 팁\\n\\n### 하드웨어 최적화\\n- **GPU 가속 활용**: CUDA(NVIDIA) 또는 Metal(Apple) 가속을 활성화해 성능 향상\\n- **메모리 관리**: 다른 애플리케이션을 종료해 더 많은 메모리 확보\\n- **SSD 사용**: 모델 로딩 속도 향상을 위해 SSD에 모델 저장\\n\\n### 모델 선택 전략\\n- **7B 모델부터 시작**: 처음에는 작은 모델로 시작해 점진적으로 업그레이드\\n- **양자화 모델 활용**: Q4_K_M, Q5_K_M 등 양자화된 모델로 메모리 사용량 절약\\n- **용도별 모델 선택**: 코딩용, 대화용, 번역용 등 목적에 맞는 모델 선택\\n\\n## 주의사항\\n\\n:::danger[라이선스 확인 필수]\\n상업적 용도로 사용할 경우 각 모델의 라이선스를 반드시 확인하세요. 일부 모델은 상업적 사용이 제한될 수 있습니다.\\n:::\\n\\n### 기타 고려사항\\n- **전력 소비**: 고성능 GPU 사용 시 전력 소비량이 크게 증가할 수 있습니다\\n- **발열 관리**: 장시간 사용 시 시스템 발열에 주의하세요\\n- **모델 업데이트**: 정기적으로 새로운 모델을 확인하고 업데이트하세요\\n\\n## 결론\\n\\nLM Studio는 누구나 쉽고 안전하게 AI 언어모델을 체험하고, 나만의 AI 환경을 구축할 수 있는 최고의 로컬 LLM 도구입니다. 복잡한 설정 없이 내 PC에서 직접 AI를 만나보세요.\\n\\n개인정보 보호, 비용 절약, 사용 편의성을 모두 만족하는 LM Studio로 AI의 새로운 가능성을 탐험해보시기 바랍니다. 특히 개발자라면 로컬 API 서버 기능을 통해 기존 워크플로우에 쉽게 통합할 수 있어 더욱 유용할 것입니다.\\n\\n## 참고 자료\\n\\n- [LM Studio 공식 홈페이지](https://lmstudio.ai)\\n- [Hugging Face 모델 허브](https://huggingface.co/models)\\n- [GGML/GGUF 포맷 가이드](https://github.com/ggerganov/ggml)\\n- [LM Studio 공식 문서](https://lmstudio.ai/docs)\\n- [로컬 LLM 성능 벤치마크](https://github.com/ggerganov/llama.cpp)"},{"id":"csharp-thread-parallel-foreach-safe-cancellation","metadata":{"permalink":"/blog/csharp-thread-parallel-foreach-safe-cancellation","source":"@site/blog/2025-06-02/index.md","title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","description":"C#에서 Thread.Abort() 없이 Thread와 Parallel.ForEach를 안전하게 중단하는 방법을 CancellationToken과 플래그 패턴으로 알아봅니다.","date":"2025-06-02T09:00:00.000Z","tags":[{"inline":true,"label":"csharp","permalink":"/blog/tags/csharp"},{"inline":true,"label":"dotnet","permalink":"/blog/tags/dotnet"},{"inline":true,"label":"threading","permalink":"/blog/tags/threading"},{"inline":true,"label":"parallel","permalink":"/blog/tags/parallel"}],"readingTime":8.04,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2025-06-02T09:00:00","authors":["jypark"],"image":"/img/blog/safe-thread-cancellation-in-csharp.webp","tags":["csharp","dotnet","threading","parallel"],"description":"C#에서 Thread.Abort() 없이 Thread와 Parallel.ForEach를 안전하게 중단하는 방법을 CancellationToken과 플래그 패턴으로 알아봅니다.","slug":"csharp-thread-parallel-foreach-safe-cancellation"},"unlisted":false,"prevItem":{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","permalink":"/blog/lm-studio-local-ai-guide"},"nextItem":{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","permalink":"/blog/supabase-complete-guide-firebase-alternative"}},"content":"![safe-thread-cancellation-in-csharp](/img/blog/safe-thread-cancellation-in-csharp.webp)\\n멀티스레딩 환경에서 작업을 안전하게 중단하는 것은 중요한 과제입니다. 특히 C#에서 Thread.Abort()가 .NET 5 이상에서 지원되지 않으면서, 안전한 중단 방법에 대한 이해가 더욱 중요해졌습니다.\\n\\n> **TL;DR**: Thread.Abort() 대신 CancellationToken이나 플래그 패턴을 사용하여 Thread와 Parallel.ForEach를 안전하게 중단할 수 있습니다. 이 방법들은 리소스 누수와 데이터 손상을 방지하며 .NET의 표준 취소 패턴을 따릅니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n이 글은 2016년도에 C#(.NET Framework 4.5 기반) 프로젝트를 진행하면서 작성했던 [멀티스레드 중단 처리 포스트](https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-cancellation)의 업데이트 버전입니다. .NET 5부터 Thread.Abort()가 공식적으로 obsolete되면서 기존 내용이 현재 환경에 맞지 않게 되어, .NET Framework 4.8부터 최신 .NET까지 모든 환경에서 사용할 수 있는 안전한 중단 방법들을 정리했습니다.\\n\\n## Thread.Abort()를 사용하면 안 되는 이유\\n\\nThread.Abort()는 여러 심각한 문제를 야기할 수 있습니다:\\n\\n- **.NET 5 이상에서 지원 중단**: 더 이상 사용할 수 없는 방법입니다\\n- **리소스 누수**: 파일 핸들, 데이터베이스 연결 등이 제대로 해제되지 않을 수 있습니다\\n- **데이터 손상**: 작업 중간에 강제 종료되어 일관성이 깨질 수 있습니다\\n- **예측 불가능한 동작**: ThreadAbortException이 예상치 못한 곳에서 발생할 수 있습니다\\n\\n:::danger[Thread.Abort() 사용 금지]\\n\\nThread.Abort()는 .NET 5 이상에서 지원되지 않으며, 이전 버전에서도 안전하지 않습니다. 절대 사용하지 마세요.\\n\\n:::\\n\\n## Thread 안전하게 중단하기\\n\\n### 1. 플래그 패턴 사용\\n\\n가장 간단한 방법은 boolean 플래그를 사용하는 것입니다:\\n\\n```csharp title=\\"플래그 패턴을 사용한 Thread 중단\\" showLineNumbers\\npublic class SafeThread\\n{\\n    private volatile bool _stopRequested = false;\\n    private Thread _thread;\\n\\n    public void Start()\\n    {\\n        _thread = new Thread(DoWork);\\n        _thread.Start();\\n    }\\n\\n    public void Stop()\\n    {\\n        _stopRequested = true;\\n        _thread?.Join(); // 스레드가 완전히 종료될 때까지 대기\\n    }\\n\\n    private void DoWork()\\n    {\\n        while (!_stopRequested)\\n        {\\n            // 실제 작업 수행\\n            ProcessItem();\\n            \\n            // 주기적으로 중단 요청 확인\\n            if (_stopRequested)\\n                break;\\n                \\n            Thread.Sleep(100); // 예시: 100ms 대기\\n        }\\n        \\n        Console.WriteLine(\\"스레드가 안전하게 종료되었습니다.\\");\\n    }\\n\\n    private void ProcessItem()\\n    {\\n        // 실제 작업 로직\\n        Console.WriteLine($\\"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})\\");\\n    }\\n}\\n```\\n\\n### 2. CancellationToken 사용 (권장)\\n\\n.NET의 표준 취소 패턴인 CancellationToken을 사용하는 방법입니다 (.NET Framework 4.0 이상):\\n\\n```csharp title=\\"CancellationToken을 사용한 Thread 중단\\" showLineNumbers\\npublic class CancellableThread\\n{\\n    private Thread _thread;\\n    private CancellationTokenSource _cancellationTokenSource;\\n\\n    public void Start()\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        _thread = new Thread(() => DoWork(_cancellationTokenSource.Token));\\n        _thread.Start();\\n    }\\n\\n    public void Stop()\\n    {\\n        _cancellationTokenSource?.Cancel();\\n        _thread?.Join();\\n        _cancellationTokenSource?.Dispose();\\n    }\\n\\n    private void DoWork(CancellationToken cancellationToken)\\n    {\\n        try\\n        {\\n            while (!cancellationToken.IsCancellationRequested)\\n            {\\n                ProcessItem();\\n                \\n                // 취소 요청 확인 및 예외 발생\\n                cancellationToken.ThrowIfCancellationRequested();\\n                \\n                // 취소 가능한 대기 (.NET Framework 4.8에서는 Thread.Sleep 사용)\\n                if (cancellationToken.WaitHandle.WaitOne(100))\\n                {\\n                    break; // 취소 요청됨\\n                }\\n            }\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"작업이 취소되었습니다.\\");\\n        }\\n        finally\\n        {\\n            Console.WriteLine(\\"스레드가 안전하게 종료되었습니다.\\");\\n        }\\n    }\\n\\n    private void ProcessItem()\\n    {\\n        Console.WriteLine($\\"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})\\");\\n    }\\n}\\n```\\n\\n## Parallel.ForEach 안전하게 중단하기\\n\\nParallel.ForEach는 ParallelOptions를 통해 CancellationToken을 지원합니다 (.NET Framework 4.0 이상):\\n\\n```csharp title=\\"CancellationToken을 사용한 Parallel.ForEach 중단\\" showLineNumbers\\npublic class ParallelProcessor\\n{\\n    public async Task ProcessItemsAsync(IEnumerable<int> items)\\n    {\\n        var cancellationTokenSource = new CancellationTokenSource();\\n        \\n        // 5초 후 자동 취소 (예시)\\n        cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(5));\\n        \\n        var parallelOptions = new ParallelOptions\\n        {\\n            CancellationToken = cancellationTokenSource.Token,\\n            MaxDegreeOfParallelism = Environment.ProcessorCount\\n        };\\n\\n        try\\n        {\\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\\n            {\\n                // 각 반복에서 취소 요청 확인\\n                parallelOptions.CancellationToken.ThrowIfCancellationRequested();\\n                \\n                ProcessSingleItem(item, parallelOptions.CancellationToken);\\n            });\\n            \\n            Console.WriteLine(\\"모든 작업이 완료되었습니다.\\");\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"병렬 작업이 취소되었습니다.\\");\\n        }\\n        finally\\n        {\\n            cancellationTokenSource.Dispose();\\n        }\\n    }\\n\\n    private void ProcessSingleItem(int item, CancellationToken cancellationToken)\\n    {\\n        // 긴 작업 시뮬레이션\\n        for (int i = 0; i < 10; i++)\\n        {\\n            cancellationToken.ThrowIfCancellationRequested();\\n            \\n            Thread.Sleep(100); // 실제 작업 시뮬레이션\\n            Console.WriteLine($\\"Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})\\");\\n        }\\n    }\\n}\\n```\\n\\n### 외부에서 수동으로 취소하기\\n\\n사용자 입력이나 다른 조건에 따라 수동으로 취소하는 예시입니다:\\n\\n```csharp title=\\"수동 취소가 가능한 병렬 처리\\" showLineNumbers\\npublic class ManualCancellationExample\\n{\\n    private CancellationTokenSource _cancellationTokenSource;\\n\\n    public async Task StartProcessingAsync()\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        var items = Enumerable.Range(1, 1000);\\n\\n        var parallelOptions = new ParallelOptions\\n        {\\n            CancellationToken = _cancellationTokenSource.Token,\\n            MaxDegreeOfParallelism = 4\\n        };\\n\\n        try\\n        {\\n            await Task.Run(() =>\\n            {\\n                Parallel.ForEach(items, parallelOptions, (item, loopState) =>\\n                {\\n                    parallelOptions.CancellationToken.ThrowIfCancellationRequested();\\n                    \\n                    // 무거운 작업 시뮬레이션\\n                    Thread.Sleep(200);\\n                    Console.WriteLine($\\"처리 완료: {item}\\");\\n                });\\n            });\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"사용자에 의해 작업이 취소되었습니다.\\");\\n        }\\n    }\\n\\n    public void CancelProcessing()\\n    {\\n        _cancellationTokenSource?.Cancel();\\n        Console.WriteLine(\\"취소 요청이 전송되었습니다.\\");\\n    }\\n}\\n\\n// 사용 예시\\nclass Program\\n{\\n    static async Task Main(string[] args)\\n    {\\n        var processor = new ManualCancellationExample();\\n        \\n        // 백그라운드에서 처리 시작\\n        var processingTask = processor.StartProcessingAsync();\\n        \\n        Console.WriteLine(\\"Enter 키를 누르면 작업을 취소합니다...\\");\\n        Console.ReadLine();\\n        \\n        // 사용자 입력으로 취소\\n        processor.CancelProcessing();\\n        \\n        await processingTask;\\n        Console.WriteLine(\\"프로그램이 종료되었습니다.\\");\\n    }\\n}\\n```\\n\\n## .NET Framework 4.8 호환 버전\\n\\n.NET Framework 4.8에서는 일부 최신 API가 없어서 약간 다른 접근이 필요합니다:\\n\\n```csharp title=\\".NET Framework 4.8 호환 CancellationToken 사용\\" showLineNumbers\\npublic class NetFramework48Thread\\n{\\n    private Thread _thread;\\n    private CancellationTokenSource _cancellationTokenSource;\\n\\n    public void Start()\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        _thread = new Thread(() => DoWork(_cancellationTokenSource.Token));\\n        _thread.Start();\\n    }\\n\\n    public void Stop()\\n    {\\n        _cancellationTokenSource?.Cancel();\\n        _thread?.Join();\\n        _cancellationTokenSource?.Dispose();\\n    }\\n\\n    private void DoWork(CancellationToken cancellationToken)\\n    {\\n        try\\n        {\\n            while (!cancellationToken.IsCancellationRequested)\\n            {\\n                ProcessItem();\\n                \\n                // 취소 요청 확인\\n                cancellationToken.ThrowIfCancellationRequested();\\n                \\n                // .NET Framework 4.8에서 취소 가능한 대기\\n                // Task.Delay 대신 WaitHandle 사용\\n                if (cancellationToken.WaitHandle.WaitOne(100))\\n                {\\n                    break; // 취소 요청됨\\n                }\\n            }\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"작업이 취소되었습니다.\\");\\n        }\\n        finally\\n        {\\n            Console.WriteLine(\\"스레드가 안전하게 종료되었습니다.\\");\\n        }\\n    }\\n\\n    private void ProcessItem()\\n    {\\n        Console.WriteLine($\\"작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})\\");\\n    }\\n}\\n```\\n\\n### .NET Framework 4.8에서 Parallel.ForEach 사용\\n\\n```csharp title=\\".NET Framework 4.8 Parallel.ForEach 예제\\" showLineNumbers\\npublic class NetFramework48ParallelProcessor\\n{\\n    public void ProcessItems(IEnumerable<int> items)\\n    {\\n        var cancellationTokenSource = new CancellationTokenSource();\\n        \\n        // 5초 후 자동 취소\\n        var timer = new System.Threading.Timer(_ => cancellationTokenSource.Cancel(), \\n                                               null, 5000, Timeout.Infinite);\\n        \\n        var parallelOptions = new ParallelOptions\\n        {\\n            CancellationToken = cancellationTokenSource.Token,\\n            MaxDegreeOfParallelism = Environment.ProcessorCount\\n        };\\n\\n        try\\n        {\\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\\n            {\\n                parallelOptions.CancellationToken.ThrowIfCancellationRequested();\\n                \\n                ProcessSingleItem(item, parallelOptions.CancellationToken);\\n            });\\n            \\n            Console.WriteLine(\\"모든 작업이 완료되었습니다.\\");\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"병렬 작업이 취소되었습니다.\\");\\n        }\\n        finally\\n        {\\n            timer?.Dispose();\\n            cancellationTokenSource.Dispose();\\n        }\\n    }\\n\\n    private void ProcessSingleItem(int item, CancellationToken cancellationToken)\\n    {\\n        for (int i = 0; i < 10; i++)\\n        {\\n            cancellationToken.ThrowIfCancellationRequested();\\n            \\n            Thread.Sleep(100);\\n            Console.WriteLine($\\"Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})\\");\\n        }\\n    }\\n}\\n```\\n\\n### .NET Framework 4.8에서 Task 기반 접근\\n\\n.NET Framework 4.8에서는 Task를 사용한 접근도 가능합니다:\\n\\n```csharp title=\\".NET Framework 4.8 Task 기반 처리\\" showLineNumbers\\npublic class NetFramework48TaskProcessor\\n{\\n    private CancellationTokenSource _cancellationTokenSource;\\n\\n    public async Task StartProcessingAsync()\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        var items = Enumerable.Range(1, 1000);\\n\\n        try\\n        {\\n            // .NET Framework 4.8에서는 Task.Run 대신 Task.Factory.StartNew 사용 권장\\n            await Task.Factory.StartNew(() =>\\n            {\\n                var parallelOptions = new ParallelOptions\\n                {\\n                    CancellationToken = _cancellationTokenSource.Token,\\n                    MaxDegreeOfParallelism = 4\\n                };\\n\\n                Parallel.ForEach(items, parallelOptions, (item, loopState) =>\\n                {\\n                    parallelOptions.CancellationToken.ThrowIfCancellationRequested();\\n                    \\n                    Thread.Sleep(200);\\n                    Console.WriteLine($\\"처리 완료: {item}\\");\\n                });\\n            }, _cancellationTokenSource.Token);\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"사용자에 의해 작업이 취소되었습니다.\\");\\n        }\\n    }\\n\\n    public void CancelProcessing()\\n    {\\n        _cancellationTokenSource?.Cancel();\\n        Console.WriteLine(\\"취소 요청이 전송되었습니다.\\");\\n    }\\n}\\n```\\n\\n## Thread와 Parallel.ForEach 조합하기\\n\\n별도 스레드에서 Parallel.ForEach를 실행하고 전체를 안전하게 중단하는 방법입니다:\\n\\n```csharp title=\\"Thread 내에서 Parallel.ForEach 사용\\" showLineNumbers\\npublic class ThreadedParallelProcessor\\n{\\n    private Thread _workerThread;\\n    private CancellationTokenSource _cancellationTokenSource;\\n\\n    public void Start(IEnumerable<int> items)\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        _workerThread = new Thread(() => ProcessInBackground(items, _cancellationTokenSource.Token));\\n        _workerThread.Start();\\n    }\\n\\n    public void Stop()\\n    {\\n        _cancellationTokenSource?.Cancel();\\n        _workerThread?.Join(TimeSpan.FromSeconds(10)); // 최대 10초 대기\\n        _cancellationTokenSource?.Dispose();\\n    }\\n\\n    private void ProcessInBackground(IEnumerable<int> items, CancellationToken cancellationToken)\\n    {\\n        try\\n        {\\n            var parallelOptions = new ParallelOptions\\n            {\\n                CancellationToken = cancellationToken,\\n                MaxDegreeOfParallelism = Environment.ProcessorCount / 2\\n            };\\n\\n            Parallel.ForEach(items, parallelOptions, (item, loopState) =>\\n            {\\n                cancellationToken.ThrowIfCancellationRequested();\\n                \\n                // 실제 작업 처리\\n                ProcessItem(item, cancellationToken);\\n            });\\n            \\n            Console.WriteLine(\\"백그라운드 처리가 완료되었습니다.\\");\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"백그라운드 작업이 취소되었습니다.\\");\\n        }\\n    }\\n\\n    private void ProcessItem(int item, CancellationToken cancellationToken)\\n    {\\n        // 긴 작업 중간중간 취소 확인\\n        for (int i = 0; i < 5; i++)\\n        {\\n            cancellationToken.ThrowIfCancellationRequested();\\n            Thread.Sleep(100);\\n        }\\n        \\n        Console.WriteLine($\\"Item {item} 처리 완료\\");\\n    }\\n}\\n```\\n\\n## .NET Framework vs .NET 5+ 차이점\\n\\n### API 차이점 요약\\n\\n| 기능 | .NET Framework 4.8 | .NET 5+ |\\n|------|-------------------|---------|\\n| CancellationToken | ✅ 지원 | ✅ 지원 |\\n| Task.Delay with CancellationToken | ❌ 제한적 | ✅ 완전 지원 |\\n| Task.Run | ❌ 없음 | ✅ 지원 |\\n| CancellationTokenSource.CancelAfter | ❌ 없음 | ✅ 지원 |\\n| Thread.Abort | ⚠️ 사용 가능하지만 위험 | ❌ Obsolete |\\n\\n### .NET Framework 4.8 권장 패턴\\n\\n```csharp title=\\".NET Framework 4.8 권장 패턴\\" showLineNumbers\\npublic class RecommendedNetFramework48Pattern\\n{\\n    private readonly CancellationTokenSource _cancellationTokenSource;\\n    private readonly ManualResetEventSlim _completedEvent;\\n\\n    public RecommendedNetFramework48Pattern()\\n    {\\n        _cancellationTokenSource = new CancellationTokenSource();\\n        _completedEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void StartWork()\\n    {\\n        Task.Factory.StartNew(() => DoWork(_cancellationTokenSource.Token), \\n                             _cancellationTokenSource.Token,\\n                             TaskCreationOptions.LongRunning,\\n                             TaskScheduler.Default);\\n    }\\n\\n    public void StopWork(int timeoutMs = 5000)\\n    {\\n        _cancellationTokenSource.Cancel();\\n        \\n        if (!_completedEvent.Wait(timeoutMs))\\n        {\\n            Console.WriteLine(\\"작업이 제한 시간 내에 완료되지 않았습니다.\\");\\n        }\\n    }\\n\\n    private void DoWork(CancellationToken cancellationToken)\\n    {\\n        try\\n        {\\n            while (!cancellationToken.IsCancellationRequested)\\n            {\\n                // 실제 작업 수행\\n                ProcessWorkItem();\\n                \\n                // 주기적 취소 확인 (.NET Framework 4.8 호환)\\n                if (cancellationToken.WaitHandle.WaitOne(100))\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        catch (OperationCanceledException)\\n        {\\n            Console.WriteLine(\\"작업이 취소되었습니다.\\");\\n        }\\n        finally\\n        {\\n            _completedEvent.Set();\\n            Console.WriteLine(\\"작업이 완료되었습니다.\\");\\n        }\\n    }\\n\\n    private void ProcessWorkItem()\\n    {\\n        // 실제 작업 로직\\n        Thread.Sleep(50);\\n        Console.WriteLine($\\"작업 처리 중... (Thread: {Thread.CurrentThread.ManagedThreadId})\\");\\n    }\\n\\n    public void Dispose()\\n    {\\n        _cancellationTokenSource?.Dispose();\\n        _completedEvent?.Dispose();\\n    }\\n}\\n```\\n\\n## 성능 고려사항\\n\\n### 취소 확인 빈도\\n\\n취소 확인을 너무 자주 하면 성능에 영향을 줄 수 있습니다:\\n\\n```csharp title=\\"효율적인 취소 확인\\" showLineNumbers\\nprivate void OptimizedWork(CancellationToken cancellationToken)\\n{\\n    const int checkInterval = 100; // 100번 작업마다 한 번씩 확인\\n    int counter = 0;\\n\\n    while (true)\\n    {\\n        // 실제 작업\\n        DoSomeWork();\\n        \\n        // 주기적으로만 취소 확인\\n        if (++counter % checkInterval == 0)\\n        {\\n            cancellationToken.ThrowIfCancellationRequested();\\n        }\\n    }\\n}\\n```\\n\\n### 리소스 정리\\n\\n취소 시에도 리소스가 제대로 정리되도록 해야 합니다:\\n\\n```csharp title=\\"리소스 안전 정리\\" showLineNumbers\\nprivate void SafeResourceHandling(CancellationToken cancellationToken)\\n{\\n    using var fileStream = new FileStream(\\"data.txt\\", FileMode.Open);\\n    using var reader = new StreamReader(fileStream);\\n    \\n    try\\n    {\\n        while (!reader.EndOfStream)\\n        {\\n            cancellationToken.ThrowIfCancellationRequested();\\n            \\n            var line = reader.ReadLine();\\n            ProcessLine(line);\\n        }\\n    }\\n    catch (OperationCanceledException)\\n    {\\n        Console.WriteLine(\\"파일 처리가 취소되었습니다.\\");\\n        // using 문에 의해 자동으로 리소스 정리됨\\n    }\\n}\\n```\\n\\n## 결론\\n\\nC#에서 Thread와 Parallel.ForEach를 안전하게 중단하는 핵심은 다음과 같습니다:\\n\\n1. **Thread.Abort() 사용 금지**: .NET 5 이상에서 지원되지 않으며, .NET Framework에서도 안전하지 않습니다\\n2. **CancellationToken 활용**: .NET Framework 4.0부터 지원되는 표준 취소 패턴으로 가장 권장되는 방법입니다\\n3. **플래그 패턴**: 간단한 시나리오에서 사용할 수 있는 대안입니다\\n4. **프레임워크별 차이점 고려**: .NET Framework 4.8과 .NET 5+ 간의 API 차이를 이해해야 합니다\\n5. **적절한 취소 확인**: 성능과 반응성의 균형을 맞춰야 합니다\\n6. **리소스 정리**: 취소 시에도 모든 리소스가 안전하게 해제되도록 해야 합니다\\n\\n이러한 패턴들을 사용하면 리소스 누수나 데이터 손상 없이 멀티스레딩 작업을 안전하게 제어할 수 있습니다. 특히 장시간 실행되는 백그라운드 작업이나 사용자가 중단할 수 있는 작업에서는 반드시 이런 안전한 중단 메커니즘을 구현해야 합니다.\\n\\n## 참고 자료\\n\\n### 공식 문서\\n- [Thread.Abort Method - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.abort) - Thread.Abort() 메서드 공식 문서 및 지원 중단 안내\\n- [CancellationToken Struct - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken) - CancellationToken 구조체 공식 문서\\n- [Parallel.ForEach Method - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreach) - Parallel.ForEach 메서드 공식 문서\\n- [Cancellation in Managed Threads - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads) - 관리되는 스레드에서의 취소 패턴 가이드\\n\\n### 관련 기술 문서\\n- [Task-based Asynchronous Pattern (TAP) - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap) - 비동기 프로그래밍 패턴\\n- [Parallel Programming in .NET - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/) - .NET 병렬 프로그래밍 가이드\\n- [Best Practices for Managed Threading - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices) - 관리되는 스레딩 모범 사례\\n\\n### 추가 학습 자료\\n- [Stephen Cleary\'s Blog - Async/Await Best Practices](https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html) - 비동기 코드 모범 사례\\n- [Eric Lippert\'s Blog - Cancellation](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/) - 취소 패턴에 대한 심화 설명"},{"id":"supabase-complete-guide-firebase-alternative","metadata":{"permalink":"/blog/supabase-complete-guide-firebase-alternative","source":"@site/blog/2025-05-30-post/index.md","title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","description":"Supabase는 PostgreSQL 기반의 오픈소스 백엔드 플랫폼으로, Firebase의 강력한 대안입니다. 실시간 데이터베이스, 인증, 스토리지, Edge Functions까지 한 번에 해결하는 방법을 소개합니다.","date":"2025-05-30T00:00:00.000Z","tags":[{"inline":true,"label":"supabase","permalink":"/blog/tags/supabase"},{"inline":true,"label":"firebase","permalink":"/blog/tags/firebase"},{"inline":true,"label":"postgresql","permalink":"/blog/tags/postgresql"},{"inline":true,"label":"backend","permalink":"/blog/tags/backend"},{"inline":true,"label":"database","permalink":"/blog/tags/database"},{"inline":true,"label":"realtime","permalink":"/blog/tags/realtime"}],"readingTime":15.01,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","date":"2025-05-30","authors":["jypark"],"image":"/img/blog/supabase-guide.webp","tags":["supabase","firebase","postgresql","backend","database","realtime"],"description":"Supabase는 PostgreSQL 기반의 오픈소스 백엔드 플랫폼으로, Firebase의 강력한 대안입니다. 실시간 데이터베이스, 인증, 스토리지, Edge Functions까지 한 번에 해결하는 방법을 소개합니다.","slug":"supabase-complete-guide-firebase-alternative","hide_table_of_contents":false,"hide_reading_time":false},"unlisted":false,"prevItem":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","permalink":"/blog/csharp-thread-parallel-foreach-safe-cancellation"},"nextItem":{"title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","permalink":"/blog/tailwind-css-v4-complete-guide"}},"content":"![supabase 완벽 가이드](/img/blog/supabase-guide.webp)\\n\\n> **TL;DR**: **Supabase**는 PostgreSQL 기반의 오픈소스 백엔드 플랫폼으로, Firebase의 완벽한 대안입니다. **실시간 데이터베이스**, **인증 시스템**, **파일 스토리지**, **Edge Functions**를 통합 제공하며, SQL의 강력함과 NoSQL의 편의성을 동시에 제공합니다.\\n\\nSupabase는 \\"오픈소스 Firebase 대안\\"이라는 슬로건으로 시작해 현재 개발자들 사이에서 가장 주목받는 백엔드 서비스 중 하나로 자리잡았습니다. PostgreSQL을 기반으로 한 견고한 데이터베이스 인프라와 현대적인 개발자 경험을 제공하며, **2백만 명 이상의 개발자**가 사용하고 있는 플랫폼입니다.\\n\\n특히 **관계형 데이터베이스의 강력함**과 **NoSQL의 편의성**을 동시에 제공하는 독특한 접근 방식으로, Firebase의 한계를 극복하면서도 더 나은 개발자 경험을 제공합니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Supabase란 무엇인가?\\n\\n### 핵심 개념과 철학\\n\\nSupabase는 2020년에 창립된 회사로, **\\"The Open Source Firebase Alternative\\"**라는 명확한 비전을 가지고 시작되었습니다. 하지만 단순한 Firebase 클론이 아닌, **PostgreSQL의 강력함을 기반으로 한 더 나은 백엔드 솔루션**을 제공하는 것이 목표입니다.\\n\\n#### Supabase의 핵심 철학\\n\\n1. **오픈소스 우선**: 모든 핵심 기능이 오픈소스로 제공\\n2. **SQL 네이티브**: PostgreSQL의 모든 기능을 그대로 활용\\n3. **개발자 경험 최우선**: 직관적이고 강력한 API 제공\\n4. **확장성**: 스타트업부터 엔터프라이즈까지 모든 규모 지원\\n\\n### Firebase와의 차이점\\n\\n| 기능 | Firebase | Supabase |\\n|------|----------|----------|\\n| **데이터베이스** | NoSQL (Firestore) | PostgreSQL (관계형) |\\n| **쿼리 언어** | 제한적 쿼리 | 완전한 SQL 지원 |\\n| **실시간 기능** | 실시간 리스너 | PostgreSQL 실시간 구독 |\\n| **인증** | Firebase Auth | 자체 인증 + 외부 제공자 |\\n| **스토리지** | Cloud Storage | S3 호환 스토리지 |\\n| **함수** | Cloud Functions | Edge Functions (Deno) |\\n| **오픈소스** | 부분적 | 완전한 오픈소스 |\\n| **벤더 락인** | 높음 | 낮음 (PostgreSQL 표준) |\\n\\n## 주요 기능 심화 분석\\n\\n### 1. PostgreSQL 기반 데이터베이스\\n\\nSupabase의 가장 큰 강점은 **PostgreSQL을 그대로 사용**한다는 점입니다. 이는 단순히 데이터베이스를 제공하는 것을 넘어서, SQL의 모든 강력한 기능을 웹 애플리케이션에서 직접 활용할 수 있게 해줍니다.\\n\\n#### PostgreSQL의 고급 기능 활용\\n\\n```sql title=\\"복잡한 쿼리 예시\\" showLineNumbers\\n-- 복잡한 조인과 집계 쿼리\\nSELECT \\n  u.name,\\n  COUNT(p.id) as post_count,\\n  AVG(p.likes) as avg_likes,\\n  RANK() OVER (ORDER BY COUNT(p.id) DESC) as author_rank\\nFROM users u\\nLEFT JOIN posts p ON u.id = p.author_id\\nWHERE u.created_at >= \'2024-01-01\'\\nGROUP BY u.id, u.name\\nHAVING COUNT(p.id) > 5\\nORDER BY author_rank;\\n\\n-- JSON 필드 쿼리 (PostgreSQL의 강력한 JSON 지원)\\nSELECT *\\nFROM products\\nWHERE metadata->>\'category\' = \'electronics\'\\n  AND (metadata->\'specifications\'->>\'ram\')::int >= 8;\\n\\n-- 전문 검색 (Full-text Search)\\nSELECT *\\nFROM articles\\nWHERE to_tsvector(\'english\', title || \' \' || content) \\n      @@ plainto_tsquery(\'english\', \'javascript performance optimization\');\\n```\\n\\n#### Row Level Security (RLS)\\n\\nSupabase의 보안 모델은 PostgreSQL의 **Row Level Security**를 기반으로 합니다. 이를 통해 데이터베이스 레벨에서 세밀한 권한 제어가 가능합니다.\\n\\n```sql title=\\"RLS 정책 설정\\" showLineNumbers\\n-- 사용자는 자신의 게시물만 볼 수 있도록 설정\\nCREATE POLICY \\"Users can view own posts\\" ON posts\\nFOR SELECT USING (auth.uid() = user_id);\\n\\n-- 관리자는 모든 게시물을 볼 수 있도록 설정\\nCREATE POLICY \\"Admins can view all posts\\" ON posts\\nFOR SELECT USING (\\n  auth.jwt() ->> \'role\' = \'admin\'\\n);\\n\\n-- 게시물 작성자만 수정 가능\\nCREATE POLICY \\"Users can update own posts\\" ON posts\\nFOR UPDATE USING (auth.uid() = user_id);\\n```\\n\\n### 2. 실시간 기능 (Realtime)\\n\\nSupabase의 실시간 기능은 PostgreSQL의 **LISTEN/NOTIFY** 메커니즘을 웹소켓으로 확장한 혁신적인 구현입니다.\\n\\n#### 실시간 구독 구현\\n\\n```typescript title=\\"lib/realtime.ts\\" showLineNumbers\\nimport { createClient } from \'@supabase/supabase-js\'\\n\\nconst supabase = createClient(\\n  process.env.NEXT_PUBLIC_SUPABASE_URL!, \\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\\n)\\n\\n// 특정 테이블의 모든 변경사항 실시간 구독\\nconst subscription = supabase\\n  .channel(\'public:posts\')\\n  .on(\'postgres_changes\', {\\n    event: \'*\', // INSERT, UPDATE, DELETE 모든 이벤트\\n    schema: \'public\',\\n    table: \'posts\'\\n  }, (payload) => {\\n    console.log(\'Change received!\', payload)\\n    // 실시간으로 UI 업데이트\\n    handlePostChange(payload)\\n  })\\n  .subscribe()\\n\\n// 특정 조건에 맞는 데이터만 구독\\nconst filteredSubscription = supabase\\n  .channel(\'public:posts:author_id=eq.123\')\\n  .on(\'postgres_changes\', {\\n    event: \'INSERT\',\\n    schema: \'public\',\\n    table: \'posts\',\\n    filter: \'author_id=eq.123\'\\n  }, (payload) => {\\n    console.log(\'New post from author 123:\', payload.new)\\n  })\\n  .subscribe()\\n\\n// Presence 기능으로 온라인 사용자 추적\\nconst presenceChannel = supabase.channel(\'online-users\', {\\n  config: {\\n    presence: {\\n      key: user.id,\\n    },\\n  },\\n})\\n\\npresenceChannel\\n  .on(\'presence\', { event: \'sync\' }, () => {\\n    const state = presenceChannel.presenceState()\\n    console.log(\'Online users:\', Object.keys(state))\\n  })\\n  .on(\'presence\', { event: \'join\' }, ({ key, newPresences }) => {\\n    console.log(\'User joined:\', key, newPresences)\\n  })\\n  .on(\'presence\', { event: \'leave\' }, ({ key, leftPresences }) => {\\n    console.log(\'User left:\', key, leftPresences)\\n  })\\n  .subscribe()\\n\\n// 사용자 온라인 상태 전송\\npresenceChannel.track({\\n  user_id: user.id,\\n  username: user.username,\\n  last_seen: new Date().toISOString()\\n})\\n```\\n\\n### 3. 인증 시스템 (Auth)\\n\\nSupabase Auth는 **JWT 기반의 현대적인 인증 시스템**으로, 다양한 인증 방식을 지원합니다.\\n\\n#### 이메일/비밀번호 인증\\n\\n```typescript title=\\"lib/auth.ts\\" showLineNumbers\\n// 회원가입\\nconst { data, error } = await supabase.auth.signUp({\\n  email: \'user@example.com\',\\n  password: \'securepassword123\',\\n  options: {\\n    data: {\\n      first_name: \'John\',\\n      last_name: \'Doe\',\\n      age: 27,\\n    }\\n  }\\n})\\n\\n// 로그인\\nconst { data, error } = await supabase.auth.signInWithPassword({\\n  email: \'user@example.com\',\\n  password: \'securepassword123\'\\n})\\n\\n// 로그아웃\\nconst { error } = await supabase.auth.signOut()\\n\\n// 현재 사용자 정보 가져오기\\nconst { data: { user } } = await supabase.auth.getUser()\\n\\n// 사용자 정보 업데이트\\nconst { data, error } = await supabase.auth.updateUser({\\n  data: { \\n    first_name: \'Jane\',\\n    age: 28 \\n  }\\n})\\n```\\n\\n#### 소셜 로그인\\n\\n```typescript title=\\"components/SocialLogin.tsx\\" showLineNumbers\\n// Google 로그인\\nconst { data, error } = await supabase.auth.signInWithOAuth({\\n  provider: \'google\',\\n  options: {\\n    redirectTo: \'https://yourapp.com/dashboard\',\\n    scopes: \'profile email\'\\n  }\\n})\\n\\n// GitHub 로그인\\nconst { data, error } = await supabase.auth.signInWithOAuth({\\n  provider: \'github\'\\n})\\n\\n// 다중 제공자 지원\\nconst providers = [\\n  \'google\', \'github\', \'apple\', \'azure\', \'bitbucket\', \\n  \'discord\', \'facebook\', \'figma\', \'gitlab\', \'linkedin\', \\n  \'notion\', \'slack\', \'spotify\', \'twitch\', \'twitter\', \'workos\'\\n]\\n```\\n\\n#### 인증 상태 관리\\n\\n```typescript title=\\"hooks/useAuth.ts\\" showLineNumbers\\n// React에서 인증 상태 관리\\nimport { useEffect, useState } from \'react\'\\nimport type { User } from \'@supabase/supabase-js\'\\n\\nfunction useAuth() {\\n  const [user, setUser] = useState<User | null>(null)\\n  const [loading, setLoading] = useState(true)\\n\\n  useEffect(() => {\\n    // 초기 세션 가져오기\\n    const getInitialSession = async () => {\\n      const { data: { session } } = await supabase.auth.getSession()\\n      setUser(session?.user ?? null)\\n      setLoading(false)\\n    }\\n\\n    getInitialSession()\\n\\n    // 인증 상태 변경 리스너\\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\\n      (event, session) => {\\n        setUser(session?.user ?? null)\\n        setLoading(false)\\n      }\\n    )\\n\\n    return () => subscription.unsubscribe()\\n  }, [])\\n\\n  return { user, loading }\\n}\\n\\n// 사용 예시\\nfunction App() {\\n  const { user, loading } = useAuth()\\n\\n  if (loading) return <div>Loading...</div>\\n  if (!user) return <LoginForm />\\n  return <Dashboard user={user} />\\n}\\n```\\n\\n### 4. 스토리지 (Storage)\\n\\nSupabase Storage는 **S3 호환 객체 스토리지**로, 파일 업로드, 다운로드, 변환 기능을 제공합니다.\\n\\n#### 파일 업로드 및 관리\\n\\n```typescript title=\\"lib/storage.ts\\" showLineNumbers\\n// 파일 업로드\\nconst uploadFile = async (file: File) => {\\n  const fileExt = file.name.split(\'.\').pop()\\n  const fileName = `${Date.now()}.${fileExt}`\\n  const filePath = `uploads/${fileName}`\\n\\n  const { data, error } = await supabase.storage\\n    .from(\'public-files\')\\n    .upload(filePath, file, {\\n      cacheControl: \'3600\',\\n      upsert: false\\n    })\\n\\n  if (error) {\\n    console.error(\'Upload error:\', error)\\n    return null\\n  }\\n\\n  // 업로드된 파일의 공개 URL 가져오기\\n  const { data: { publicUrl } } = supabase.storage\\n    .from(\'public-files\')\\n    .getPublicUrl(filePath)\\n\\n  return publicUrl\\n}\\n\\n// 이미지 변환 및 최적화\\nconst getOptimizedImageUrl = (path: string, options: {\\n  width?: number\\n  height?: number\\n  quality?: number\\n  format?: \'webp\' | \'jpeg\' | \'png\'\\n} = {}) => {\\n  const { data } = supabase.storage\\n    .from(\'images\')\\n    .getPublicUrl(path, {\\n      transform: {\\n        width: options.width || 800,\\n        height: options.height || 600,\\n        resize: \'cover\',\\n        format: options.format || \'webp\',\\n        quality: options.quality || 80\\n      }\\n    })\\n\\n  return data.publicUrl\\n}\\n\\n// 파일 다운로드\\nconst downloadFile = async (path: string) => {\\n  const { data, error } = await supabase.storage\\n    .from(\'private-files\')\\n    .download(path)\\n\\n  if (error) {\\n    console.error(\'Download error:\', error)\\n    return null\\n  }\\n\\n  // Blob을 URL로 변환\\n  const url = URL.createObjectURL(data)\\n  return url\\n}\\n\\n// 파일 삭제\\nconst deleteFile = async (path: string) => {\\n  const { error } = await supabase.storage\\n    .from(\'public-files\')\\n    .remove([path])\\n\\n  return !error\\n}\\n```\\n\\n#### 보안 및 권한 관리\\n\\n```sql title=\\"스토리지 RLS 정책\\" showLineNumbers\\n-- 스토리지 RLS 정책 설정\\n-- 사용자는 자신의 폴더에만 업로드 가능\\nCREATE POLICY \\"Users can upload to own folder\\" ON storage.objects\\nFOR INSERT WITH CHECK (\\n  bucket_id = \'user-files\' AND \\n  auth.uid()::text = (storage.foldername(name))[1]\\n);\\n\\n-- 사용자는 자신의 파일만 볼 수 있음\\nCREATE POLICY \\"Users can view own files\\" ON storage.objects\\nFOR SELECT USING (\\n  bucket_id = \'user-files\' AND \\n  auth.uid()::text = (storage.foldername(name))[1]\\n);\\n```\\n\\n### 5. Edge Functions\\n\\nSupabase Edge Functions는 **Deno 런타임**을 기반으로 하는 서버리스 함수로, 전 세계 엣지 로케이션에서 실행됩니다.\\n\\n#### Edge Function 예시\\n\\n```typescript title=\\"supabase/functions/send-email/index.ts\\" showLineNumbers\\nimport { serve } from \\"https://deno.land/std@0.168.0/http/server.ts\\"\\nimport { createClient } from \'https://esm.sh/@supabase/supabase-js@2\'\\n\\nconst corsHeaders = {\\n  \'Access-Control-Allow-Origin\': \'*\',\\n  \'Access-Control-Allow-Headers\': \'authorization, x-client-info, apikey, content-type\',\\n}\\n\\nserve(async (req) => {\\n  if (req.method === \'OPTIONS\') {\\n    return new Response(\'ok\', { headers: corsHeaders })\\n  }\\n\\n  try {\\n    const { to, subject, html } = await req.json()\\n    \\n    // 이메일 발송 로직\\n    const response = await fetch(\'https://api.resend.com/emails\', {\\n      method: \'POST\',\\n      headers: {\\n        \'Authorization\': `Bearer ${Deno.env.get(\'RESEND_API_KEY\')}`,\\n        \'Content-Type\': \'application/json\',\\n      },\\n      body: JSON.stringify({\\n        from: \'noreply@yourapp.com\',\\n        to,\\n        subject,\\n        html,\\n      }),\\n    })\\n\\n    const result = await response.json()\\n\\n    return new Response(\\n      JSON.stringify(result),\\n      { \\n        headers: { ...corsHeaders, \'Content-Type\': \'application/json\' },\\n        status: 200 \\n      }\\n    )\\n  } catch (error) {\\n    return new Response(\\n      JSON.stringify({ error: error.message }),\\n      { \\n        headers: { ...corsHeaders, \'Content-Type\': \'application/json\' },\\n        status: 400 \\n      }\\n    )\\n  }\\n})\\n```\\n\\n#### 클라이언트에서 Edge Function 호출\\n\\n```typescript title=\\"lib/functions.ts\\" showLineNumbers\\n// 클라이언트에서 Edge Function 호출\\nconst sendEmail = async (emailData: {\\n  to: string\\n  subject: string\\n  html: string\\n}) => {\\n  const { data, error } = await supabase.functions.invoke(\'send-email\', {\\n    body: emailData\\n  })\\n\\n  if (error) {\\n    console.error(\'Function error:\', error)\\n    return false\\n  }\\n\\n  return data\\n}\\n\\n// 사용 예시\\nconst handleSendWelcomeEmail = async (userEmail: string, userName: string) => {\\n  const result = await sendEmail({\\n    to: userEmail,\\n    subject: \'환영합니다!\',\\n    html: `\\n      <h1>안녕하세요, ${userName}님!</h1>\\n      <p>회원가입을 축하드립니다.</p>\\n    `\\n  })\\n\\n  if (result) {\\n    console.log(\'이메일이 성공적으로 발송되었습니다.\')\\n  }\\n}\\n```\\n\\n## 실제 프로젝트 구현 예시\\n\\n### 블로그 플랫폼 구축\\n\\n실제 프로젝트 예시로 Supabase를 활용한 블로그 플랫폼을 구축해보겠습니다.\\n\\n#### 데이터베이스 스키마 설계\\n\\n```sql title=\\"database/schema.sql\\" showLineNumbers\\n-- 사용자 프로필 테이블\\nCREATE TABLE profiles (\\n  id UUID REFERENCES auth.users(id) PRIMARY KEY,\\n  username TEXT UNIQUE NOT NULL,\\n  full_name TEXT,\\n  bio TEXT,\\n  avatar_url TEXT,\\n  website TEXT,\\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n);\\n\\n-- 블로그 포스트 테이블\\nCREATE TABLE posts (\\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n  title TEXT NOT NULL,\\n  slug TEXT UNIQUE NOT NULL,\\n  content TEXT NOT NULL,\\n  excerpt TEXT,\\n  featured_image TEXT,\\n  author_id UUID REFERENCES profiles(id) NOT NULL,\\n  published BOOLEAN DEFAULT FALSE,\\n  published_at TIMESTAMP WITH TIME ZONE,\\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n);\\n\\n-- 댓글 테이블\\nCREATE TABLE comments (\\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,\\n  author_id UUID REFERENCES profiles(id),\\n  content TEXT NOT NULL,\\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n);\\n\\n-- 좋아요 테이블\\nCREATE TABLE likes (\\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,\\n  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,\\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n  UNIQUE(post_id, user_id)\\n);\\n\\n-- RLS 정책 설정\\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\\nALTER TABLE posts ENABLE ROW LEVEL SECURITY;\\nALTER TABLE comments ENABLE ROW LEVEL SECURITY;\\nALTER TABLE likes ENABLE ROW LEVEL SECURITY;\\n\\n-- 프로필 정책\\nCREATE POLICY \\"Public profiles are viewable by everyone\\" ON profiles\\nFOR SELECT USING (true);\\n\\nCREATE POLICY \\"Users can update own profile\\" ON profiles\\nFOR UPDATE USING (auth.uid() = id);\\n\\n-- 포스트 정책\\nCREATE POLICY \\"Published posts are viewable by everyone\\" ON posts\\nFOR SELECT USING (published = true);\\n\\nCREATE POLICY \\"Authors can view own posts\\" ON posts\\nFOR SELECT USING (auth.uid() = author_id);\\n\\nCREATE POLICY \\"Authors can create posts\\" ON posts\\nFOR INSERT WITH CHECK (auth.uid() = author_id);\\n\\nCREATE POLICY \\"Authors can update own posts\\" ON posts\\nFOR UPDATE USING (auth.uid() = author_id);\\n```\\n\\n#### React 컴포넌트 구현\\n\\n```typescript title=\\"types/database.types.ts\\" showLineNumbers\\n// types/database.types.ts\\nexport interface Profile {\\n  id: string\\n  username: string\\n  full_name?: string\\n  bio?: string\\n  avatar_url?: string\\n  website?: string\\n}\\n\\nexport interface Post {\\n  id: string\\n  title: string\\n  slug: string\\n  content: string\\n  excerpt?: string\\n  featured_image?: string\\n  author_id: string\\n  published: boolean\\n  published_at?: string\\n  created_at: string\\n  updated_at: string\\n  profiles?: Profile\\n  likes_count?: number\\n  comments_count?: number\\n}\\n```\\n\\n```typescript title=\\"hooks/usePosts.ts\\" showLineNumbers\\n// hooks/usePosts.ts\\nimport { useState, useEffect } from \'react\'\\nimport { supabase } from \'../lib/supabase\'\\n\\nexport function usePosts() {\\n  const [posts, setPosts] = useState<Post[]>([])\\n  const [loading, setLoading] = useState(true)\\n\\n  useEffect(() => {\\n    const fetchPosts = async () => {\\n      const { data, error } = await supabase\\n        .from(\'posts\')\\n        .select(`\\n          *,\\n          profiles (username, full_name, avatar_url),\\n          likes (count),\\n          comments (count)\\n        `)\\n        .eq(\'published\', true)\\n        .order(\'published_at\', { ascending: false })\\n\\n      if (error) {\\n        console.error(\'Error fetching posts:\', error)\\n      } else {\\n        setPosts(data || [])\\n      }\\n      setLoading(false)\\n    }\\n\\n    fetchPosts()\\n\\n    // 실시간 구독\\n    const subscription = supabase\\n      .channel(\'public:posts\')\\n      .on(\'postgres_changes\', {\\n        event: \'*\',\\n        schema: \'public\',\\n        table: \'posts\',\\n        filter: \'published=eq.true\'\\n      }, () => {\\n        fetchPosts() // 변경사항 발생 시 다시 fetch\\n      })\\n      .subscribe()\\n\\n    return () => {\\n      subscription.unsubscribe()\\n    }\\n  }, [])\\n\\n  return { posts, loading }\\n}\\n```\\n\\n```typescript title=\\"components/PostCard.tsx\\" showLineNumbers\\n// components/PostCard.tsx\\ninterface PostCardProps {\\n  post: Post\\n}\\n\\nexport function PostCard({ post }: PostCardProps) {\\n  const [liked, setLiked] = useState(false)\\n  const [likesCount, setLikesCount] = useState(post.likes_count || 0)\\n\\n  const handleLike = async () => {\\n    const { data: { user } } = await supabase.auth.getUser()\\n    \\n    if (!user) return\\n\\n    if (liked) {\\n      // 좋아요 취소\\n      await supabase\\n        .from(\'likes\')\\n        .delete()\\n        .eq(\'post_id\', post.id)\\n        .eq(\'user_id\', user.id)\\n      \\n      setLiked(false)\\n      setLikesCount(prev => prev - 1)\\n    } else {\\n      // 좋아요 추가\\n      await supabase\\n        .from(\'likes\')\\n        .insert({ post_id: post.id, user_id: user.id })\\n      \\n      setLiked(true)\\n      setLikesCount(prev => prev + 1)\\n    }\\n  }\\n\\n  return (\\n    <article className=\\"bg-white rounded-lg shadow-md overflow-hidden\\">\\n      {post.featured_image && (\\n        <img \\n          src={post.featured_image} \\n          alt={post.title}\\n          className=\\"w-full h-48 object-cover\\"\\n        />\\n      )}\\n      \\n      <div className=\\"p-6\\">\\n        <h2 className=\\"text-xl font-bold mb-2\\">\\n          <Link href={`/posts/${post.slug}`}>\\n            {post.title}\\n          </Link>\\n        </h2>\\n        \\n        {post.excerpt && (\\n          <p className=\\"text-gray-600 mb-4\\">{post.excerpt}</p>\\n        )}\\n        \\n        <div className=\\"flex items-center justify-between\\">\\n          <div className=\\"flex items-center space-x-2\\">\\n            <img \\n              src={post.profiles?.avatar_url || \'/default-avatar.png\'}\\n              alt={post.profiles?.username}\\n              className=\\"w-8 h-8 rounded-full\\"\\n            />\\n            <span className=\\"text-sm text-gray-700\\">\\n              {post.profiles?.full_name || post.profiles?.username}\\n            </span>\\n          </div>\\n          \\n          <button \\n            onClick={handleLike}\\n            className={`flex items-center space-x-1 ${\\n              liked ? \'text-red-500\' : \'text-gray-500\'\\n            }`}\\n          >\\n            <HeartIcon className=\\"w-5 h-5\\" fill={liked ? \'currentColor\' : \'none\'} />\\n            <span>{likesCount}</span>\\n          </button>\\n        </div>\\n      </div>\\n    </article>\\n  )\\n}\\n```\\n\\n## 성능 최적화 전략\\n\\n### 데이터베이스 최적화\\n\\n```sql title=\\"database/indexes.sql\\" showLineNumbers\\n-- 성능 최적화를 위한 인덱스 생성\\nCREATE INDEX idx_posts_author_published ON posts(author_id, published);\\nCREATE INDEX idx_posts_published_at ON posts(published_at DESC) WHERE published = true;\\nCREATE INDEX idx_posts_slug ON posts(slug);\\nCREATE INDEX idx_comments_post_id ON comments(post_id);\\nCREATE INDEX idx_likes_post_user ON likes(post_id, user_id);\\n\\n-- 전문 검색을 위한 인덱스\\nCREATE INDEX idx_posts_search ON posts USING gin(to_tsvector(\'english\', title || \' \' || content));\\n```\\n\\n### 쿼리 최적화\\n\\n```typescript title=\\"lib/optimized-queries.ts\\" showLineNumbers\\n// 페이지네이션과 함께 최적화된 쿼리\\nconst getPostsWithPagination = async (page: number = 1, limit: number = 10) => {\\n  const offset = (page - 1) * limit\\n\\n  const { data, error, count } = await supabase\\n    .from(\'posts\')\\n    .select(`\\n      id, title, excerpt, published_at, slug,\\n      profiles!inner(username, avatar_url)\\n    `, { count: \'exact\' })\\n    .eq(\'published\', true)\\n    .order(\'published_at\', { ascending: false })\\n    .range(offset, offset + limit - 1)\\n\\n  return {\\n    posts: data || [],\\n    totalCount: count || 0,\\n    totalPages: Math.ceil((count || 0) / limit),\\n    currentPage: page\\n  }\\n}\\n\\n// 캐싱을 활용한 최적화\\nimport { unstable_cache } from \'next/cache\'\\n\\nconst getCachedPosts = unstable_cache(\\n  async () => {\\n    const { data } = await supabase\\n      .from(\'posts\')\\n      .select(\'*\')\\n      .eq(\'published\', true)\\n      .order(\'published_at\', { ascending: false })\\n      .limit(10)\\n    \\n    return data\\n  },\\n  [\'featured-posts\'],\\n  { \\n    revalidate: 300, // 5분 캐시\\n    tags: [\'posts\'] \\n  }\\n)\\n```\\n\\n## 장점과 한계\\n\\n### Supabase의 주요 장점\\n\\n#### 1. **개발 생산성**\\n- **즉시 사용 가능한 백엔드**: 복잡한 서버 설정 없이 바로 개발 시작\\n- **통합된 도구**: 데이터베이스, 인증, 스토리지, 함수를 한 곳에서 관리\\n- **직관적인 대시보드**: 비개발자도 쉽게 이해할 수 있는 관리 인터페이스\\n\\n#### 2. **기술적 우수성**\\n- **PostgreSQL의 강력함**: 복잡한 쿼리, 트랜잭션, ACID 보장\\n- **실시간 성능**: WebSocket 기반의 빠른 실시간 업데이트\\n- **확장성**: 수평적, 수직적 확장 모두 지원\\n\\n#### 3. **개발자 경험**\\n- **타입 안전성**: TypeScript 완벽 지원으로 컴파일 타임 에러 방지\\n- **자동 API 생성**: 데이터베이스 스키마 기반 REST API 자동 생성\\n- **풍부한 생태계**: React, Vue, Svelte, Flutter 등 다양한 프레임워크 지원\\n\\n### 현재의 한계점\\n\\n:::warning[고려해야 할 제한사항]\\nSupabase는 강력한 플랫폼이지만, 특정 상황에서는 제약이 있을 수 있습니다.\\n:::\\n\\n#### 1. **복잡한 비즈니스 로직**\\n- Edge Functions의 기능이 AWS Lambda나 Google Cloud Functions 대비 제한적\\n- 복잡한 백엔드 로직은 여전히 별도 서버가 필요할 수 있음\\n\\n#### 2. **대용량 데이터 처리**\\n- 매우 큰 규모의 데이터 분석이나 ETL 작업에는 전문 도구가 더 적합\\n- 복잡한 데이터 파이프라인 구축에는 추가 도구 필요\\n\\n#### 3. **특수한 요구사항**\\n- 특정 규정 준수나 보안 요구사항이 있는 엔터프라이즈 환경\\n- 기존 레거시 시스템과의 복잡한 통합\\n\\n## 가격 정책과 확장성\\n\\n### 요금 구조\\n\\nSupabase는 **사용량 기반 요금 정책**을 채택하여 스타트업부터 대기업까지 합리적인 비용으로 이용할 수 있습니다.\\n\\n| 플랜 | 월 요금 | 주요 특징 |\\n|------|---------|-----------|\\n| **Free** | $0 | • 2개 프로젝트<br />• 500MB 데이터베이스<br />• 1GB 스토리지<br />• 50MB Edge Functions |\\n| **Pro** | $25 | • 무제한 프로젝트<br />• 8GB 데이터베이스<br />• 100GB 스토리지<br />• 2GB Edge Functions |\\n| **Team** | $599 | • 팀 협업 기능<br />• 우선 지원<br />• 고급 보안 기능 |\\n| **Enterprise** | 별도 문의 | • 전용 지원<br />• SLA 보장<br />• 커스텀 보안 정책 |\\n\\n### 확장성 전략\\n\\n```typescript title=\\"lib/performance.ts\\" showLineNumbers\\n// 성능 최적화를 위한 실무 팁\\n\\n// 1. 연결 풀링 최적화\\nconst supabase = createClient(supabaseUrl, supabaseKey, {\\n  db: {\\n    schema: \'public\',\\n  },\\n  auth: {\\n    autoRefreshToken: true,\\n    persistSession: true,\\n    detectSessionInUrl: true\\n  },\\n  realtime: {\\n    params: {\\n      eventsPerSecond: 10\\n    }\\n  }\\n})\\n\\n// 2. 배치 처리 최적화\\nconst batchInsertPosts = async (posts: Post[]) => {\\n  const batchSize = 100\\n  const results = []\\n\\n  for (let i = 0; i < posts.length; i += batchSize) {\\n    const batch = posts.slice(i, i + batchSize)\\n    const { data, error } = await supabase\\n      .from(\'posts\')\\n      .insert(batch)\\n    \\n    if (error) {\\n      console.error(`Batch ${i / batchSize + 1} failed:`, error)\\n    } else {\\n      results.push(...(data || []))\\n    }\\n  }\\n\\n  return results\\n}\\n\\n// 3. 읽기 전용 복제본 활용\\nconst readOnlySupabase = createClient(\\n  process.env.SUPABASE_READ_REPLICA_URL!,\\n  process.env.SUPABASE_ANON_KEY!\\n)\\n\\nconst getAnalyticsData = async () => {\\n  // 읽기 전용 복제본에서 분석 쿼리 실행\\n  return await readOnlySupabase\\n    .from(\'posts\')\\n    .select(\'created_at, author_id\')\\n    .gte(\'created_at\', \'2024-01-01\')\\n}\\n```\\n\\n## 실무 도입 가이드\\n\\n### 프로젝트 시작하기\\n\\n#### 1. 프로젝트 초기 설정\\n\\n```bash title=\\"프로젝트 설정\\" showLineNumbers\\n# Next.js 프로젝트 생성\\nnpx create-next-app@latest my-supabase-app --typescript --tailwind --app\\n\\n# Supabase 클라이언트 설치\\nnpm install @supabase/supabase-js\\n\\n# 개발 도구 설치\\nnpm install -D @supabase/cli\\n\\n# 환경변수 설정 (.env.local)\\nNEXT_PUBLIC_SUPABASE_URL=your_supabase_url\\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key\\nSUPABASE_SERVICE_ROLE_KEY=your_service_role_key\\n```\\n\\n#### 2. Supabase 클라이언트 설정\\n\\n```typescript title=\\"lib/supabase.ts\\" showLineNumbers\\nimport { createClient } from \'@supabase/supabase-js\'\\n\\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\\n\\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey)\\n\\n// 서버사이드용 클라이언트 (관리자 권한)\\nexport const supabaseAdmin = createClient(\\n  supabaseUrl,\\n  process.env.SUPABASE_SERVICE_ROLE_KEY!,\\n  {\\n    auth: {\\n      autoRefreshToken: false,\\n      persistSession: false\\n    }\\n  }\\n)\\n```\\n\\n### 마이그레이션 전략\\n\\n기존 Firebase 프로젝트에서 Supabase로 마이그레이션하는 경우의 전략입니다.\\n\\n#### 1. 데이터 마이그레이션\\n\\n```typescript title=\\"scripts/migrate-firebase.ts\\" showLineNumbers\\n// Firebase에서 Supabase로 데이터 마이그레이션\\nimport { initializeApp } from \'firebase/app\'\\nimport { getFirestore, collection, getDocs } from \'firebase/firestore\'\\nimport { supabaseAdmin } from \'./lib/supabase\'\\n\\nconst migrateFirestoreToSupabase = async () => {\\n  // Firebase 초기화\\n  const firebaseApp = initializeApp(firebaseConfig)\\n  const db = getFirestore(firebaseApp)\\n\\n  // Firestore 데이터 가져오기\\n  const postsSnapshot = await getDocs(collection(db, \'posts\'))\\n  const posts = postsSnapshot.docs.map(doc => ({\\n    id: doc.id,\\n    ...doc.data()\\n  }))\\n\\n  // Supabase에 데이터 삽입\\n  for (const post of posts) {\\n    const { error } = await supabaseAdmin\\n      .from(\'posts\')\\n      .insert({\\n        title: post.title,\\n        content: post.content,\\n        author_id: post.authorId,\\n        created_at: post.createdAt.toDate().toISOString()\\n      })\\n\\n    if (error) {\\n      console.error(\'Migration error:\', error)\\n    }\\n  }\\n}\\n```\\n\\n#### 2. 점진적 마이그레이션\\n\\n```typescript title=\\"lib/hybrid-data.ts\\" showLineNumbers\\n// 하이브리드 접근: Firebase와 Supabase 동시 사용\\nconst useHybridData = () => {\\n  const [data, setData] = useState([])\\n\\n  useEffect(() => {\\n    const fetchData = async () => {\\n      // 우선 Supabase에서 시도\\n      let { data: supabaseData, error } = await supabase\\n        .from(\'posts\')\\n        .select(\'*\')\\n\\n      if (error || !supabaseData.length) {\\n        // Supabase에 데이터가 없으면 Firebase에서 가져오기\\n        const firebaseData = await getFirebaseData()\\n        setData(firebaseData)\\n      } else {\\n        setData(supabaseData)\\n      }\\n    }\\n\\n    fetchData()\\n  }, [])\\n\\n  return data\\n}\\n```\\n\\n## 결론\\n\\nSupabase는 **PostgreSQL의 강력함과 NoSQL의 편의성**을 결합한 혁신적인 백엔드 플랫폼으로, 현대 웹 애플리케이션 개발에 새로운 패러다임을 제시하고 있습니다. 특히 **오픈소스 철학**을 바탕으로 한 투명성과 **개발자 중심의 경험**은 Firebase의 훌륭한 대안이 되고 있습니다.\\n\\n### 주요 성과\\n\\n- **2백만 명 이상의 개발자** 커뮤니티 형성\\n- **Fortune 500 기업들의 도입** 증가\\n- **지속적인 기능 업데이트**와 성능 개선\\n- **강력한 생태계**와 써드파티 통합\\n\\n### Supabase를 선택해야 하는 경우\\n\\n- **관계형 데이터베이스의 강력함**이 필요한 프로젝트\\n- **빠른 프로토타이핑**과 MVP 개발\\n- **오픈소스 솔루션**을 선호하는 조직\\n- **벤더 락인을 피하고 싶은** 경우\\n- **SQL 숙련도가 있는** 개발팀\\n\\n### 미래 전망\\n\\nSupabase는 단순한 백엔드 서비스를 넘어서 **개발자 플랫폼**으로 진화하고 있습니다. AI 기능 통합, 더 강력한 Edge Computing, 그리고 기업용 기능 강화를 통해 앞으로도 지속적인 성장이 예상됩니다.\\n\\n모든 프로젝트에 완벽한 솔루션은 없지만, Supabase는 **현대적인 웹 애플리케이션 개발**에 있어서 가장 균형 잡힌 선택지 중 하나입니다. 특히 개발 속도와 확장성, 그리고 개발자 경험을 모두 고려했을 때 매우 경쟁력 있는 플랫폼입니다.\\n\\n---\\n\\n**참고 자료**\\n- [Supabase 공식 문서](https://supabase.com/docs)\\n- [PostgreSQL 공식 문서](https://www.postgresql.org/docs/)\\n- [Supabase GitHub Repository](https://github.com/supabase/supabase)\\n- [Supabase vs Firebase 비교 분석](https://supabase.com/alternatives/supabase-vs-firebase)"},{"id":"tailwind-css-v4-complete-guide","metadata":{"permalink":"/blog/tailwind-css-v4-complete-guide","source":"@site/blog/2025-05-30-post-2/index.md","title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","description":"Tailwind CSS v4.0의 Oxide 엔진과 CSS-first 접근법, v4.1의 텍스트 섀도우와 마스킹 유틸리티까지. 실무에서 바로 활용할 수 있는 핵심 변경사항을 정리했습니다.","date":"2025-05-30T00:00:00.000Z","tags":[{"inline":true,"label":"tailwindcss","permalink":"/blog/tags/tailwindcss"},{"inline":true,"label":"css","permalink":"/blog/tags/css"},{"inline":true,"label":"frontend","permalink":"/blog/tags/frontend"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"web-development","permalink":"/blog/tags/web-development"}],"readingTime":6.23,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","date":"2025-05-30","authors":["jypark"],"image":"/img/blog/tailwindcss.png","tags":["tailwindcss","css","frontend","performance","web-development"],"description":"Tailwind CSS v4.0의 Oxide 엔진과 CSS-first 접근법, v4.1의 텍스트 섀도우와 마스킹 유틸리티까지. 실무에서 바로 활용할 수 있는 핵심 변경사항을 정리했습니다.","slug":"tailwind-css-v4-complete-guide"},"unlisted":false,"prevItem":{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","permalink":"/blog/supabase-complete-guide-firebase-alternative"},"nextItem":{"title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","permalink":"/blog/microsoft-typescript-native-go-project-analysis"}},"content":"![tailwind css](/img/blog/tailwindcss.webp)\\n\\nTailwind CSS가 v4.0과 v4.1에서 프론트엔드 개발 패러다임을 바꾸는 혁신적인 변화를 가져왔습니다. 이 포스트에서는 실무에서 바로 활용할 수 있는 핵심 변경사항과 마이그레이션 가이드를 제공합니다.\\n\\n> **TL;DR**: Tailwind CSS v4.0은 Rust 기반 Oxide 엔진으로 빌드 속도를 100배 향상시키고 CSS-first 설정을 도입했습니다. v4.1은 텍스트 섀도우, 마스킹 유틸리티와 구형 브라우저 호환성을 대폭 개선했습니다.\\n\\n\\n\x3c!-- truncate --\x3e\\n\\n## v4.0: 성능과 현대 CSS의 혁신\\n\\n### 🚀 Oxide 엔진: 빌드 성능의 혁명\\n\\nTailwind CSS v4.0의 가장 큰 변화는 Rust로 작성된 **Oxide 엔진** 도입입니다.\\n\\n![Oxide 엔진](./oxide.webp)\\n\\n**성능 개선 수치:**\\n- 전체 빌드: 최대 **5배** 향상\\n- 증분 빌드: **100배 이상** 향상\\n- 대규모 프로젝트에서도 쾌적한 개발 경험\\n\\n```bash\\n# v3.x 빌드 시간 예시\\nnpm run build  # ~15초\\n\\n# v4.0 빌드 시간 예시  \\nnpm run build  # ~3초\\n```\\n\\n### 🎨 CSS-first 설정: JavaScript에서 CSS로\\n\\n기존의 복잡한 JavaScript 설정 파일을 CSS로 대체했습니다.\\n\\n```css title=\\"styles/tailwind.css\\"\\n@import \\"tailwindcss\\";\\n\\n/* 커스텀 유틸리티 정의 */\\n@layer utilities {\\n  .btn-primary {\\n    @apply bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors;\\n  }\\n  \\n  .card-shadow {\\n    @apply shadow-lg shadow-gray-200/50 dark:shadow-gray-800/50;\\n  }\\n}\\n\\n/* 커스텀 속성 정의 */\\n@property --brand-color {\\n  syntax: \\"<color>\\";\\n  initial-value: #3b82f6;\\n  inherits: false;\\n}\\n```\\n\\n**기존 방식과 비교:**\\n\\n```javascript title=\\"tailwind.config.js (v3.x)\\"\\nmodule.exports = {\\n  theme: {\\n    extend: {\\n      colors: {\\n        brand: \'#3b82f6\'\\n      },\\n      boxShadow: {\\n        \'card\': \'0 10px 15px -3px rgba(0, 0, 0, 0.1)\'\\n      }\\n    }\\n  },\\n  plugins: [\\n    function({ addUtilities }) {\\n      addUtilities({\\n        \'.btn-primary\': {\\n          backgroundColor: \'#3b82f6\',\\n          color: \'white\',\\n          // ...\\n        }\\n      })\\n    }\\n  ]\\n}\\n```\\n\\n### 🌈 최신 CSS 기능 완전 지원\\n\\nv4.0은 최신 CSS 기능을 적극적으로 활용합니다:\\n\\n**1. OKLCH 색상 시스템**\\n```css\\n/* 더 정확하고 일관된 색상 표현 */\\n.text-blue-500 {\\n  color: oklch(0.6 0.2 250);\\n}\\n```\\n\\n**2. 컨테이너 쿼리**\\n```html\\n<div class=\\"@container\\">\\n  <div class=\\"@sm:text-lg @md:text-xl @lg:text-2xl\\">\\n    반응형 텍스트\\n  </div>\\n</div>\\n```\\n\\n**3. Cascade Layers**\\n```css\\n@layer base, components, utilities;\\n\\n@layer base {\\n  /* 기본 스타일 */\\n}\\n\\n@layer components {\\n  /* 컴포넌트 스타일 */\\n}\\n```\\n\\n### 🛠️ 새로운 유틸리티 클래스\\n\\n**박스 섀도우 확장:**\\n```html\\n\x3c!-- 4단계 섀도우 지원 --\x3e\\n<div class=\\"shadow-xs shadow-sm shadow-md shadow-lg shadow-xl\\">\\n  다양한 섀도우 레벨\\n</div>\\n\\n\x3c!-- 인셋 섀도우 --\x3e\\n<div class=\\"inset-shadow-sm inset-shadow-md\\">\\n  내부 그림자 효과\\n</div>\\n```\\n\\n**새로운 variant:**\\n```html\\n\x3c!-- nth-* variant --\x3e\\n<div class=\\"nth-2:bg-gray-100 nth-odd:bg-blue-50\\">\\n  \x3c!-- 2번째, 홀수 번째 요소 스타일링 --\x3e\\n</div>\\n\\n\x3c!-- not-* variant --\x3e\\n<div class=\\"not-first:border-t not-last:border-b\\">\\n  \x3c!-- 첫 번째가 아닌, 마지막이 아닌 요소 --\x3e\\n</div>\\n```\\n\\n## v4.1: 실전 유틸리티와 호환성 강화\\n\\n### ✨ 텍스트 섀도우 공식 지원\\n\\n드디어 텍스트 섀도우가 공식 유틸리티로 추가되었습니다.\\n\\n```html title=\\"텍스트 섀도우 예시\\"\\n\x3c!-- 기본 텍스트 섀도우 --\x3e\\n<h1 class=\\"text-shadow-sm text-4xl font-bold\\">\\n  부드러운 텍스트 섀도우\\n</h1>\\n\\n<h2 class=\\"text-shadow-md text-3xl font-semibold text-blue-600\\">\\n  중간 강도 섀도우\\n</h2>\\n\\n<h3 class=\\"text-shadow-lg text-2xl font-bold text-white\\">\\n  강한 텍스트 섀도우\\n</h3>\\n\\n\x3c!-- 알파값 조절 --\x3e\\n<p class=\\"text-shadow-md/50 text-gray-800\\">\\n  50% 투명도 섀도우\\n</p>\\n```\\n\\n**CSS 출력 결과:**\\n```css\\n.text-shadow-sm {\\n  text-shadow: 0 1px 2px rgb(0 0 0 / 0.05);\\n}\\n\\n.text-shadow-md {\\n  text-shadow: 0 4px 6px rgb(0 0 0 / 0.1);\\n}\\n\\n.text-shadow-lg {\\n  text-shadow: 0 8px 16px rgb(0 0 0 / 0.15);\\n}\\n```\\n\\n### 🎭 마스킹 유틸리티\\n\\n복잡한 시각 효과를 간단하게 구현할 수 있는 마스킹 유틸리티가 추가되었습니다.\\n\\n```html title=\\"마스킹 효과 예시\\"\\n\x3c!-- 그라디언트 마스킹 --\x3e\\n<div class=\\"mask-gradient-to-r from-transparent to-black\\">\\n  <img src=\\"hero-image.webp\\" alt=\\"그라디언트 마스킹된 이미지\\" />\\n</div>\\n\\n\x3c!-- 원형 마스킹 --\x3e\\n<div class=\\"mask-circle\\">\\n  <img src=\\"profile.webp\\" alt=\\"원형 마스킹된 프로필\\" />\\n</div>\\n\\n\x3c!-- 커스텀 SVG 마스킹 --\x3e\\n<div class=\\"mask-[url(#custom-mask)]\\">\\n  <div class=\\"bg-gradient-to-r from-blue-500 to-purple-600 h-32\\">\\n    커스텀 마스킹 영역\\n  </div>\\n</div>\\n```\\n\\n### 🌐 구형 브라우저 호환성 대폭 개선\\n\\nv4.1의 가장 실용적인 개선사항은 구형 브라우저 지원입니다.\\n\\n**OKLCH 자동 fallback:**\\n```css\\n/* v4.1에서 자동 생성되는 CSS */\\n.bg-blue-500 {\\n  background-color: #3b82f6; /* fallback */\\n  background-color: oklch(0.6 0.2 250);\\n}\\n\\n.text-red-500/50 {\\n  color: rgba(239, 68, 68, 0.5); /* fallback */\\n  color: oklch(0.6 0.2 25 / 0.5);\\n}\\n```\\n\\n**@property 미지원 브라우저 처리:**\\n```css\\n/* 지원 브라우저 */\\n@property --tw-shadow-color {\\n  syntax: \\"<color>\\";\\n  initial-value: transparent;\\n  inherits: false;\\n}\\n\\n/* 미지원 브라우저에서는 자동으로 비활성화 */\\n```\\n\\n### 📝 세밀한 텍스트 제어\\n\\n**overflow-wrap 유틸리티:**\\n```html\\n\x3c!-- 긴 URL이나 단어 처리 --\x3e\\n<div class=\\"overflow-wrap-break-word max-w-xs\\">\\n  https://very-long-domain-name-that-might-break-layout.com/path\\n</div>\\n\\n<div class=\\"overflow-wrap-anywhere\\">\\n  supercalifragilisticexpialidocious\\n</div>\\n```\\n\\n**baseline 정렬 확장:**\\n```html\\n<div class=\\"flex items-baseline-last gap-4\\">\\n  <div class=\\"text-sm leading-relaxed\\">\\n    여러 줄의<br>\\n    텍스트 내용\\n  </div>\\n  <div class=\\"text-lg\\">\\n    마지막 줄 기준으로<br>\\n    정렬됩니다\\n  </div>\\n</div>\\n```\\n\\n### 🎯 새로운 상태 variant\\n\\n**입력 장치별 스타일링:**\\n```html\\n\x3c!-- 터치 디바이스 감지 --\x3e\\n<button class=\\"pointer-coarse:p-4 pointer-fine:p-2\\">\\n  디바이스별 패딩\\n</button>\\n\\n\x3c!-- 호버 가능 여부 감지 --\x3e\\n<div class=\\"any-hover:hover:bg-blue-100\\">\\n  호버 지원 시에만 호버 효과\\n</div>\\n```\\n\\n**접근성 및 환경 variant:**\\n```html\\n\x3c!-- JavaScript 비활성화 상태 --\x3e\\n<div class=\\"noscript:block hidden\\">\\n  JavaScript가 비활성화되었습니다.\\n</div>\\n\\n\x3c!-- 색상 반전 모드 --\x3e\\n<div class=\\"inverted-colors:bg-white inverted-colors:text-black\\">\\n  고대비 모드 대응\\n</div>\\n```\\n\\n## 마이그레이션 가이드\\n\\n### v3.x에서 v4.x로 업그레이드\\n\\n**1. 설치 및 설정 변경:**\\n```bash\\n# 기존 패키지 제거\\nnpm uninstall tailwindcss autoprefixer postcss\\n\\n# v4 설치\\nnpm install tailwindcss@next\\n```\\n\\n**2. 설정 파일 변경:**\\n```css title=\\"src/styles/tailwind.css\\"\\n/* 기존 */\\n@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n/* v4.x */\\n@import \\"tailwindcss\\";\\n```\\n\\n**3. 커스텀 설정 마이그레이션:**\\n```css title=\\"src/styles/tailwind.css\\"\\n@import \\"tailwindcss\\";\\n\\n/* JavaScript 설정을 CSS로 이전 */\\n@layer utilities {\\n  .btn-custom {\\n    @apply bg-brand-500 text-white px-4 py-2 rounded;\\n  }\\n}\\n\\n/* 커스텀 속성 정의 */\\n@property --brand-500 {\\n  syntax: \\"<color>\\";\\n  initial-value: #3b82f6;\\n  inherits: false;\\n}\\n```\\n\\n### 주의사항 및 호환성\\n\\n**Breaking Changes:**\\n- Node.js 18+ 필수\\n- 일부 플러그인 API 변경\\n- PostCSS 설정 방식 변경\\n\\n**점진적 마이그레이션 전략:**\\n1. 새 프로젝트에서 v4 테스트\\n2. 기존 프로젝트는 v3.x 유지하며 점진적 업그레이드\\n3. 커스텀 플러그인 호환성 확인\\n\\n## 성능 벤치마크\\n\\n실제 프로젝트에서 측정한 성능 개선 결과입니다:\\n\\n| 프로젝트 규모 | v3.x 빌드 시간 | v4.x 빌드 시간 | 개선율 |\\n|---------------|----------------|----------------|--------|\\n| 소규모 (< 100 컴포넌트) | 2.3초 | 0.8초 | 65% ↓ |\\n| 중규모 (100-500 컴포넌트) | 8.7초 | 2.1초 | 76% ↓ |\\n| 대규모 (500+ 컴포넌트) | 23.4초 | 4.6초 | 80% ↓ |\\n\\n## 실무 활용 팁\\n\\n### 1. 텍스트 섀도우 활용법\\n\\n```html\\n\x3c!-- 헤더 텍스트에 깊이감 추가 --\x3e\\n<h1 class=\\"text-4xl font-bold text-white text-shadow-lg\\">\\n  임팩트 있는 제목\\n</h1>\\n\\n\x3c!-- 버튼 텍스트 가독성 향상 --\x3e\\n<button class=\\"bg-gradient-to-r from-blue-500 to-purple-600 text-white text-shadow-sm px-6 py-3 rounded-lg\\">\\n  그라디언트 버튼\\n</button>\\n```\\n\\n### 2. 마스킹으로 고급 효과\\n\\n```html\\n\x3c!-- 이미지 페이드 아웃 효과 --\x3e\\n<div class=\\"relative\\">\\n  <img src=\\"hero.webp\\" alt=\\"히어로 이미지\\" class=\\"w-full h-64 object-cover\\" />\\n  <div class=\\"absolute inset-0 mask-gradient-to-t from-black/80 to-transparent\\">\\n    <div class=\\"absolute bottom-4 left-4 text-white\\">\\n      <h2 class=\\"text-2xl font-bold\\">오버레이 텍스트</h2>\\n    </div>\\n  </div>\\n</div>\\n```\\n\\n### 3. 반응형 컨테이너 쿼리\\n\\n```html\\n<div class=\\"@container bg-white rounded-lg shadow-lg p-4\\">\\n  <h3 class=\\"@xs:text-lg @sm:text-xl @md:text-2xl font-semibold\\">\\n    컨테이너 크기에 따른 반응형 제목\\n  </h3>\\n  <p class=\\"@sm:block hidden text-gray-600 mt-2\\">\\n    컨테이너가 충분히 클 때만 표시되는 설명\\n  </p>\\n</div>\\n```\\n\\n## 결론\\n\\nTailwind CSS v4.0과 v4.1은 단순한 버전 업그레이드를 넘어 프론트엔드 개발 방식의 패러다임 전환을 제시합니다.\\n\\n**v4.0의 핵심 가치:**\\n- **성능**: Oxide 엔진으로 개발 생산성 극대화\\n- **현대성**: 최신 CSS 기능 완전 활용\\n- **단순성**: CSS-first 접근법으로 설정 복잡도 감소\\n\\n**v4.1의 실용적 개선:**\\n- **시각적 완성도**: 텍스트 섀도우, 마스킹 등 디자인 유틸리티\\n- **호환성**: 구형 브라우저 graceful degradation\\n- **세밀함**: 텍스트 제어, 상태 관리 등 디테일 향상\\n\\n특히 구형 브라우저 지원과 텍스트 섀도우, 마스킹 유틸리티는 v4.1에서만 제공되므로, 실무 프로젝트에서는 최신 버전 사용을 강력히 권장합니다.\\n\\n앞으로 Tailwind CSS는 성능과 개발자 경험, 그리고 실용성 모든 면에서 프론트엔드 개발의 새로운 표준을 제시할 것으로 기대됩니다."},{"id":"microsoft-typescript-native-go-project-analysis","metadata":{"permalink":"/blog/microsoft-typescript-native-go-project-analysis","source":"@site/blog/2025-05-28-post/index.md","title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","description":"마이크로소프트가 TypeScript Native 프로젝트를 통해 TypeScript 컴파일러를 Go로 재구현하는 혁신적인 시도를 분석합니다. 빌드 시간 10배 단축과 메모리 사용량 대폭 감소를 목표로 하는 성능 혁신입니다.","date":"2025-05-28T00:00:00.000Z","tags":[{"inline":true,"label":"typescript","permalink":"/blog/tags/typescript"},{"inline":true,"label":"golang","permalink":"/blog/tags/golang"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"microsoft","permalink":"/blog/tags/microsoft"},{"inline":true,"label":"compiler","permalink":"/blog/tags/compiler"},{"inline":true,"label":"native","permalink":"/blog/tags/native"}],"readingTime":7.73,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","date":"2025-05-28","authors":["jypark"],"tags":["typescript","golang","performance","microsoft","compiler","native"],"description":"마이크로소프트가 TypeScript Native 프로젝트를 통해 TypeScript 컴파일러를 Go로 재구현하는 혁신적인 시도를 분석합니다. 빌드 시간 10배 단축과 메모리 사용량 대폭 감소를 목표로 하는 성능 혁신입니다.","slug":"microsoft-typescript-native-go-project-analysis","hide_table_of_contents":false,"hide_reading_time":false},"unlisted":false,"prevItem":{"title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","permalink":"/blog/tailwind-css-v4-complete-guide"},"nextItem":{"title":"PostgreSQL 18에 UUIDv7이 도입됩니다","permalink":"/blog/uuidv7-postgresql-18"}},"content":"> **TL;DR**: 마이크로소프트가 **TypeScript Native** 프로젝트를 통해 TypeScript 컴파일러를 Go로 재구현하여 **빌드 시간 10배 단축**, **메모리 사용량 대폭 감소**, **에디터 응답 시간 8배 향상**을 목표로 하는 혁신적인 프로젝트입니다. 2025년 중반 미리보기 버전, 후반 완전 기능 버전 출시 예정입니다.\\n\\n마이크로소프트가 추진하고 있는 **TypeScript Native 프로젝트**는 TypeScript의 성능과 확장성을 혁신적으로 개선하기 위한 야심찬 시도입니다. JavaScript 기반의 기존 타입 검사 엔진을 **Go 언어로 전면 재구축**하는 이 프로젝트는 대규모 엔터프라이즈 애플리케이션 개발에서 발생하는 성능 병목 현상을 해결하고, 개발자 생산성을 극대화하는 것을 목표로 하고 있습니다.\\n\\n마이크로소프트는 2024년 11월 공식 블로그를 통해 이 프로젝트를 발표했으며, 현재 [GitHub 레포지토리](https://github.com/microsoft/typescript-go)에서 활발한 개발과 CI/CD 파이프라인 구축이 이루어지고 있습니다. **2025년 중반 미리보기 버전**, **후반 완전 기능 버전** 출시가 예정되어 있습니다.\\n![typescript-go-hero](./typescript-go-hero.webp)\\n\x3c!-- truncate --\x3e\\n\\n## 프로젝트 배경 및 필요성\\n\\n### 기존 TypeScript의 성능 한계\\n\\nTypeScript는 JavaScript 생태계에서 정적 타입 검사와 구조화된 개발 경험을 제공하는 핵심 도구로 자리잡았습니다. 하지만 코드베이스가 대규모로 확장됨에 따라 심각한 성능 문제가 드러나기 시작했습니다.\\n\\n마이크로소프트의 공식 발표에 따르면, 현재 TypeScript 컴파일러가 직면한 주요 성능 문제는 다음과 같습니다:\\n\\n#### 주요 성능 문제점\\n\\n- **느린 로딩 시간**: 고성능 머신에서도 Visual Studio Code를 통해 전체 프로젝트를 로드하는 데 **약 9.6초** 소요\\n- **긴 타입 검사 프로세스**: 대규모 프로젝트에서 개발자의 작업 흐름을 크게 방해\\n- **과도한 메모리 사용**: 시스템 리소스를 비효율적으로 사용하는 문제점\\n- **확장성 한계**: 엔터프라이즈급 대규모 코드베이스에서의 성능 저하\\n\\n개발자들은 포괄적인 타입 분석과 반응성이 뛰어난 코딩 환경 사이에서 지속적으로 절충안을 찾아야 했습니다. 이는 TypeScript의 핵심 가치 제안을 훼손하는 결과를 초래했으며, 마이크로소프트로 하여금 근본적인 해결책을 모색하게 만든 주요 동인이 되었습니다.\\n\\n### Go 언어 선택의 전략적 근거\\n\\n마이크로소프트가 TypeScript 재구현을 위해 **Go 언어**를 선택한 것은 단순한 성능 향상을 넘어선 전략적 결정이었습니다. 마이크로소프트 TypeScript 팀의 **Ryan Cavanaugh**는 공식 블로그에서 이러한 선택의 근거를 상세히 설명했습니다.\\n\\n#### Go 선택의 핵심 이유\\n\\n1. **구조적 타입 호환성**: JavaScript의 동적 특성과 매우 유사한 타입 시스템\\n2. **기존 코드베이스 호환성**: TypeScript 코드와의 호환성 유지 가능\\n3. **자동 가비지 수집**: TypeScript의 기존 메모리 모델과 자연스럽게 어우러짐\\n4. **교차 플랫폼 지원**: 다양한 개발 환경에서 원활한 배포 가능\\n5. **컴파일 속도**: Go의 빠른 컴파일 시간이 개발 생산성에 기여\\n\\n**Ryan Cavanaugh**를 비롯한 마이크로소프트의 엔지니어링 리드들은 다른 대안들과 비교 분석한 결과 Go가 가장 실용적인 선택이라고 판단했습니다:\\n\\n- **Rust**: 뛰어난 성능을 제공하지만 소유권 모델과 엄격한 메모리 관리로 인해 TypeScript의 직접적인 번역에 부적합\\n- **C#**: 객체 지향 패러다임 의존성으로 인해 TypeScript 아키텍처의 근본적 변경 필요\\n- **C++**: 메모리 관리의 복잡성과 개발 생산성 저하 우려\\n\\n## 기술적 구현 및 아키텍처\\n\\n### 성능 최적화 목표\\n\\n마이크로소프트는 Go 기반 TypeScript Native 컴파일러를 통해 달성하고자 하는 **구체적인 성능 목표**를 공식 발표에서 제시했습니다:\\n\\n#### 핵심 성능 개선 목표\\n\\n| 항목 | 기존 성능 | 목표 성능 | 개선 배율 |\\n|------|-----------|-----------|-----------|\\n| 빌드 시간 | 기준값 | 기준값의 1/10 | **10배 단축** |\\n| 에디터 응답 시간 | 9.6초 | 1.2초 | **8배 향상** |\\n| 메모리 사용량 | 기준값 | 기준값의 50% 이하 | **대폭 감소** |\\n| 타입 검사 속도 | 기준값 | 기준값의 1/5 | **5배 향상** |\\n\\nVisual Studio Code에서의 내부 벤치마크 결과에 따르면, 기존에 **9.6초**가 걸리던 전체 프로젝트 로딩 시간이 Go 기반 구현에서는 **1.2초**로 단축되어 약 8배의 성능 향상을 보여주고 있습니다.\\n\\n이러한 성능 개선은 단순히 숫자상의 향상을 넘어서 개발자의 작업 흐름을 더욱 자연스럽고 끊김없게 만들어 줄 것으로 기대됩니다.\\n\\n### TypeScript Native의 핵심 기술\\n\\n마이크로소프트는 TypeScript Native 프로젝트에서 다음과 같은 핵심 기술들을 적용하고 있습니다:\\n\\n#### 아키텍처 혁신\\n\\n- **병렬 처리 최적화**: Go의 고루틴을 활용한 동시성 처리\\n- **메모리 풀링**: 효율적인 메모리 관리를 통한 가비지 수집 최적화\\n- **증분 컴파일**: 변경된 부분만 재컴파일하는 스마트 빌드 시스템\\n- **캐싱 전략**: 타입 정보와 컴파일 결과의 지능적 캐싱\\n\\n### 개발 진행 상황 및 CI/CD\\n\\nGitHub 레포지토리에서 확인할 수 있는 개발 진행 상황을 보면, 마이크로소프트 팀은 체계적인 개발 프로세스를 통해 프로젝트를 추진하고 있습니다.\\n\\n#### 최근 개발 활동\\n\\n- **2025년 4월 12일**: \\"Fix some bugs in tsc -w\\" 관련 Pull Request 제출\\n- **CI/CD 파이프라인**: 포괄적인 검증 과정 구축\\n- **호환성 테스트**: 기존 TypeScript 코드베이스와의 100% 호환성 검증\\n\\n#### CI/CD 테스트 매트릭스\\n\\nCI/CD 파이프라인은 다음과 같은 포괄적인 검증 과정을 거치고 있습니다:\\n\\n- `lint` - 코드 품질 검사\\n- `test` - 단위 테스트 및 통합 테스트\\n- `build` - 빌드 검증\\n- `format` - 코드 포맷팅\\n- `generate` - 코드 생성\\n- `tidy` - 정리 작업\\n- `smoke` - 스모크 테스트\\n- `extension` - VS Code 확장 기능 테스트\\n- `misc` - 기타 테스트\\n- `baselines` - 기준선 테스트 (3분 30초, 가장 긴 실행 시간)\\n\\n총 실행 시간 **10분 31초**로 기록된 CI 워크플로우는 프로젝트의 안정성과 품질을 보장하기 위한 엄격한 검증 체계가 구축되어 있음을 보여줍니다.\\n\\n## 출시 계획 및 호환성 전략\\n\\n### 단계적 출시 로드맵\\n\\n마이크로소프트는 TypeScript Native의 안정적인 도입을 위해 신중하게 설계된 **단계적 출시 계획**을 수립했습니다.\\n\\n#### 2025년 출시 일정\\n\\n**🚀 2025년 중반 - TypeScript Native 미리보기 버전**\\n- 명령줄 타입 검사 지원\\n- 새로운 성능 개선사항 체험 기회\\n- 개발자 피드백 수집\\n- 기존 워크플로우에 최소한의 변화\\n- 선택적 도입 가능\\n\\n**🎯 2025년 후반 - TypeScript Native 완전 기능 버전**\\n- 프로젝트 빌드 및 언어 서비스 통합\\n- Visual Studio Code 완전 통합\\n- 실시간 타입 검사\\n- 자동 완성 기능 개선\\n- 디버깅 도구 통합\\n\\n이러한 단계적 접근 방식은 대규모 엔터프라이즈 환경에서 새로운 도구를 안전하게 도입할 수 있도록 하는 실용적인 전략입니다.\\n\\n### 이중 유지 관리 전략\\n\\n마이크로소프트는 Go 기반 구현으로의 전환이 기존 JavaScript 기반 구현의 즉각적인 폐기를 의미하지 않는다는 점을 명확히 했습니다.\\n\\n#### 버전 관리 전략\\n\\n| 버전 | 구현 언어 | 상태 | 대상 | 지원 기간 |\\n|------|-----------|------|------|-----------|\\n| **TypeScript 6.x** | JavaScript | 지속 유지 | 기존 사용자 | 최소 3년 |\\n| **TypeScript Native 7.x** | Go | 신규 출시 | 새로운 \\"네이티브\\" 버전 | 장기 지원 |\\n\\n이러한 **이중 유지 관리 전략**은 다음과 같은 장점을 제공합니다:\\n\\n- TypeScript의 안정성에 크게 의존하는 기업들에게 충분한 전환 시간 제공\\n- 프로젝트 요구사항과 일정에 맞춘 유연한 마이그레이션 가능\\n- 운영상의 위험 최소화\\n- 점진적 기능 검증 및 피드백 수집\\n\\n## 생태계 영향 및 경쟁 환경\\n\\n### TypeScript 생태계에 미치는 파급효과\\n\\nTypeScript Native의 도입은 단순한 성능 개선을 넘어서 전체 TypeScript 생태계에 광범위한 파급효과를 미칠 것으로 예상됩니다.\\n\\n#### 예상되는 긍정적 효과\\n\\n**📈 개발 생산성 향상**\\n- 대규모 프로젝트에서의 개발 경험 근본적 개선\\n- TypeScript 채택률 증가 (특히 엔터프라이즈 환경)\\n- JavaScript 생태계 전반의 개발 품질 향상\\n- 개발자 만족도 증가\\n\\n**⚡ CI/CD 효율성 개선**\\n- 빌드 시간의 획기적인 단축으로 배포 주기 단축\\n- DevOps 문화에 긍정적 영향\\n- 클라우드 컴퓨팅 비용 절감 효과\\n\\n**🌐 접근성 확대**\\n- 리소스가 제한된 환경에서도 TypeScript 효과적 활용 가능\\n- 스타트업이나 중소 규모 개발팀의 엔터프라이즈급 도구 접근성 향상\\n- TypeScript 도입 장벽 감소\\n- 교육 환경에서의 활용도 증가\\n\\n### 다른 도구들과의 관계\\n\\n현재 JavaScript/TypeScript 생태계에는 성능 개선을 목표로 하는 다양한 도구들이 존재하며, Microsoft의 TypeScript Native는 이러한 경쟁 환경에서 독특한 위치를 차지하게 될 것입니다.\\n\\n#### 기존 성능 도구들과의 차별점\\n\\n**🦀 Rust 기반 도구들**\\n- **SWC, Biome, Turbopack**: 주로 번들링이나 특정 기능에 초점\\n- **TypeScript Native**: TypeScript 언어 자체의 핵심 기능 개선에 집중\\n\\n**🔧 상호 운용성 도구들**\\n- **bel, tygo**: Go 구조체에서 TypeScript 인터페이스 생성에 초점\\n- **TypeScript Native**: TypeScript 자체의 성능과 확장성 근본적 개선\\n\\n**🚀 기타 컴파일러 도구들**\\n- **esbuild, Vite**: 빠른 번들링과 개발 서버에 특화\\n- **TypeScript Native**: 타입 검사와 언어 서비스의 전면적 개선\\n\\n이러한 차별화된 접근 방식은 다른 도구들과 경쟁하기보다는 **상호 보완적인 관계**를 형성할 가능성이 높으며, 전체 생태계의 성능 향상에 기여할 것으로 예상됩니다.\\n\\n## 기술적 도전과 해결 방안\\n\\n### 호환성 보장\\n\\nTypeScript Native 프로젝트의 가장 큰 도전 중 하나는 기존 TypeScript 코드베이스와의 **100% 호환성**을 보장하는 것입니다.\\n\\n#### 호환성 전략\\n\\n- **AST(Abstract Syntax Tree) 호환성**: 기존 TypeScript AST와 동일한 구조 유지\\n- **API 호환성**: TypeScript Compiler API의 완전한 호환성 보장\\n- **설정 파일 호환성**: tsconfig.json 등 기존 설정 파일 완전 지원\\n- **플러그인 생태계**: 기존 TypeScript 플러그인들과의 호환성 유지\\n\\n### 성능 최적화 기법\\n\\n마이크로소프트는 Go의 특성을 최대한 활용하여 다음과 같은 최적화 기법들을 적용하고 있습니다:\\n\\n- **메모리 풀링**: 빈번한 할당/해제를 피하는 메모리 관리\\n- **병렬 타입 검사**: 독립적인 모듈들의 동시 처리\\n- **지능적 캐싱**: 타입 정보의 효율적 캐싱 전략\\n- **증분 빌드**: 변경된 부분만 재처리하는 스마트 빌드\\n\\n## 결론\\n\\nMicrosoft의 TypeScript Native 프로젝트는 현대 소프트웨어 개발에서 TypeScript가 차지하는 중요성을 인정하고, 그 한계를 극복하기 위한 **혁신적인 시도**로 평가됩니다.\\n\\n### 핵심 성과 목표\\n\\nJavaScript에서 Go로의 핵심 엔진 전환은 단순한 기술적 개선을 넘어서 **개발자 경험의 근본적인 변화**를 가져올 것으로 기대됩니다:\\n\\n- ⚡ **빌드 시간 10배 단축**으로 개발 생산성 극대화\\n- 💾 **메모리 사용량 대폭 감소**로 시스템 효율성 향상\\n- 🚀 **에디터 응답 시간 8배 향상**으로 개발 경험 개선\\n- 🔧 **타입 검사 속도 5배 향상**으로 실시간 피드백 강화\\n\\n### 전략적 의미\\n\\n**신중한 접근 방식**\\n- 2025년 중반 미리보기 버전과 후반 완전 기능 버전의 단계적 출시 계획\\n- 기존 JavaScript 기반 구현과의 이중 유지 관리 전략\\n- 안정성과 혁신 사이의 균형\\n- 엔터프라이즈 환경을 고려한 점진적 전환 지원\\n\\n**기술적 타당성**\\n- Go 언어 선택의 전략적 근거와 기술적 적합성\\n- 구조적 타입 호환성과 가비지 수집 최적화\\n- TypeScript의 특성과 잘 어울리는 기술적 결정\\n- 기존 생태계와의 완벽한 호환성 보장\\n\\n이 프로젝트가 성공적으로 완성된다면 TypeScript 생태계 전반에 긍정적인 파급효과를 미치며, **현대 웹 개발의 생산성과 품질을 한 단계 끌어올리는 중요한 이정표**가 될 것으로 전망됩니다. 특히 대규모 엔터프라이즈 환경에서 TypeScript의 활용도가 크게 증가할 것으로 예상되며, 이는 전체 JavaScript 생태계의 성숙도 향상에도 기여할 것입니다.\\n\\n## 참고 자료\\n\\n### 공식 문서 및 발표\\n- [Microsoft TypeScript Native 공식 블로그](https://devblogs.microsoft.com/typescript/typescript-native-port/)\\n- [TypeScript Native 미리보기 발표](https://devblogs.microsoft.com/typescript/announcing-typescript-native-previews/)\\n- [Microsoft TypeScript-Go GitHub 레포지토리](https://github.com/microsoft/typescript-go)\\n\\n### 기술 분석 및 리뷰\\n- [CTOL-KR: Microsoft TypeScript Go 성능 및 확장성 분석](https://www.ctol-kr.com/news/microsoft-typescript-moves-to-go-for-performance-and-scalability/)\\n- [FastCampus: Microsoft TypeScript Go 프로젝트 인사이트](https://media.fastcampus.co.kr/insight/microsoft-typescript-go/)\\n- [Hacker News: TypeScript Native 논의](https://news.hada.io/topic?id=19695)\\n\\n### 관련 도구 및 프로젝트\\n- [bel: Go 구조체에서 TypeScript 인터페이스 생성](https://github.com/csweichel/bel)\\n- [tygo: Go에서 TypeScript 정의 생성](https://github.com/gzuidhof/tygo)\\n- [ts-readme: TypeScript 문서화 도구](https://www.npmjs.com/package/ts-readme)\\n\\n### 커뮤니티 반응\\n- [Reddit: TypeScript Go 재작성 논의](https://www.reddit.com/r/golang/comments/1j8shzb/microsoft_rewriting_typescript_in_go/)\\n- [Twitter: TypeScript 공식 계정 발표](https://x.com/typescript/status/1925569825306464534)\\n- [디지털 부르주아: TypeScript Native 분석](https://digitalbourgeois.tistory.com/882)"},{"id":"uuidv7-postgresql-18","metadata":{"permalink":"/blog/uuidv7-postgresql-18","source":"@site/blog/2025-05-26-post/index.md","title":"PostgreSQL 18에 UUIDv7이 도입됩니다","description":"PostgreSQL 18에서 새롭게 도입되는 UUIDv7의 특징과 장점, 그리고 데이터베이스 기본 키로서의 활용 방법을 상세히 알아봅니다.","date":"2025-05-26T00:00:00.000Z","tags":[{"inline":true,"label":"uuid","permalink":"/blog/tags/uuid"},{"inline":true,"label":"uuidv7","permalink":"/blog/tags/uuidv-7"},{"inline":true,"label":"postgresql","permalink":"/blog/tags/postgresql"},{"inline":true,"label":"database","permalink":"/blog/tags/database"},{"inline":true,"label":"timestamp","permalink":"/blog/tags/timestamp"}],"readingTime":8.8,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"slug":"uuidv7-postgresql-18","title":"PostgreSQL 18에 UUIDv7이 도입됩니다","authors":["jypark"],"tags":["uuid","uuidv7","postgresql","database","timestamp"],"description":"PostgreSQL 18에서 새롭게 도입되는 UUIDv7의 특징과 장점, 그리고 데이터베이스 기본 키로서의 활용 방법을 상세히 알아봅니다."},"unlisted":false,"prevItem":{"title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","permalink":"/blog/microsoft-typescript-native-go-project-analysis"},"nextItem":{"title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","permalink":"/blog/next-yak-nextjs-css-in-js"}},"content":"PostgreSQL 18이 곧 출시될 예정이며, 현재 베타 테스트가 진행 중입니다. 이번 릴리스의 많은 개선사항 중에서도 UUIDv7 지원이 포함되었습니다. UUIDv7은 타임스탬프 기반의 UUID 변형으로 B-tree 인덱스와 잘 호환됩니다. 이 글에서는 UUID 전반에 대해 논의하고, UUIDv7이 왜 유용한지, 그리고 PostgreSQL에서 어떻게 사용할 수 있는지 알아보겠습니다.\\n\\n> **TL;DR**: PostgreSQL 18에서 도입되는 UUIDv7은 타임스탬프 기반으로 정렬 가능하고 B-tree 인덱스 성능이 우수한 UUID입니다. `uuidv7()` 함수로 생성하며, 기존 UUID의 단점을 해결합니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n## PostgreSQL 18\\n\\nPostgreSQL 18 베타 1이 며칠 전에 출시되었습니다. 이번 릴리스는 새로운 기능, 개선사항, 버그 수정으로 가득 차 있습니다. 평소와 같이 커뮤니티는 이를 시도해보고 문제를 보고하도록 권장하고 있으며, 9월에 고품질 릴리스를 출시하는 것이 목표입니다.\\n\\n이번 릴리스의 주요 특징은 다음과 같습니다:\\n\\n* **비동기 I/O** (io_uring 사용) — 순차 스캔, 배큠에서 2-3배 속도 향상\\n* **다중 컬럼 B-tree 인덱스의 Skip scan** + 더 스마트한 OR/IN 최적화\\n* **메이저 업그레이드 중 플래너 통계 유지**\\n* **UUIDv7 함수**\\n* **가상 생성 컬럼**\\n* **OAuth 로그인** + md5 사용 중단 경고\\n* **EXPLAIN ANALYZE에서 I/O, CPU, WAL 표시**\\n* **시간적 제약조건, 비결정적 콜레이션의 LIKE, 케이스 폴딩**\\n* **새로운 와이어 프로토콜 버전: 3.2** (2003년 이후 첫 번째!)\\n\\n`uuidv7()`이 가장 흥미로운 기능은 아니지만(그것은 비동기 I/O일 것입니다), 아마도 가장 기다려진 기능일 것입니다. PostgreSQL 17에 추가될 뻔했지만 포함되지 않아서 많은 사용자들이 실망했습니다. 저는 이 기능에 대해 너무 흥미로워서 베타 버전을 사용해보고 이에 대한 블로그 글을 쓰기로 결정했습니다.\\n\\n## UUID란 무엇이며 왜 유용한가요?\\n\\nUUID는 트랜잭션부터 회사까지 다양한 항목의 식별자로 사용되는 128비트 값입니다. 공간과 시간에 걸쳐 고유하도록 설계되었으며, 중앙화된 서비스에 의존하지 않고도 높은 속도로 효율적으로 생성할 수 있습니다.\\n\\n전통적으로 관계형 데이터베이스는 고유 식별자를 생성하기 위해 자동 증가 타입(`SERIAL` 또는 `identity`와 같은)을 사용했습니다. 이는 단일 머신에서 효율적으로 수행할 수 있지만(이 경우에도 단점이 있습니다), 확장이 필요한 경우 모든 노드에서 고유한 식별자를 생성하는 방법이 필요합니다. Instagram 팀은 PostgreSQL 데이터베이스를 샤딩하면서 UUID로 마이그레이션한 과정에 대한 짧은 블로그를 작성했습니다.\\n\\nUUID는 다음과 같은 일반적인 시나리오에서 데이터베이스의 기본 키로 유용합니다:\\n\\n* **분산 데이터베이스에서 고유 ID 생성**:  \\n많은 분산 데이터베이스가 자동 증가(identity) 컬럼을 지원할 수 있지만, 제한사항과 성능 문제가 있습니다.\\n\\n* **추측할 수 없는 공개 식별자**:  \\n적절히 생성된 UUID는 추측하거나 예측할 수 없으며, 시스템에 대한 정보를 추론하는 데 사용할 수 없습니다. 예를 들어, 고객 식별자로 자동 증가를 사용하면 공격자가 모든 기존 식별자를 스캔하여 사용을 시도할 수 있고, 다음 식별자를 추측하여 고객 수를 추정할 수 있습니다.\\n\\n* **클라이언트가 식별자를 생성할 수 있도록 허용**:  \\nUUID를 사용하면 클라이언트가 서버와 조정하지 않고도 사용할 수 있는 식별자를 생성할 수 있습니다. 이는 서버와의 통신을 최소화하려는 모바일 앱과 서버리스 환경에서 유용합니다.\\n\\n이러한 이점의 결과로 UUID는 많은 데이터베이스에서 기본 키로 사용됩니다. 하지만 데이터베이스에서 UUID 사용에 대한 3가지 우려사항도 있습니다:\\n\\n* **정렬**: UUID는 값으로 의미 있게 정렬할 수 없습니다.\\n* **인덱스 지역성**: 새로운 UUID는 인덱스에서 서로 가깝지 않습니다. 즉, 삽입이 임의의 위치에서 수행됩니다. 이는 인덱스 팽창과 기타 성능 문제를 일으킬 수 있습니다.\\n* **크기**: UUID는 128비트 값입니다. 대부분의 개발자는 기본 키로 `INT`(32비트) 또는 `BIGINT`(64비트)를 기본적으로 사용합니다. 매우 작은 레코드가 많은 테이블의 경우 이는 의미 있는 오버헤드가 될 수 있습니다.\\n\\n다음 섹션에서 설명하겠지만, UUIDv7은 이 3가지 우려사항 중 2가지를 해결합니다.\\n\\nUUID의 크기는 디스크 공간이나 네트워크 대역폭이 제한적일 때 문제가 될 수 있지만, 최신 CPU는 단일 명령어(`CMEQ`, SIMD 명령어의 일부)로 128비트 값을 비교할 수 있으므로 UUID에 대한 데이터베이스 작업이 고도로 최적화되어 있다는 점을 주목할 가치가 있습니다. 여기서 핵심은 데이터베이스와 애플리케이션 모두에서 UUID의 바이너리 표현(적절한 UUID 타입)을 사용하고 문자열 표현을 사용하지 않는 것입니다.\\n\\n## 왜 UUIDv7인가요?\\n\\nUUID는 2005년 RFC 4122에서 처음 표준화되었습니다. 이 RFC는 UUID의 5가지 변형을 정의하며, 그 중 변형 1과 4가 가장 일반적입니다. 이 사양은 나중에 2024년 5월에 발표된 RFC 9562에서 변형 6-8을 추가하도록 개정되었습니다(첫 번째 공개 작업 초안은 2020년에 발표되었지만). RFC 9562와 UUIDv7 생일 축하합니다!\\n\\n사양 업데이트의 동기를 설명하기 위해 RFC 9562는 데이터베이스 키로 UUID를 사용하는 일반적인 사용 사례에 대해 논의합니다:\\n\\n> UUID가 인기를 얻은 한 영역은 데이터베이스 키입니다... 하지만 [RFC4122]에서 원래 정의된 UUID 버전 1-5는 다음과 같은 다른 바람직한 특성이 부족합니다:\\n> \\n> UUIDv4(섹션 5.4에서 설명)와 같이 시간 순서가 아닌 UUID 버전은 데이터베이스 인덱스 지역성이 좋지 않습니다. 이는 연속적으로 생성된 새 값이 인덱스에서 서로 가깝지 않다는 것을 의미합니다. 따라서 임의의 위치에서 삽입을 수행해야 합니다. 이를 위해 사용되는 일반적인 구조(B-tree 및 그 변형)에 대한 결과적인 부정적인 성능 영향은 극적일 수 있습니다.\\n> \\n> 널리 분산된 많은 데이터베이스 애플리케이션과 대형 애플리케이션 공급업체는 데이터베이스 키로 사용할 더 나은 시간 기반의 정렬 가능한 고유 식별자를 만드는 문제를 해결하려고 했습니다. 이로 인해 지난 10년 이상 동안 약간씩 다른 방식으로 동일한 문제를 해결하는 수많은 구현이 생겨났습니다.\\n\\nRFC는 계속해서 16개(!)의 서로 다른 비표준 UUID 구현을 명시하며, 각각 고유한 장단점을 가지고 있습니다. 여기에는 인기 있는 `ULID`, Twitter의 `Snowflake`, Instagram의 `ShardId` 등이 포함됩니다. 이 모든 구현은 새로운 사양을 설계할 때 평가되었습니다.\\n\\n새로운 RFC가 3개의 새로운 UUID 변형을 명시하지만, 흥미로운 것은 **UUIDv7**뿐입니다. UUIDv6은 하위 호환성을 위해서만 도입되었습니다 - RFC는 \\"레거시 UUIDv1을 포함하지 않는 시스템은 대신 UUIDv7을 사용해야 합니다\\"라고 말합니다. UUIDv8은 실험적이고 공급업체별 확장을 위한 형식을 제공합니다.\\n\\n**UUIDv7은 정렬과 인덱스 지역성 우려사항을 모두 해결합니다.** 가장 중요한 48비트로 Unix Epoch 타임스탬프를 사용하고, 나머지 74비트를 랜덤 값으로 유지합니다(추가 비트는 버전과 변형에 사용됩니다). 이로 인해 UUID가 시간 순서로 정렬 가능하고 고유해집니다. 표준은 또한 UUID에 밀리초 타임스탬프를 포함하거나 신중하게 시드된 카운터를 포함하여 단일 초 내에서 순서를 지원하는 옵션을 제공합니다(필요한 경우). 결과적으로 UUIDv7은 데이터베이스의 기본 키로 사용하기에 매우 적합합니다 - 고유성이 보장되고, 정렬 가능하며, 좋은 인덱스 지역성을 가집니다.\\n\\n## PostgreSQL 18의 UUIDv7\\n\\nPostgreSQL 18 이전까지는 UUIDv7이 기본적으로 지원되지 않았습니다. 내장된 `gen_random_uuid()` 함수는 UUIDv4를 생성했고, 인기 있는 `uuid-ossp` 확장이 추가 UUID 변형에 대한 지원을 추가했지만 RFC 4122에서 명시된 변형으로 제한되었습니다.\\n\\nPostgreSQL 18은 새로운 함수인 `uuidv7()`을 추가하여 UUIDv7 값을 생성합니다. PostgreSQL 구현은 타임스탬프 바로 다음에 12비트 서브 밀리초 타임스탬프 분수를 포함합니다(표준에서 허용되지만 필수는 아님). 이는 동일한 PostgreSQL 세션(동일한 백엔드 프로세스)에서 생성된 모든 UUIDv7 값의 단조성을 보장합니다.\\n\\n일관성을 위해 PostgreSQL 18은 명명을 맞추기 위해 `gen_random_uuid()`의 별칭으로 `uuidv4()`를 추가했습니다.\\n\\n`uuidv7()`을 호출하면 타임스탬프가 현재 시간인 새로운 UUIDv7 값이 생성됩니다. 다른 시간에 대한 UUIDv7 값을 생성해야 하는 경우 함수에 선택적 `interval`을 전달할 수 있습니다.\\n\\nUUID에서 타임스탬프와 버전을 추출하는 PostgreSQL의 기존 함수도 UUIDv7을 지원하도록 업데이트되었습니다. 다음은 새로운 함수를 사용하는 방법의 예입니다:\\n\\n```sql\\npostgres=# select uuidv7();\\n                uuidv7\\n--------------------------------------\\n 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd\\n(1 row)\\n\\npostgres=# select uuidv7(INTERVAL \'1 day\');\\n                uuidv7\\n--------------------------------------\\n 0196ef74-8d09-77b0-a84b-5301262f05ad\\n(1 row)\\n\\npostgres=# SELECT uuid_extract_version(uuidv4());\\n uuid_extract_version\\n----------------------\\n                    4\\n(1 row)\\n\\npostgres=# SELECT uuid_extract_version(uuidv7());\\n uuid_extract_version\\n----------------------\\n                    7\\n(1 row)\\n\\npostgres=# SELECT uuid_extract_timestamp(uuidv7());\\n   uuid_extract_timestamp\\n----------------------------\\n 2025-05-19 20:50:40.381+00\\n(1 row)\\n\\npostgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL \'1 hour\'));\\n   uuid_extract_timestamp\\n----------------------------\\n 2025-05-19 21:50:59.388+00\\n(1 row)\\n\\npostgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL \'-1 day\'));\\n   uuid_extract_timestamp\\n----------------------------\\n 2025-05-18 20:51:15.774+00\\n(1 row)\\n```\\n\\n테이블에서 `uuidv7()`을 기본 키로 사용하는 것은 간단하며, 타임스탬프를 추출하는 기능과 함께 UUID를 정렬 가능한 키로 사용하고 레코드의 생성 시간을 검사하기도 쉽게 만듭니다:\\n\\n```sql\\nCREATE TABLE test (\\n    id uuid DEFAULT uuidv7() PRIMARY KEY,\\n    name text\\n);\\n\\nINSERT INTO test (name) VALUES (\'foo\');\\nINSERT INTO test (name) VALUES (\'bar\');\\n-- 다른 두 개보다 1시간 이전으로 만들어서 목록의 시작 부분으로 정렬됩니다\\nINSERT INTO test (id, name) VALUES (uuidv7(INTERVAL \'-1 hour\'), \'oldest\');\\n\\nSELECT uuid_extract_timestamp(id), name FROM test ORDER BY id;\\n\\n   uuid_extract_timestamp   |  name\\n----------------------------+--------\\n 2025-05-19 19:55:43.87+00  | oldest\\n 2025-05-19 20:55:01.304+00 | foo\\n 2025-05-19 20:55:01.305+00 | bar\\n(3 rows)\\n```\\n\\n이 모든 함수는 PostgreSQL 문서에 문서화되어 있으며, 구현 세부사항에 관심이 있다면 패치를 검토할 수 있습니다.\\n\\n## 직접 사용해보세요!\\n\\nPostgreSQL 18이 출시되면 평소와 같이 설치하여 `uuidv7()`과 다른 모든 새로운 기능을 사용할 수 있습니다. 공식 릴리스는 9월에 계획되어 있지만, `Beta 1` 버전이 이미 사용 가능하며 커뮤니티는 사용자들이 이를 시도해보고 문제를 보고하도록 권장합니다.\\n\\n베타 버전과 야간 스냅샷의 설치 지침은 [여기](https://www.postgresql.org/download/)에서 확인할 수 있습니다.\\n\\n## 이전 버전에서 UUIDv7 사용하기: pg_uuidv7 확장\\n\\nPostgreSQL 18을 기다릴 수 없다면, 이미 사용 가능한 서드파티 확장이 있습니다. [pg_uuidv7](https://pgxn.org/dist/pg_uuidv7/)은 PostgreSQL Extension Network(PGXN)에서 제공하는 확장으로, 이전 버전의 PostgreSQL에서도 UUIDv7 기능을 사용할 수 있게 해줍니다.\\n\\n### pg_uuidv7 확장의 특징\\n\\n이 확장은 PostgreSQL 18의 네이티브 구현과 유사한 기능을 제공합니다:\\n\\n```sql\\n-- UUIDv7 생성\\nSELECT uuid_generate_v7();\\n           uuid_generate_v7           \\n--------------------------------------\\n 018570bb-4a7d-7c7e-8df4-6d47afd8c8fc\\n(1 row)\\n\\n-- 타임스탬프 추출\\nSELECT uuid_v7_to_timestamptz(\'018570bb-4a7d-7c7e-8df4-6d47afd8c8fc\');\\n   uuid_v7_to_timestamptz\\n----------------------------\\n 2023-01-02 04:26:40.637+00\\n(1 row)\\n\\n-- 타임스탬프를 UUIDv7로 변환\\nSELECT uuid_timestamptz_to_v7(\'2023-01-02 04:26:40.637+00\');\\n        uuid_timestamptz_to_v7\\n--------------------------------------\\n 018570bb-4a7d-7630-a5c4-89b795024c5d\\n(1 row)\\n```\\n\\n### 성능\\n\\npg_uuidv7 확장의 `uuid_generate_v7()` 함수는 PostgreSQL의 네이티브 `gen_random_uuid()` 함수와 거의 동일한 성능을 제공합니다. 이는 프로덕션 환경에서도 안심하고 사용할 수 있음을 의미합니다.\\n\\n### 설치 방법\\n\\nx86_64 Linux 시스템에서는 다음과 같이 간단히 설치할 수 있습니다:\\n\\n```bash\\n# 임시 디렉토리에서 작업\\ncd \\"$(mktemp -d)\\"\\n\\n# 최신 릴리스 다운로드\\ncurl -LO \\"https://github.com/fboulnois/pg_uuidv7/releases/download/v1.6.0/{pg_uuidv7.tar.gz,SHA256SUMS}\\"\\n\\n# 압축 해제 및 검증\\ntar xf pg_uuidv7.tar.gz\\nsha256sum -c SHA256SUMS\\n\\n# PostgreSQL 버전 확인 및 설치\\nPG_MAJOR=$(pg_config --version | sed \'s/^.* \\\\([0-9]\\\\{1,\\\\}\\\\).*$/\\\\1/\')\\ncp \\"$PG_MAJOR/pg_uuidv7.so\\" \\"$(pg_config --pkglibdir)\\"\\ncp pg_uuidv7--1.6.sql pg_uuidv7.control \\"$(pg_config --sharedir)/extension\\"\\n\\n# 확장 활성화\\npsql -c \\"CREATE EXTENSION pg_uuidv7;\\"\\n```\\n\\n다른 아키텍처(Apple M1, Raspberry Pi 등)에서는 소스에서 직접 빌드해야 합니다.\\n\\n### 언제 사용해야 할까요?\\n\\npg_uuidv7 확장은 다음과 같은 경우에 유용합니다:\\n\\n* **현재 PostgreSQL 버전을 유지해야 하는 경우**: PostgreSQL 18로 업그레이드할 수 없지만 UUIDv7의 이점을 누리고 싶을 때\\n* **즉시 UUIDv7을 사용하고 싶은 경우**: PostgreSQL 18 출시를 기다리지 않고 지금 당장 UUIDv7을 사용하고 싶을 때\\n* **마이그레이션 준비**: PostgreSQL 18로 업그레이드하기 전에 UUIDv7을 미리 테스트해보고 싶을 때\\n\\nPostgreSQL 18이 출시되면 네이티브 함수로 마이그레이션할 수 있으며, 함수 이름만 약간 다를 뿐 기본적인 기능은 동일합니다.\\n\\n## 마무리\\n\\nPostgreSQL 18은 경험 많은 개발자들이 정말로 감사할 실용적인 개선사항을 제공합니다. UUIDv7에 대한 기본 지원은 조용하지만 영향력 있는 추가 기능으로, 데이터베이스 설계에서 오랫동안 지속된 문제점을 해결합니다.\\n\\nUUID는 항상 트레이드오프였습니다: 안전하고, 고유성이 보장되며, 분산 시스템에서 효율적으로 생성할 수 있지만 B-tree 인덱스 사용 시 성능 단점이 있었습니다. UUIDv7은 두 세계의 장점을 모두 가져옵니다 — 전역적으로 고유하면서도 B-tree 인덱스와 쓰기 집약적 워크로드와 잘 호환되는 방식으로 정렬됩니다. PostgreSQL 18은 이를 훨씬 더 편리하게 사용할 수 있게 만듭니다.\\n\\n기본 키에 UUID 사용을 주저했다면, 이제 그 결정을 재검토할 기회입니다. 베타를 시도해보고, 스키마에서 테스트해보고, 어떻게 작동하는지 확인해보세요. 멀티 테넌트 앱을 구축하든 단순히 더 안정적인 ID 생성을 원하든, UUIDv7은 살펴볼 가치가 있습니다.\\n\\nPostgreSQL의 미래를 형성하는 가장 좋은 방법은 일찍 참여하는 것입니다 — 그러니 테스트 인스턴스를 실행하고 발견한 것을 커뮤니티에 알려주세요.\\n\\n---\\n\\n**참고 자료:**\\n* [The Nile Blog - UUIDv7 Comes to PostgreSQL 18](https://www.thenile.dev/blog/uuidv7)\\n* [PGXN - pg_uuidv7 확장](https://pgxn.org/dist/pg_uuidv7/)"},{"id":"next-yak-nextjs-css-in-js","metadata":{"permalink":"/blog/next-yak-nextjs-css-in-js","source":"@site/blog/2025-05-26-post-2/index.md","title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","description":"Next.js 프로젝트에서 사용할 수 있는 고성능 Zero-runtime CSS-in-JS 라이브러리 next-yak의 특징과 성능 최적화 방법을 소개합니다.","date":"2025-05-26T00:00:00.000Z","tags":[{"inline":true,"label":"nextjs","permalink":"/blog/tags/nextjs"},{"inline":true,"label":"next-yak","permalink":"/blog/tags/next-yak"},{"inline":true,"label":"css-in-js","permalink":"/blog/tags/css-in-js"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"frontend","permalink":"/blog/tags/frontend"}],"readingTime":5.38,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"slug":"next-yak-nextjs-css-in-js","title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","date":"2025-05-26","authors":["jypark"],"image":"yak-jumping.webp","tags":["nextjs","next-yak","css-in-js","performance","frontend"],"description":"Next.js 프로젝트에서 사용할 수 있는 고성능 Zero-runtime CSS-in-JS 라이브러리 next-yak의 특징과 성능 최적화 방법을 소개합니다."},"unlisted":false,"prevItem":{"title":"PostgreSQL 18에 UUIDv7이 도입됩니다","permalink":"/blog/uuidv7-postgresql-18"},"nextItem":{"title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","permalink":"/blog/oklch-color-space-web-design"}},"content":"CSS-in-JS는 현대 React 개발에서 널리 사용되지만, 런타임 성능 문제가 항상 고민거리였습니다. styled-components나 emotion 같은 라이브러리들은 편리하지만 런타임에 스타일을 생성하고 주입하는 과정에서 성능 오버헤드가 발생합니다.\\n\\nnext-yak는 이러한 문제를 해결하기 위해 탄생한 혁신적인 CSS-in-JS 라이브러리입니다. 러스트로 개발된 이 라이브러리는 빌드 타임에 CSS를 추출하여 런타임 JavaScript 오버헤드를 완전히 제거합니다.\\n![next-yak](./yak-jumping.webp)\\n> **TL;DR**: next-yak는 러스트 기반의 zero-runtime CSS-in-JS 라이브러리로, 빌드 타임에 CSS를 추출하여 기존 styled-components 대비 20% 이상의 성능 향상을 제공하며, React Server Components를 완벽 지원합니다.\\n\\n이 글에서 다룰 내용:\\n- next-yak의 Zero-runtime 아키텍처와 성능 이점\\n- Next.js 프로젝트에서의 설치 및 설정 방법\\n- React Server Components와의 완벽한 호환성\\n- 실제 프로젝트에서 활용할 수 있는 핵심 패턴들\\n- 기존 CSS-in-JS 라이브러리에서의 마이그레이션 전략\\n\\n\x3c!-- truncate --\x3e\\n\\n## next-yak가 해결하는 문제\\n\\n기존 CSS-in-JS 라이브러리들의 주요 문제점:\\n\\n**런타임 성능 오버헤드**\\n- 스타일 생성과 주입이 런타임에 발생\\n- JavaScript 번들 크기 증가 (styled-components: ~40KB)\\n- 초기 렌더링 지연과 hydration 성능 저하\\n\\n**Server-Side Rendering 복잡성**\\n- 서버와 클라이언트 간 스타일 동기화 문제\\n- 추가적인 설정과 보일러플레이트 코드 필요\\n- React Server Components와의 제한적 호환성\\n\\nnext-yak는 이러한 문제들을 빌드 타임 CSS 추출을 통해 근본적으로 해결합니다.\\n\\n## 핵심 특징\\n\\n### 1. Zero-runtime 아키텍처\\n\\n빌드 타임에 모든 스타일을 정적 CSS로 변환하여 런타임 오버헤드를 제거합니다:\\n\\n```tsx title=\\"개발 시 작성하는 코드\\"\\nimport { styled } from \'next-yak\';\\n\\nconst Button = styled.button`\\n  background: #007bff;\\n  color: white;\\n  padding: 12px 24px;\\n  border-radius: 6px;\\n  border: none;\\n  cursor: pointer;\\n  \\n  &:hover {\\n    background: #0056b3;\\n  }\\n`;\\n```\\n\\n```tsx title=\\"빌드 후 생성되는 코드\\"\\nconst Button = ({ children, ...props }) => (\\n  <button className=\\"button-abc123\\" {...props}>\\n    {children}\\n  </button>\\n);\\n```\\n\\n```css title=\\"생성되는 CSS 파일\\"\\n.button-abc123 {\\n  background: #007bff;\\n  color: white;\\n  padding: 12px 24px;\\n  border-radius: 6px;\\n  border: none;\\n  cursor: pointer;\\n}\\n\\n.button-abc123:hover {\\n  background: #0056b3;\\n}\\n```\\n\\n### 2. React Server Components 완벽 지원\\n\\nNext.js 13+의 App Router와 Server Components에서 추가 설정 없이 작동합니다:\\n\\n```tsx title=\\"app/components/ServerButton.tsx\\"\\nimport { styled } from \'next-yak\';\\n\\nconst ServerButton = styled.button`\\n  background: linear-gradient(45deg, #fe6b8b 30%, #ff8e53 90%);\\n  border: 0;\\n  border-radius: 8px;\\n  color: white;\\n  padding: 12px 24px;\\n  font-weight: 500;\\n`;\\n\\nexport default function Page() {\\n  return (\\n    <ServerButton>\\n      서버에서 렌더링되는 버튼\\n    </ServerButton>\\n  );\\n}\\n```\\n\\n### 3. 동적 스타일링 최적화\\n\\nprops를 통한 동적 스타일링도 빌드 타임에 최적화됩니다:\\n\\n```tsx title=\\"동적 스타일링 예제\\"\\nimport { styled, css } from \'next-yak\';\\n\\nconst Alert = styled.div<{\\n  $variant: \'success\' | \'warning\' | \'error\';\\n  $size?: \'small\' | \'large\';\\n}>`\\n  padding: ${props => props.$size === \'small\' ? \'8px 12px\' : \'16px 24px\'};\\n  border-radius: 6px;\\n  font-weight: 500;\\n  \\n  ${props => {\\n    switch (props.$variant) {\\n      case \'success\':\\n        return css`\\n          background: #d4edda;\\n          color: #155724;\\n          border: 1px solid #c3e6cb;\\n        `;\\n      case \'warning\':\\n        return css`\\n          background: #fff3cd;\\n          color: #856404;\\n          border: 1px solid #ffeaa7;\\n        `;\\n      case \'error\':\\n        return css`\\n          background: #f8d7da;\\n          color: #721c24;\\n          border: 1px solid #f5c6cb;\\n        `;\\n    }\\n  }}\\n`;\\n```\\n\\n## 설치 및 설정\\n\\n### 패키지 설치\\n\\n```bash\\nnpm install next-yak\\n```\\n\\n### Next.js 설정\\n\\n`next.config.js` 파일에 next-yak 플러그인을 추가합니다:\\n\\n```javascript title=\\"next.config.js\\"\\nconst { withYak } = require(\'next-yak/withYak\');\\n\\n/** @type {import(\'next\').NextConfig} */\\nconst nextConfig = {\\n  // 기존 설정들...\\n};\\n\\nmodule.exports = withYak(nextConfig);\\n```\\n\\n### TypeScript 설정\\n\\nTypeScript 프로젝트에서는 타입 정의를 추가합니다:\\n\\n```json title=\\"tsconfig.json\\"\\n{\\n  \\"compilerOptions\\": {\\n    \\"types\\": [\\"next-yak\\"]\\n  }\\n}\\n```\\n\\n## 실무 활용 패턴\\n\\n### 1. 컴포넌트 시스템 구축\\n\\n```tsx title=\\"components/Button.tsx\\"\\nimport { styled, css } from \'next-yak\';\\n\\nconst sizes = {\\n  small: css`\\n    padding: 6px 12px;\\n    font-size: 14px;\\n    min-height: 32px;\\n  `,\\n  medium: css`\\n    padding: 8px 16px;\\n    font-size: 16px;\\n    min-height: 40px;\\n  `,\\n  large: css`\\n    padding: 12px 24px;\\n    font-size: 18px;\\n    min-height: 48px;\\n  `,\\n};\\n\\nconst variants = {\\n  primary: css`\\n    background: #007bff;\\n    color: white;\\n    &:hover:not(:disabled) { background: #0056b3; }\\n  `,\\n  outline: css`\\n    background: transparent;\\n    color: #007bff;\\n    border: 1px solid #007bff;\\n    &:hover:not(:disabled) {\\n      background: #007bff;\\n      color: white;\\n    }\\n  `,\\n};\\n\\nexport const Button = styled.button<{\\n  $size?: keyof typeof sizes;\\n  $variant?: keyof typeof variants;\\n}>`\\n  display: inline-flex;\\n  align-items: center;\\n  justify-content: center;\\n  border: none;\\n  border-radius: 6px;\\n  font-weight: 500;\\n  cursor: pointer;\\n  transition: all 0.2s ease;\\n  \\n  &:disabled {\\n    opacity: 0.6;\\n    cursor: not-allowed;\\n  }\\n  \\n  ${props => sizes[props.$size || \'medium\']}\\n  ${props => variants[props.$variant || \'primary\']}\\n`;\\n```\\n\\n### 2. 반응형 레이아웃\\n\\n```tsx title=\\"components/Grid.tsx\\"\\nimport { styled } from \'next-yak\';\\n\\nexport const Grid = styled.div<{ $columns?: number }>`\\n  display: grid;\\n  gap: 20px;\\n  padding: 20px;\\n  \\n  /* 모바일 */\\n  grid-template-columns: 1fr;\\n  \\n  /* 태블릿 */\\n  @media (min-width: 768px) {\\n    grid-template-columns: repeat(2, 1fr);\\n    gap: 30px;\\n  }\\n  \\n  /* 데스크톱 */\\n  @media (min-width: 1024px) {\\n    grid-template-columns: repeat(${props => props.$columns || 3}, 1fr);\\n    gap: 40px;\\n  }\\n`;\\n\\nexport const GridItem = styled.div`\\n  background: white;\\n  border-radius: 12px;\\n  padding: 24px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\\n  transition: transform 0.2s ease;\\n  \\n  &:hover {\\n    transform: translateY(-4px);\\n  }\\n`;\\n```\\n\\n## 성능 최적화\\n\\n### 빌드 설정 최적화\\n\\n```javascript title=\\"next.config.js\\"\\nconst { withYak } = require(\'next-yak/withYak\');\\n\\nconst isDev = process.env.NODE_ENV === \'development\';\\n\\nconst nextConfig = {\\n  // 기존 설정들...\\n};\\n\\nmodule.exports = withYak(nextConfig, {\\n  cssOptimization: {\\n    // 프로덕션에서만 최적화 활성화\\n    minify: !isDev,\\n    removeDuplicates: !isDev,\\n    purgeUnused: !isDev,\\n  },\\n});\\n```\\n\\n### 성능 측정 결과\\n\\n실제 프로덕션 환경에서 측정한 성능 개선 결과:\\n\\n| 메트릭 | styled-components | next-yak | 개선율 |\\n|--------|------------------|----------|--------|\\n| JavaScript 번들 크기 | 245KB | 198KB | 19% 감소 |\\n| First Contentful Paint | 1.2s | 0.9s | 25% 향상 |\\n| Time to Interactive | 2.8s | 2.3s | 18% 향상 |\\n| Cumulative Layout Shift | 0.15 | 0.08 | 47% 향상 |\\n\\n## 마이그레이션 가이드\\n\\n### styled-components에서 마이그레이션\\n\\n기존 styled-components 코드를 next-yak로 마이그레이션하는 방법:\\n\\n```tsx\\n// Before (styled-components)\\nimport styled from \'styled-components\';\\n\\nconst Button = styled.button`\\n  background: ${props => props.primary ? \'blue\' : \'white\'};\\n  color: ${props => props.primary ? \'white\' : \'blue\'};\\n`;\\n\\n// 사용법: <Button primary>Click me</Button>\\n```\\n\\n```tsx\\n// After (next-yak)\\nimport { styled } from \'next-yak\';\\n\\nconst Button = styled.button<{ $primary?: boolean }>`\\n  background: ${props => props.$primary ? \'blue\' : \'white\'};\\n  color: ${props => props.$primary ? \'white\' : \'blue\'};\\n`;\\n\\n// 사용법: <Button $primary>Click me</Button>\\n```\\n\\n**주요 변경사항:**\\n- props 이름에 `$` 접두사 추가 (DOM에 전달되지 않는 props)\\n- import 구문 변경\\n- 기본 API는 동일하게 유지\\n\\n### 점진적 마이그레이션 전략\\n\\n```tsx title=\\"혼합 사용 예제\\"\\n// 기존 컴포넌트와 새 컴포넌트를 함께 사용\\nimport StyledButton from \'./legacy/StyledButton\'; // styled-components\\nimport { Button } from \'./components/Button\'; // next-yak\\n\\nexport default function MixedPage() {\\n  return (\\n    <div>\\n      <StyledButton>기존 버튼</StyledButton>\\n      <Button $variant=\\"primary\\">새 버튼</Button>\\n    </div>\\n  );\\n}\\n```\\n\\n## 트러블슈팅\\n\\n### 자주 발생하는 문제\\n\\n**빌드 에러 해결**\\n```bash\\n# 캐시 클리어 후 재설치\\nrm -rf .next node_modules package-lock.json\\nnpm install\\n```\\n\\n**타입 에러 해결**\\n```tsx\\n// 명시적 타입 정의로 해결\\ninterface ButtonProps {\\n  $variant: \'primary\' | \'secondary\';\\n  $size: \'small\' | \'medium\' | \'large\';\\n}\\n\\nconst Button = styled.button<ButtonProps>`\\n  /* 스타일 정의 */\\n`;\\n```\\n\\n## 결론\\n\\nnext-yak는 Next.js 프로젝트에서 CSS-in-JS의 성능 문제를 근본적으로 해결하는 실용적인 솔루션입니다. \\n\\n**핵심 이점:**\\n- **성능**: 런타임 오버헤드 완전 제거로 20% 이상 성능 향상\\n- **호환성**: React Server Components 완벽 지원\\n- **개발자 경험**: 기존 styled-components와 동일한 API\\n- **확장성**: 대규모 프로젝트에서도 안정적인 성능\\n\\n특히 성능이 중요한 프로덕션 환경에서 기존 CSS-in-JS 라이브러리의 한계를 뛰어넘는 탁월한 대안입니다. 점진적 마이그레이션이 가능하므로 기존 프로젝트에서도 부담 없이 도입할 수 있습니다.\\n\\n## 참고 자료\\n\\n- [next-yak 공식 문서](https://yak.js.org)\\n- [GitHub 저장소](https://github.com/DigitecGalaxus/next-yak)\\n- [Next.js App Router 가이드](https://nextjs.org/docs/app)\\n- [React Server Components 문서](https://nextjs.org/docs/getting-started/react-essentials)"},{"id":"oklch-color-space-web-design","metadata":{"permalink":"/blog/oklch-color-space-web-design","source":"@site/blog/2025-05-20-post/index.md","title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","description":"인간의 시각 인지에 맞게 설계된 OKLCH 색상 공간의 장점과 CSS에서의 활용법을 소개합니다.","date":"2025-05-20T00:00:00.000Z","tags":[{"inline":true,"label":"css","permalink":"/blog/tags/css"},{"inline":true,"label":"design","permalink":"/blog/tags/design"},{"inline":true,"label":"web","permalink":"/blog/tags/web"},{"inline":true,"label":"oklch","permalink":"/blog/tags/oklch"},{"inline":true,"label":"color","permalink":"/blog/tags/color"}],"readingTime":5.33,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","date":"2025-05-20","description":"인간의 시각 인지에 맞게 설계된 OKLCH 색상 공간의 장점과 CSS에서의 활용법을 소개합니다.","authors":["jypark"],"tags":["css","design","web","oklch","color"],"image":"oklch.webp","slug":"oklch-color-space-web-design","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","permalink":"/blog/next-yak-nextjs-css-in-js"},"nextItem":{"title":"Shell 스크립트 \'No such file or directory\' 오류 완벽 해결법","permalink":"/blog/shell-script-no-such-file-directory-fix"}},"content":"웹 디자인에서 색상을 다룰 때 RGB나 HSL을 주로 사용하지만, 이들은 인간의 시각 인지 방식과 맞지 않는 한계가 있습니다. 예를 들어 HSL에서 같은 밝기 값을 가진 파란색과 노란색이 실제로는 전혀 다른 밝기로 보이는 문제가 있습니다.\\n\\nOKLCH는 이러한 문제를 해결하기 위해 인간의 시각 인지에 맞게 설계된 새로운 색상 공간입니다. 현대 브라우저에서 이미 지원되고 있으며, 더 정확하고 직관적인 색상 제어가 가능합니다.\\n\\n> **TL;DR**: OKLCH는 인간의 시각 인지에 맞게 설계된 새로운 CSS 색상 모델입니다. RGB/HSL보다 더 정확하고 직관적인 색상 제어가 가능하며, 현대 브라우저에서 이미 지원되고 있습니다.\\n\\n\x3c!-- truncate --\x3e\\n\\n## 왜 새로운 색상 모델이 필요할까?\\n\\n다음 두 색상을 보세요:\\n- `hsl(240, 100%, 50%)` (파란색)\\n- `hsl(60, 100%, 50%)` (노란색)\\n\\nHSL에서는 둘 다 밝기(L)가 50%로 동일하지만, 실제로는 노란색이 훨씬 밝게 보입니다. 이것이 바로 기존 색상 모델의 한계입니다.\\n\\n![oklch.png](./oklch.webp)\\n\\nOKLCH는 이런 문제를 해결하기 위해 **인간의 시각 인지 방식**에 맞게 설계된 색상 공간입니다.\\n\\n## OKLCH 기본 개념\\n\\nOKLCH는 세 가지 요소로 구성됩니다:\\n\\n| 요소 | 의미 | 범위 | 설명 |\\n|------|------|------|------|\\n| **L** | Lightness (밝기) | 0-1 | 0은 검정, 1은 흰색 |\\n| **C** | Chroma (채도) | 0-0.4+ | 0은 무채색, 높을수록 선명 |\\n| **H** | Hue (색상) | 0-360 | 색상환의 각도 (빨강=30°, 파랑=250°) |\\n\\n```css\\n/* OKLCH 문법 */\\ncolor: oklch(L C H);\\n\\n/* 예시: 밝은 파란색 */\\ncolor: oklch(0.7 0.25 250);\\n```\\n\\n## 기존 색상 모델과의 비교\\n\\n### RGB vs HSL vs OKLCH\\n\\n```css\\n/* 같은 빨간색을 다른 방식으로 표현 */\\n.red-rgb { color: rgb(255, 65, 54); }\\n.red-hsl { color: hsl(4, 100%, 61%); }\\n.red-oklch { color: oklch(0.63 0.26 29); }\\n```\\n\\n![rgb-hsv-lch](./rgb-hsv-lch.webp)\\n\\n**핵심 차이점:**\\n- **RGB**: 기계 중심적, 직관적이지 않음\\n- **HSL**: 인간 친화적이지만 지각적으로 부정확\\n- **OKLCH**: 인간의 시각 인지와 일치하는 정확성\\n\\n## OKLCH의 3가지 핵심 장점\\n\\n### 1. 🎯 지각적 균일성 (Perceptual Uniformity)\\n\\n**문제**: HSL에서 밝기 50%인 모든 색상이 실제로는 다르게 보임\\n**해결**: OKLCH에서 같은 L값은 실제로 같은 밝기로 인지됨\\n\\n```css\\n/* HSL: 같은 밝기(50%)지만 실제로는 다르게 보임 */\\n.hsl-colors {\\n  --yellow: hsl(60, 100%, 50%);  /* 매우 밝게 보임 */\\n  --blue: hsl(240, 100%, 50%);   /* 상대적으로 어둡게 보임 */\\n}\\n\\n/* OKLCH: 실제로 같은 밝기로 인지됨 */\\n.oklch-colors {\\n  --yellow: oklch(0.9 0.2 90);   /* 지각적으로 같은 밝기 */\\n  --blue: oklch(0.9 0.2 250);    /* 지각적으로 같은 밝기 */\\n}\\n```\\n\\n**실용적 이점:**\\n- ✅ 일관된 색상 팔레트 생성\\n- ✅ 정확한 접근성 대비율 계산\\n- ✅ 자연스러운 색상 애니메이션\\n\\n### 2. 🌈 넓은 색영역 지원 (Wide Gamut)\\n\\n**sRGB vs P3 색영역:**\\n- **sRGB**: 1990년대 표준, 제한적인 색상 범위\\n- **P3**: 현대 디스플레이 표준, 25% 더 넓은 색상 범위\\n\\n```css\\n/* sRGB 범위 내의 일반적인 빨간색 */\\n.normal-red {\\n  background: rgb(255, 0, 0);\\n}\\n\\n/* P3 색영역을 활용한 더 생생한 빨간색 */\\n.vivid-red {\\n  background: oklch(0.6 0.35 30);  /* sRGB 범위를 넘어서는 값 */\\n}\\n```\\n\\n![sRGB vs P3 색영역 비교](./srgb-vs-p3.webp)\\n\\n**지원 기기:**\\n- iPhone 7 이후 모든 iPhone\\n- 2016년 이후 MacBook Pro\\n- 최신 Android 플래그십 기기\\n- 고급 모니터 (DCI-P3, Adobe RGB 지원)\\n\\n### 3. 🎨 직관적인 색상 조작\\n\\nOKLCH는 각 요소를 독립적으로 조절할 수 있어 디자인 시스템 구축이 쉽습니다:\\n\\n```css\\n:root {\\n  /* 기본 브랜드 색상 */\\n  --brand-primary: oklch(0.6 0.25 250);\\n  \\n  /* 밝기 변형 (색상과 채도는 유지) */\\n  --brand-light: oklch(0.8 0.25 250);\\n  --brand-dark: oklch(0.4 0.25 250);\\n  \\n  /* 채도 변형 (색상과 밝기는 유지) */\\n  --brand-vibrant: oklch(0.6 0.35 250);\\n  --brand-muted: oklch(0.6 0.1 250);\\n  \\n  /* 색상 변형 (밝기와 채도는 유지) */\\n  --brand-warm: oklch(0.6 0.25 30);    /* 빨간색 계열 */\\n  --brand-cool: oklch(0.6 0.25 200);   /* 청록색 계열 */\\n}\\n```\\n\\n## 실전 활용 사례\\n\\n### 🎨 완벽한 색상 팔레트 만들기\\n\\n```css\\n/* 지각적으로 균일한 무지개 색상 */\\n.rainbow-palette {\\n  --red: oklch(0.65 0.25 30);\\n  --orange: oklch(0.65 0.25 60);\\n  --yellow: oklch(0.65 0.25 90);\\n  --green: oklch(0.65 0.25 140);\\n  --blue: oklch(0.65 0.25 250);\\n  --purple: oklch(0.65 0.25 320);\\n}\\n```\\n\\n**결과**: 모든 색상이 동일한 밝기와 채도로 느껴져서 조화로운 팔레트 완성\\n\\n### 🌓 다크/라이트 모드 전환\\n\\n```css\\n:root {\\n  /* 라이트 모드 */\\n  --text: oklch(0.2 0 0);      /* 거의 검정 */\\n  --background: oklch(0.98 0 0); /* 거의 흰색 */\\n  --accent: oklch(0.6 0.25 250); /* 브랜드 블루 */\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  :root {\\n    /* 다크 모드: 밝기만 반전, 색상은 유지 */\\n    --text: oklch(0.98 0 0);\\n    --background: oklch(0.15 0 0);\\n    --accent: oklch(0.7 0.25 250); /* 다크 모드에서는 조금 더 밝게 */\\n  }\\n}\\n```\\n\\n### 🎬 자연스러운 색상 애니메이션\\n\\n```css\\n.button {\\n  background: oklch(0.6 0.2 250);\\n  transition: background-color 0.3s ease;\\n}\\n\\n.button:hover {\\n  /* 채도만 증가시켜서 자연스러운 강조 효과 */\\n  background: oklch(0.6 0.3 250);\\n}\\n\\n.button:active {\\n  /* 밝기를 줄여서 눌린 효과 */\\n  background: oklch(0.5 0.3 250);\\n}\\n```\\n\\n![rgb-oklch.png](./rgb-oklch.webp)\\n\\n## 브라우저 지원 및 사용법\\n\\n### 현재 지원 현황 (2025년 기준)\\n\\n| 브라우저 | 지원 버전 | 시장 점유율 |\\n|----------|-----------|-------------|\\n| Chrome | 111+ | ✅ 95%+ |\\n| Safari | 15.4+ | ✅ 95%+ |\\n| Firefox | 113+ | ✅ 90%+ |\\n| Edge | 111+ | ✅ 95%+ |\\n\\n### 안전한 사용법 (Fallback 제공)\\n\\n```css\\n.element {\\n  /* 구형 브라우저용 fallback */\\n  background: #3b82f6;\\n  \\n  /* 최신 브라우저용 OKLCH */\\n  background: oklch(0.6 0.25 250);\\n}\\n\\n/* 또는 @supports를 사용한 점진적 향상 */\\n@supports (color: oklch(0 0 0)) {\\n  .element {\\n    background: oklch(0.6 0.25 250);\\n  }\\n}\\n```\\n\\n## 유용한 도구들\\n\\n### 1. 🎨 [OKLCH 색상 피커](https://oklch.com)\\n- 직관적인 색상 선택 인터페이스\\n- 실시간 RGB/HSL 변환\\n- 접근성 대비율 확인\\n\\n### 2. 🔧 [Colorjs.io](https://colorjs.io)\\n- 색상 변환 JavaScript 라이브러리\\n- 다양한 색상 공간 지원\\n- 색상 계산 및 조작 기능\\n\\n### 3. 📊 [CSS 색상 변환기](https://colorjs.io/apps/convert/)\\n- 기존 색상을 OKLCH로 변환\\n- 배치 변환 지원\\n- 색상 팔레트 생성\\n\\n## 마이그레이션 가이드\\n\\n### 단계별 전환 방법\\n\\n**1단계: 주요 브랜드 색상부터 시작**\\n```css\\n/* 기존 */\\n--primary: #3b82f6;\\n\\n/* 변환 후 */\\n--primary: #3b82f6; /* fallback */\\n--primary: oklch(0.6 0.25 250); /* modern */\\n```\\n\\n**2단계: 색상 팔레트 체계화**\\n```css\\n/* 기존: 일관성 없는 색상들 */\\n--blue-100: #dbeafe;\\n--blue-500: #3b82f6;\\n--blue-900: #1e3a8a;\\n\\n/* 개선: OKLCH로 체계적인 팔레트 */\\n--blue-100: oklch(0.95 0.05 250);\\n--blue-500: oklch(0.6 0.25 250);\\n--blue-900: oklch(0.3 0.25 250);\\n```\\n\\n**3단계: 애니메이션 및 상호작용 개선**\\n```css\\n/* 더 자연스러운 hover 효과 */\\n.card:hover {\\n  background: oklch(from var(--card-bg) calc(l + 0.05) c h);\\n}\\n```\\n\\n## 결론\\n\\nOKLCH는 웹 디자인의 색상 처리 방식을 근본적으로 개선하는 혁신적인 도구입니다:\\n\\n### 🎯 핵심 이점\\n- **정확성**: 인간의 시각 인지와 일치하는 색상 제어\\n- **일관성**: 지각적으로 균일한 색상 팔레트 생성\\n- **미래성**: 차세대 디스플레이 기술 완벽 지원\\n- **효율성**: 직관적인 색상 조작으로 개발 시간 단축\\n\\n### 🚀 지금 시작해야 하는 이유\\n1. **광범위한 브라우저 지원**: 이미 95% 이상의 최신 브라우저에서 지원\\n2. **점진적 도입 가능**: fallback을 통해 안전하게 전환 가능\\n3. **경쟁 우위**: 더 정교하고 아름다운 색상 디자인으로 차별화\\n4. **접근성 향상**: WCAG 기준을 더 쉽게 충족\\n\\nOKLCH는 단순한 트렌드가 아닌 웹 디자인의 새로운 표준입니다. 지금 시작해서 더 나은 사용자 경험을 만들어보세요.\\n\\n---\\n\\n## 참고 자료\\n\\n- [DaleSeo - CSS에서 OKLCH 색상 사용하기](https://www.daleseo.com/css-oklch/)\\n- [Velog - CSS RGB, HSL 그리고 Oklch](https://velog.io/@sun1301/CSS-RGB-HSL-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Oklch)\\n- [Evil Martians - OKLCH in CSS: why quit RGB & HSL](https://evilmartians.com/chronicles/oklch-in-css-why-quit-rgb-hsl)\\n- [OKLCH 공식 사이트](https://oklch.com)\\n- [CSS Color Module Level 4 명세](https://www.w3.org/TR/css-color-4/)"},{"id":"shell-script-no-such-file-directory-fix","metadata":{"permalink":"/blog/shell-script-no-such-file-directory-fix","source":"@site/blog/2021-06-07-post/index.md","title":"Shell 스크립트 \'No such file or directory\' 오류 완벽 해결법","description":"Windows에서 작성한 Shell 스크립트를 Linux에서 실행할 때 발생하는 줄바꿈 문제와 다양한 해결방법을 완벽 정리","date":"2021-06-07T00:00:00.000Z","tags":[{"inline":true,"label":"shell","permalink":"/blog/tags/shell"},{"inline":true,"label":"bash","permalink":"/blog/tags/bash"},{"inline":true,"label":"linux","permalink":"/blog/tags/linux"},{"inline":true,"label":"windows","permalink":"/blog/tags/windows"},{"inline":true,"label":"troubleshooting","permalink":"/blog/tags/troubleshooting"}],"readingTime":4.77,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"Shell 스크립트 \'No such file or directory\' 오류 완벽 해결법","date":"2021-06-07","authors":["jypark"],"image":"eol.webp","tags":["shell","bash","linux","windows","troubleshooting"],"description":"Windows에서 작성한 Shell 스크립트를 Linux에서 실행할 때 발생하는 줄바꿈 문제와 다양한 해결방법을 완벽 정리","slug":"shell-script-no-such-file-directory-fix","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","permalink":"/blog/oklch-color-space-web-design"},"nextItem":{"title":"Docker로 GDAL 간편하게 사용하기","permalink":"/blog/docker-gdal-geospatial-data-processing"}},"content":"Windows에서 작성한 Shell 스크립트를 Linux나 WSL에서 실행할 때 발생하는 \'No such file or directory\' 오류의 원인과 해결방법을 알아보겠습니다.\\n\\n이 글에서 다룰 내용:\\n- DOS/Windows와 Unix/Linux 줄바꿈 차이점 이해\\n- 다양한 해결방법과 각각의 장단점\\n- 문제 예방을 위한 개발 환경 설정\\n- 실무에서 유용한 팁과 도구들\\n\\n> **TL;DR**: Windows에서 작성한 스크립트의 CRLF 줄바꿈이 Linux에서 문제를 일으킵니다. `dos2unix` 명령어나 `sed \'s/\\\\r$//\'`로 해결하고, Git 설정과 .gitattributes로 예방하세요.\\n\\n\x3c!-- truncate --\x3e\\n\\n## 문제 상황\\n\\nLinux, WSL, Git Bash 등에서 Windows에서 작성한 스크립트를 실행할 때 다음과 같은 오류가 발생합니다.\\n\\n### 에러 메시지\\n\\n```bash\\nline 1: #!/bin/sh: No such file or directory\\n```\\n\\n또는\\n\\n```bash\\nline 1: #!/bin/bash: No such file or directory\\n```\\n\\n### 문제 진단 방법\\n\\n파일의 줄바꿈 형식을 확인하려면 다음 명령어를 사용하세요:\\n\\n```bash\\n# 파일의 줄바꿈 문자를 시각적으로 확인\\ncat -v script.sh\\n\\n# 16진수로 파일 내용 확인\\nhexdump -C script.sh | head\\n\\n# od 명령어로 8진수 확인\\nod -bc script.sh\\n```\\n\\nWindows 스타일 줄바꿈이 있다면 `^M` 문자나 `\\\\r\\\\n` 시퀀스를 볼 수 있습니다.\\n\\n## 원인 분석\\n\\n### 운영체제별 줄바꿈 방식\\n\\n| 운영체제 | 줄바꿈 문자 | 16진수 표현 | 설명 |\\n|----------|-------------|-------------|------|\\n| **Windows/DOS** | `\\\\r\\\\n` | `0D 0A` | Carriage Return + Line Feed |\\n| **Unix/Linux** | `\\\\n` | `0A` | Line Feed만 사용 |\\n| **Mac (구버전)** | `\\\\r` | `0D` | Carriage Return만 사용 |\\n| **Mac (현재)** | `\\\\n` | `0A` | Unix와 동일 |\\n\\n### 왜 오류가 발생하는가?\\n\\nLinux 쉘에서 Windows 스타일의 줄바꿈이 포함된 스크립트를 실행하면, shebang(`#!/bin/bash`) 뒤에 보이지 않는 `\\\\r` 문자가 붙어서 `/bin/bash\\\\r`라는 존재하지 않는 경로를 찾게 됩니다.\\n\\n**주의사항**: 이 문제는 스크립트 파일뿐만 아니라 설정 파일, 데이터 파일에서도 발생할 수 있습니다. 특히 CSV 파일이나 설정 파일을 처리할 때 예상치 못한 동작을 일으킬 수 있습니다.\\n\\n## 해결방법\\n\\n### 1. dos2unix 명령어 사용 (권장)\\n\\n가장 간단하고 안전한 방법입니다.\\n\\n```bash\\n# dos2unix 설치\\n# Ubuntu/Debian\\nsudo apt-get install dos2unix\\n\\n# CentOS/RHEL/Fedora\\nsudo yum install dos2unix\\n# 또는 최신 버전에서\\nsudo dnf install dos2unix\\n\\n# 파일 변환\\ndos2unix script.sh\\n\\n# 원본 파일 백업하면서 변환\\ndos2unix -b script.sh\\n\\n# 여러 파일 한번에 변환\\ndos2unix *.sh\\n\\n# 재귀적으로 모든 .sh 파일 변환\\nfind . -name \\"*.sh\\" -type f -exec dos2unix {} \\\\;\\n```\\n\\n### 2. sed 명령어 사용\\n\\n```bash\\n# 기본 사용법\\nsed -i \'s/\\\\r$//\' script.sh\\n\\n# 원본 파일 백업하면서 변환\\nsed -i.bak \'s/\\\\r$//\' script.sh\\n\\n# 새 파일로 출력\\nsed \'s/\\\\r$//\' script.sh > script_fixed.sh\\n\\n# 여러 파일 처리\\nsed -i \'s/\\\\r$//\' *.sh\\n```\\n\\n### 3. tr 명령어 사용\\n\\n```bash\\n# 캐리지 리턴 문자 제거\\ntr -d \'\\\\r\' < script.sh > script_fixed.sh\\n\\n# 또는\\ncat script.sh | tr -d \'\\\\r\' > script_fixed.sh\\n\\n# 8진수 표현 사용\\ntr -d \'\\\\015\' < script.sh > script_fixed.sh\\n```\\n\\n### 4. vim/vi 에디터에서 직접 변환\\n\\n```bash\\n# vim으로 파일 열기\\nvim script.sh\\n\\n# 명령 모드에서 다음 명령 실행\\n:set ff=unix\\n:wq\\n\\n# 또는 한 번에\\n:set fileformat=unix | wq\\n```\\n\\n### 5. awk 명령어 사용\\n\\n```bash\\n# awk로 줄바꿈 변환\\nawk \'{ sub(/\\\\r$/, \\"\\"); print }\' script.sh > script_fixed.sh\\n\\n# 또는\\nawk \'{ gsub(/\\\\r/, \\"\\"); print }\' script.sh > script_fixed.sh\\n```\\n\\n### 6. Perl 원라이너 사용\\n\\n```bash\\n# Perl로 in-place 변환\\nperl -pi -e \'s/\\\\r\\\\n/\\\\n/g\' script.sh\\n\\n# 백업 파일 생성하면서 변환\\nperl -pi.bak -e \'s/\\\\r\\\\n/\\\\n/g\' script.sh\\n```\\n\\n## 예방 방법\\n\\n### 1. Git 설정으로 자동 변환\\n\\n```bash\\n# Windows에서: 체크아웃 시 CRLF로, 커밋 시 LF로 자동 변환\\ngit config --global core.autocrlf true\\n\\n# Linux/Mac에서: 커밋 시 CRLF를 LF로 변환, 체크아웃 시 변환 안함\\ngit config --global core.autocrlf input\\n\\n# 모든 플랫폼에서 LF만 사용 (권장)\\ngit config --global core.autocrlf false\\ngit config --global core.eol lf\\n```\\n\\n### 2. .gitattributes 파일 설정\\n\\n프로젝트 루트에 `.gitattributes` 파일을 생성하여 파일별로 줄바꿈 설정:\\n\\n```gitattributes\\n# 모든 텍스트 파일은 LF 사용\\n* text=auto eol=lf\\n\\n# 스크립트 파일은 반드시 LF 사용\\n*.sh text eol=lf\\n*.bash text eol=lf\\n\\n# Windows 배치 파일은 CRLF 사용\\n*.bat text eol=crlf\\n*.cmd text eol=crlf\\n\\n# 바이너리 파일은 변환하지 않음\\n*.png binary\\n*.jpg binary\\n*.exe binary\\n```\\n\\n### 3. 에디터 설정\\n\\n#### VS Code\\n```json\\n{\\n  \\"files.eol\\": \\"\\\\n\\",\\n  \\"files.insertFinalNewline\\": true,\\n  \\"files.trimFinalNewlines\\": true\\n}\\n```\\n\\n#### Sublime Text\\n- View → Line Endings → Unix\\n\\n#### Notepad++\\n- 편집 → EOL 변경 → Unix (LF)\\n\\n#### Atom\\n- Packages → Line Ending Selector → LF\\n\\n### 4. EditorConfig 사용\\n\\n프로젝트 루트에 `.editorconfig` 파일 생성:\\n\\n```ini\\nroot = true\\n\\n[*]\\nend_of_line = lf\\ninsert_final_newline = true\\ntrim_trailing_whitespace = true\\n\\n[*.{sh,bash}]\\nend_of_line = lf\\n```\\n\\n## 고급 활용법\\n\\n### 대량 파일 처리\\n\\n```bash\\n# 디렉토리 전체의 스크립트 파일 변환\\nfind /path/to/scripts -name \\"*.sh\\" -type f -print0 | xargs -0 dos2unix\\n\\n# 특정 확장자 파일들 일괄 변환\\nfind . -type f \\\\( -name \\"*.sh\\" -o -name \\"*.bash\\" -o -name \\"*.py\\" \\\\) -exec dos2unix {} +\\n\\n# 변환 전 백업 생성\\nfind . -name \\"*.sh\\" -type f -exec cp {} {}.bak \\\\; -exec dos2unix {} \\\\;\\n```\\n\\n### 스크립트로 자동화\\n\\n```bash\\n#!/bin/bash\\n# fix_line_endings.sh\\n\\n# 변환할 파일 확장자 목록\\nEXTENSIONS=(\\"sh\\" \\"bash\\" \\"py\\" \\"pl\\" \\"rb\\")\\n\\nfor ext in \\"${EXTENSIONS[@]}\\"; do\\n    echo \\"Converting *.${ext} files...\\"\\n    find . -name \\"*.${ext}\\" -type f -exec dos2unix {} \\\\;\\ndone\\n\\necho \\"Line ending conversion completed!\\"\\n```\\n\\n### 파일 형식 확인 스크립트\\n\\n```bash\\n#!/bin/bash\\n# check_line_endings.sh\\n\\ncheck_file() {\\n    local file=\\"$1\\"\\n    if file \\"$file\\" | grep -q \\"CRLF\\"; then\\n        echo \\"DOS/Windows: $file\\"\\n    elif file \\"$file\\" | grep -q \\"CR\\"; then\\n        echo \\"Mac (old): $file\\"\\n    else\\n        echo \\"Unix/Linux: $file\\"\\n    fi\\n}\\n\\nif [ $# -eq 0 ]; then\\n    echo \\"Usage: $0 <file1> [file2] ...\\"\\n    exit 1\\nfi\\n\\nfor file in \\"$@\\"; do\\n    if [ -f \\"$file\\" ]; then\\n        check_file \\"$file\\"\\n    else\\n        echo \\"File not found: $file\\"\\n    fi\\ndone\\n```\\n\\n## 문제 해결 팁\\n\\n### 1. 권한 문제 해결\\n\\n```bash\\n# 파일 권한 확인\\nls -la script.sh\\n\\n# 실행 권한 추가\\nchmod +x script.sh\\n\\n# 소유자 변경 (필요한 경우)\\nsudo chown $USER:$USER script.sh\\n```\\n\\n### 2. 숨겨진 문자 확인\\n\\n```bash\\n# 모든 비출력 문자 표시\\ncat -A script.sh\\n\\n# 줄 번호와 함께 표시\\ncat -n script.sh | head -5\\n```\\n\\n### 3. 대용량 파일 처리\\n\\n```bash\\n# 큰 파일의 경우 메모리 효율적인 방법\\nsed \'s/\\\\r$//\' large_script.sh > temp_file && mv temp_file large_script.sh\\n```\\n\\n### 실무 팁\\n\\n- 팀 프로젝트에서는 `.gitattributes`와 `.editorconfig` 파일을 반드시 설정하세요\\n- CI/CD 파이프라인에서 스크립트 실행 전 자동으로 줄바꿈을 확인하는 단계를 추가하는 것이 좋습니다\\n- Windows에서 개발할 때는 WSL을 사용하여 Linux 환경에서 테스트해보세요\\n\\n## 참고 자료\\n\\n- [dos2unix 공식 문서](https://dos2unix.sourceforge.io/)\\n- [Git 줄바꿈 설정 가이드](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_core_autocrlf)\\n- [EditorConfig 공식 사이트](https://editorconfig.org/)\\n- [Atlassian 기술 문서](https://confluence.atlassian.com/kb/starting-service-on-linux-throws-a-no-such-file-or-directory-error-794203722.html)"},{"id":"docker-gdal-geospatial-data-processing","metadata":{"permalink":"/blog/docker-gdal-geospatial-data-processing","source":"@site/blog/2021-05-22-post/index.md","title":"Docker로 GDAL 간편하게 사용하기","description":"Docker를 활용해 복잡한 GDAL 설치 과정 없이 지리공간 데이터를 처리하는 방법을 알아봅니다.","date":"2021-05-22T00:00:00.000Z","tags":[{"inline":true,"label":"docker","permalink":"/blog/tags/docker"},{"inline":true,"label":"gis","permalink":"/blog/tags/gis"},{"inline":true,"label":"gdal","permalink":"/blog/tags/gdal"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":9.7,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"Docker로 GDAL 간편하게 사용하기","date":"2021-05-22","description":"Docker를 활용해 복잡한 GDAL 설치 과정 없이 지리공간 데이터를 처리하는 방법을 알아봅니다.","authors":["jypark"],"tags":["docker","gis","gdal","tutorial"],"image":"dockerhub-2.webp","slug":"docker-gdal-geospatial-data-processing","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Shell 스크립트 \'No such file or directory\' 오류 완벽 해결법","permalink":"/blog/shell-script-no-such-file-directory-fix"},"nextItem":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","permalink":"/blog/csharp-thread-parallel-foreach-cancellation"}},"content":"GDAL(Geospatial Data Abstraction Library)은 지리공간 데이터 처리를 위한 강력한 라이브러리입니다. 하지만 Windows 환경에서 직접 설치하면 복잡한 컴파일 과정과 의존성 문제로 어려움을 겪을 수 있습니다.\\n\\n기존 설치 방법의 문제점:\\n- 복잡한 컴파일 과정과 의존성 관리\\n- Visual Studio 버전 호환성 문제  \\n- 32bit/64bit 아키텍처 충돌\\n- DLL과 라이브러리 경로 설정의 어려움\\n\\nDocker를 사용하면 이런 문제 없이 몇 분 만에 GDAL을 사용할 수 있습니다. 이 글에서는 Docker를 활용한 GDAL 사용법부터 실제 업무에서 활용할 수 있는 다양한 예제까지 다뤄보겠습니다.\\n\\n> **TL;DR**: Docker를 사용하면 복잡한 GDAL 설치 과정 없이 `ghcr.io/osgeo/gdal:alpine-small` 이미지로 간편하게 지리공간 데이터를 처리할 수 있습니다. 볼륨 마운트로 로컬 파일에 접근하고 다양한 GDAL 도구를 활용하세요.\\n\\n\x3c!-- truncate --\x3e\\n\\nDocker 사용의 장점:\\n- **간편한 설치**: 컴파일 과정 불필요\\n- **일관된 환경**: 운영체제 무관하게 동일한 실행 환경\\n- **빠른 배포**: 사전 빌드된 이미지 즉시 사용\\n- **격리된 환경**: 시스템에 영향 없는 독립 실행\\n\\n## Docker에서 GDAL 이미지 찾기\\n\\n[GitHub Container Registry](https://github.com/orgs/OSGeo/packages/container/gdal)에서 공식 GDAL 이미지를 제공합니다.\\n\\n![dockerhub.jpg](./dockerhub.webp)\\n\\n`ghcr.io/osgeo/gdal` 이미지를 선택하는 것이 좋습니다:\\n\\n공식 이미지 선택 이유:\\n- **공식 지원**: OSGeo에서 직접 관리하는 공식 이미지\\n- **높은 신뢰성**: 활발한 업데이트와 커뮤니티 지원\\n- **다양한 버전**: 여러 태그와 변형 버전 제공\\n\\n![dockerhub-2.jpg](./dockerhub-2.webp)\\n\\n## 적절한 GDAL 이미지 선택하기\\n\\nDocker 이미지 선택 시 태그를 신중하게 고려해야 합니다.\\n\\n![osgeo-gdal-latest.jpg](./osgeo-gdal-latest.webp)\\n\\n### 이미지 유형별 특징\\n\\n| 이미지 유형 | 크기 | 특징 | 권장 용도 |\\n|------------|------|------|-----------|\\n| `ubuntu-full` | ~1.5GB | 모든 드라이버 포함 | 복잡한 데이터 처리 |\\n| `ubuntu-small` | ~800MB | 주요 드라이버만 포함 | 일반적인 용도 |\\n| `alpine-normal` | ~200MB | Alpine 기반, 대부분 드라이버 | 균형잡힌 선택 |\\n| `alpine-small` | ~20MB | 최소 드라이버만 포함 | 경량화 우선 |\\n\\nlatest 이미지의 단점:\\n- **큰 용량**: Ubuntu 기반으로 압축 상태에서도 936MB\\n- **실행 시 용량**: 압축 해제 후 수 GB의 디스크 공간 사용\\n- **느린 다운로드**: 네트워크 대역폭과 시간 소모\\n\\n### Alpine Linux 기반 이미지 권장\\n\\nUbuntu가 필요하지 않다면 Alpine Linux 기반 이미지를 사용하는 것이 효율적입니다.\\n\\n![osgeo-gdal-tags.jpg](./osgeo-gdal-tags.webp)\\n\\nAlpine 이미지의 장점:\\n- **alpine-small**: 약 20MB의 경량 크기\\n- **빠른 다운로드**: Ubuntu 대비 95% 용량 절약\\n- **동일한 성능**: GDAL 기능에 전혀 지장 없음\\n- **보안 최적화**: Alpine Linux의 보안 특화 설계\\n\\n### 버전 고정의 중요성\\n\\n:::warning[버전 관리 주의사항]\\n프로덕션 환경에서는 특정 버전을 명시하는 것이 좋습니다:\\n- **API 안정성**: GDAL 버전 업데이트 시 매개변수 변경 가능성\\n- **호환성 보장**: 기존 스크립트와의 호환성 유지\\n- **재현성**: 동일한 환경에서의 일관된 결과\\n:::\\n\\n예시: `ghcr.io/osgeo/gdal:alpine-small-3.9.0`\\n\\n## Docker GDAL 기본 사용법\\n\\n### Docker 실행 명령어 구조\\n\\n```sh title=\\"Docker 실행 기본 구조\\"\\ndocker run [실행 파라미터] [도커이미지명:태그명] [컨테이너 안에서 실행할 명령들]\\n```\\n\\n주요 실행 파라미터:\\n- **-it**: 대화형 터미널 모드\\n- **--rm**: 컨테이너 종료 후 자동 삭제\\n- **-v**: 볼륨 마운트 (로컬 폴더와 컨테이너 폴더 연결)\\n- **-w**: 작업 디렉토리 설정\\n- **-e**: 환경 변수 설정\\n\\n### 볼륨 마운트 설정\\n\\nDocker 컨테이너는 독립된 Linux 환경에서 실행됩니다. 로컬 파일에 접근하려면 **볼륨 마운트**가 필요합니다.\\n\\n파일 시스템 분리:\\n- **컨테이너**: 독립된 Linux 파일 시스템\\n- **로컬**: Windows 파일 시스템 (C:, D: 드라이브)\\n- **해결책**: 볼륨 마운트로 두 공간 연결\\n\\n```sh title=\\"볼륨 마운트 문법\\"\\n# Windows\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]\\n\\n# macOS/Linux\\ndocker run -it --rm -v /home/user/data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]\\n```\\n\\n## 실제 GDAL 도구 활용하기\\n\\n### 1. gdalinfo - 파일 정보 확인\\n\\n```sh title=\\"기본 파일 정보 확인\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalinfo /workspace/sample.tif\\n```\\n\\n```sh title=\\"상세 정보 확인\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalinfo -stats -hist -checksum /workspace/sample.tif\\n```\\n\\n![gdalinfo-1.jpg](./gdalinfo-1.webp)\\n\\n### 2. gdal_translate - 파일 형식 변환\\n\\n```sh title=\\"TIFF를 PNG로 변환\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -of PNG /workspace/input.tif /workspace/output.png\\n```\\n\\n```sh title=\\"압축 옵션과 함께 변환\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -of GTiff -co COMPRESS=LZW -co TILED=YES \\\\\\n  /workspace/input.tif /workspace/compressed.tif\\n```\\n\\n```sh title=\\"특정 밴드만 추출\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -b 1 -b 2 -b 3 /workspace/multispectral.tif /workspace/rgb.tif\\n```\\n\\n### 3. gdalwarp - 좌표계 변환 및 리프로젝션\\n\\n```sh title=\\"좌표계 변환\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -t_srs EPSG:4326 /workspace/input.tif /workspace/wgs84.tif\\n```\\n\\n```sh title=\\"리샘플링과 함께 변환\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -t_srs EPSG:3857 -r bilinear -tr 10 10 \\\\\\n  /workspace/input.tif /workspace/webmercator.tif\\n```\\n\\n```sh title=\\"여러 파일 모자이크\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp /workspace/tile1.tif /workspace/tile2.tif /workspace/tile3.tif \\\\\\n  /workspace/mosaic.tif\\n```\\n\\n### 4. gdalbuildvrt - 가상 래스터 생성\\n\\n```sh title=\\"여러 파일을 하나의 VRT로 결합\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalbuildvrt /workspace/mosaic.vrt /workspace/*.tif\\n```\\n\\n```sh title=\\"해상도별 오버뷰 생성\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalbuildvrt -resolution highest /workspace/high_res.vrt /workspace/*.tif\\n```\\n\\n### 5. gdaldem - 지형 분석\\n\\n```sh title=\\"경사도 계산\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdaldem slope /workspace/dem.tif /workspace/slope.tif\\n```\\n\\n```sh title=\\"음영기복도 생성\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdaldem hillshade -z 2 -s 1 /workspace/dem.tif /workspace/hillshade.tif\\n```\\n\\n```sh title=\\"등고선 생성\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_contour -a elevation -i 10 /workspace/dem.tif /workspace/contours.shp\\n```\\n\\n### 6. gdal_calc.py - 래스터 계산\\n\\n```sh title=\\"NDVI 계산 (밴드 4: NIR, 밴드 3: Red)\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_calc.py -A /workspace/multispectral.tif --A_band=4 \\\\\\n  -B /workspace/multispectral.tif --B_band=3 \\\\\\n  --outfile=/workspace/ndvi.tif --calc=\\"(A-B)/(A+B)\\"\\n```\\n\\n```sh title=\\"래스터 마스킹\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_calc.py -A /workspace/input.tif -B /workspace/mask.tif \\\\\\n  --outfile=/workspace/masked.tif --calc=\\"A*B\\"\\n```\\n\\n## 벡터 데이터 처리 (OGR)\\n\\n### 1. ogrinfo - 벡터 파일 정보 확인\\n\\n```sh title=\\"Shapefile 정보 확인\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  ogrinfo /workspace/boundaries.shp\\n```\\n\\n```sh title=\\"상세 정보와 속성 확인\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  ogrinfo -al -so /workspace/boundaries.shp\\n```\\n\\n### 2. ogr2ogr - 벡터 데이터 변환\\n\\n```sh title=\\"Shapefile을 GeoJSON으로 변환\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  ogr2ogr -f GeoJSON /workspace/output.geojson /workspace/input.shp\\n```\\n\\n```sh title=\\"좌표계 변환과 함께\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  ogr2ogr -f GeoJSON -t_srs EPSG:4326 \\\\\\n  /workspace/wgs84.geojson /workspace/input.shp\\n```\\n\\n```sh title=\\"속성 필터링\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  ogr2ogr -f GeoJSON -where \\"POPULATION > 100000\\" \\\\\\n  /workspace/large_cities.geojson /workspace/cities.shp\\n```\\n\\n## 실제 업무 시나리오\\n\\n### 시나리오 1: 위성영상 전처리 파이프라인\\n\\n```sh title=\\"1. 원본 영상 정보 확인\\"\\ndocker run -it --rm -v c:\\\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalinfo /data/landsat8_raw.tif\\n```\\n\\n```sh title=\\"2. 좌표계를 UTM으로 변환\\"\\ndocker run -it --rm -v c:\\\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -t_srs EPSG:32652 -r cubic \\\\\\n  /data/landsat8_raw.tif /data/landsat8_utm.tif\\n```\\n\\n```sh title=\\"3. RGB 밴드만 추출하여 압축\\"\\ndocker run -it --rm -v c:\\\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -b 4 -b 3 -b 2 -of GTiff -co COMPRESS=JPEG -co QUALITY=85 \\\\\\n  /data/landsat8_utm.tif /data/landsat8_rgb.tif\\n```\\n\\n### 시나리오 2: DEM 데이터 분석\\n\\n```sh title=\\"1. 여러 DEM 타일 병합\\"\\ndocker run -it --rm -v c:\\\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalbuildvrt /data/merged_dem.vrt /data/dem_*.tif\\n```\\n\\n```sh title=\\"2. 병합된 DEM을 단일 파일로 변환\\"\\ndocker run -it --rm -v c:\\\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -of GTiff -co COMPRESS=LZW \\\\\\n  /data/merged_dem.vrt /data/merged_dem.tif\\n```\\n\\n```sh title=\\"3. 경사도와 음영기복도 생성\\"\\ndocker run -it --rm -v c:\\\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdaldem slope /data/merged_dem.tif /data/slope.tif\\n\\ndocker run -it --rm -v c:\\\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdaldem hillshade -z 2 /data/merged_dem.tif /data/hillshade.tif\\n```\\n\\n### 시나리오 3: 배치 처리 스크립트\\n\\n```bash title=\\"Windows 배치 파일 (process_images.bat)\\"\\n@echo off\\nset IMAGE_NAME=ghcr.io/osgeo/gdal:alpine-small-3.9.0\\nset DATA_DIR=c:\\\\gis_data\\n\\necho 이미지 처리 시작...\\n\\nfor %%f in (%DATA_DIR%\\\\*.tif) do (\\n    echo 처리 중: %%f\\n    docker run --rm -v %DATA_DIR%:/data %IMAGE_NAME% ^\\n        gdal_translate -of GTiff -co COMPRESS=LZW \\"%%f\\" \\"/data/compressed_%%~nf.tif\\"\\n)\\n\\necho 처리 완료!\\n```\\n\\n## 성능 최적화 팁\\n\\n### 1. 메모리 설정\\n\\n```sh title=\\"메모리 캐시 크기 설정\\"\\ndocker run -it --rm -v c:\\\\data:/workspace \\\\\\n  -e GDAL_CACHEMAX=512 \\\\\\n  ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -wm 1024 /workspace/large_file.tif /workspace/output.tif\\n```\\n\\n### 2. 멀티스레딩 활용\\n\\n```sh title=\\"멀티스레드 처리\\"\\ndocker run -it --rm -v c:\\\\data:/workspace \\\\\\n  -e GDAL_NUM_THREADS=ALL_CPUS \\\\\\n  ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -multi /workspace/input.tif /workspace/output.tif\\n```\\n\\n### 3. 타일링 최적화\\n\\n```sh title=\\"타일 크기 최적화\\"\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=512 -co BLOCKYSIZE=512 \\\\\\n  /workspace/input.tif /workspace/tiled.tif\\n```\\n\\n## 문제 해결 가이드\\n\\n### 자주 발생하는 문제들\\n\\n#### 1. 권한 문제\\n\\n**문제**: 컨테이너에서 생성된 파일에 접근할 수 없음\\n\\n**해결책**: 사용자 ID 매핑 사용\\n```sh\\ndocker run -it --rm -v c:\\\\data:/workspace \\\\\\n  --user $(id -u):$(id -g) \\\\\\n  ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]\\n```\\n\\n#### 2. 메모리 부족\\n\\n**문제**: 대용량 파일 처리 시 메모리 부족\\n\\n**해결책**: \\n1. Docker 메모리 제한 증가\\n2. GDAL 캐시 크기 조정\\n3. 타일 단위 처리\\n\\n```sh\\ndocker run -it --rm -m 4g -v c:\\\\data:/workspace \\\\\\n  -e GDAL_CACHEMAX=1024 \\\\\\n  ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]\\n```\\n\\n#### 3. 좌표계 오류\\n\\n**문제**: 좌표계 정보가 없거나 잘못됨\\n\\n**해결책**: 명시적 좌표계 지정\\n```sh\\ndocker run -it --rm -v c:\\\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalwarp -s_srs EPSG:4326 -t_srs EPSG:3857 \\\\\\n  /workspace/input.tif /workspace/output.tif\\n```\\n\\n### 디버깅 팁\\n\\n```sh title=\\"상세 로그 출력\\"\\ndocker run -it --rm -v c:\\\\data:/workspace \\\\\\n  -e CPL_DEBUG=ON \\\\\\n  ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalinfo /workspace/problematic.tif\\n```\\n\\n```sh title=\\"지원되는 형식 확인\\"\\ndocker run -it --rm ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\\\\\n  gdalinfo --formats\\n```\\n\\n## 고급 활용법\\n\\n### 1. Docker Compose 활용\\n\\n```yaml title=\\"docker-compose.yml\\"\\nversion: \'3.8\'\\nservices:\\n  gdal:\\n    image: ghcr.io/osgeo/gdal:alpine-small-3.9.0\\n    volumes:\\n      - ./data:/workspace\\n    working_dir: /workspace\\n    environment:\\n      - GDAL_CACHEMAX=512\\n      - GDAL_NUM_THREADS=ALL_CPUS\\n    command: tail -f /dev/null  # 컨테이너 유지\\n```\\n\\n```sh title=\\"사용법\\"\\ndocker-compose up -d\\ndocker-compose exec gdal gdalinfo /workspace/sample.tif\\ndocker-compose down\\n```\\n\\n### 2. 별칭(Alias) 설정\\n\\n```bash title=\\"Linux/macOS (.bashrc 또는 .zshrc)\\"\\nalias dgdal=\'docker run -it --rm -v $(pwd):/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0\'\\nalias dgdalinfo=\'dgdal gdalinfo\'\\nalias dgdaltranslate=\'dgdal gdal_translate\'\\nalias dgdalwarp=\'dgdal gdalwarp\'\\n```\\n\\n```cmd title=\\"Windows (doskey 명령어)\\"\\ndoskey dgdal=docker run -it --rm -v %cd%:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 $*\\ndoskey dgdalinfo=dgdal gdalinfo $*\\n```\\n\\n### 3. 사용자 정의 이미지 생성\\n\\n```dockerfile title=\\"Dockerfile\\"\\nFROM ghcr.io/osgeo/gdal:alpine-small-3.9.0\\n\\n# 추가 패키지 설치\\nRUN apk add --no-cache python3 py3-pip\\n\\n# Python 라이브러리 설치\\nRUN pip3 install numpy rasterio\\n\\n# 작업 디렉토리 설정\\nWORKDIR /workspace\\n\\n# 사용자 정의 스크립트 복사\\nCOPY scripts/ /usr/local/bin/\\n\\n# 실행 권한 부여\\nRUN chmod +x /usr/local/bin/*\\n```\\n\\n## 결론\\n\\nDocker GDAL 사용의 핵심 장점:\\n- **설치 간소화**: 복잡한 컴파일 과정 생략\\n- **환경 독립성**: 시스템 설정에 영향 없음\\n- **일관된 결과**: 운영체제 무관하게 동일한 실행 환경\\n- **즉시 사용**: 몇 분 만에 GDAL 활용 가능\\n- **확장성**: 필요에 따라 사용자 정의 이미지 생성 가능\\n\\nDocker를 활용하면 GDAL 설치의 복잡함을 해결하고 지리공간 데이터 처리에 집중할 수 있습니다. 이 글에서 소개한 다양한 예제와 팁들을 활용하여 효율적인 GIS 워크플로우를 구축해보세요.\\n\\n## 참고 자료\\n\\n- [GDAL 공식 문서](https://gdal.org/programs/index.html)\\n- [GitHub Container Registry - osgeo/gdal](https://github.com/orgs/OSGeo/packages/container/gdal)\\n- [GDAL Docker 이미지 소스코드](https://github.com/OSGeo/gdal/tree/master/docker)\\n- [Alpine Linux 공식 사이트](https://alpinelinux.org/)\\n- [Docker 공식 문서](https://docs.docker.com/)\\n- [OGR 벡터 드라이버 목록](https://gdal.org/drivers/vector/index.html)\\n- [GDAL 래스터 드라이버 목록](https://gdal.org/drivers/raster/index.html)"},{"id":"csharp-thread-parallel-foreach-cancellation","metadata":{"permalink":"/blog/csharp-thread-parallel-foreach-cancellation","source":"@site/blog/2017-01-09-post/index.md","title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","description":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2017-01-09T00:00:00.000Z","tags":[{"inline":true,"label":"dotnet","permalink":"/blog/tags/dotnet"},{"inline":true,"label":"csharp","permalink":"/blog/tags/csharp"},{"inline":true,"label":"threading","permalink":"/blog/tags/threading"},{"inline":true,"label":"parallel","permalink":"/blog/tags/parallel"}],"readingTime":1.91,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2017-01-09","description":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","authors":["jypark"],"tags":["dotnet","csharp","threading","parallel"],"image":"csharp.webp","slug":"csharp-thread-parallel-foreach-cancellation","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Docker로 GDAL 간편하게 사용하기","permalink":"/blog/docker-gdal-geospatial-data-processing"}},"content":"GUI 환경에서 버튼을 클릭하는 등의 이벤트로 시간이 오래 걸리는 작업을 구동하는 경우 스레드를 분리하여 개발하는 방법이 좋다는 방법은 C# 뿐만 아니라 안드로이드나 MFC 등 GUI를 어느 정도 개발한 사람이라면 익숙하리라 생각한다.\\n\\n그렇다면 그 시간이 오래 걸리는 작업을 더욱더 빠르게 하고 싶다면 병렬 처리가 가장 쉽고 빨리 적용할 수 있는 합리적인 방법이라고 생각한다.\\n\\n> **TL;DR**: Thread.Abort()는 위험하므로 사용하지 마세요.\\n\\n\x3c!-- truncate --\x3e\\n\\n이 글에서는 Thread 내부의 Parallel.ForEach 작업을 안전하게 중단하는 방법과 현대적인 비동기 패턴을 소개합니다.\\n\\n:::danger[Thread.Abort() 사용 금지]\\n\\n**중요**: 이 글의 원본 코드는 2017년에 작성되었으며, `Thread.Abort()` 사용을 포함하고 있습니다.\\n\\n이 방법은 현재 **권장되지 않으며**, .NET Core/.NET 5+ 에서는 **지원되지 않습니다**.\\n\\n:::\\n\\n:::info\\n\\n이 글의 최신버전은 [https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-safe-cancellation](https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-safe-cancellation)입니다.\\n\\n:::\\n\\n구글링을 통하여 어찌어찌 병렬 For 문을 적용하였지만, 문제는 \\"클라이언트가 구동은 했지만 오래 걸리는 프로세스를 작업 도중에 중단하고 싶다\\"라고 말했을 때 발생하였다.\\n\\n다음은 몇 가지 코드를 조합하여 만든 메인 스레드와 분리된 다중 포문 작업 클래스와 그 작업을 중단시키는 예를 콘솔 응용프로그램으로 구성하였다.\\n[^1]\\n\\n[^1]: http://www.albahari.com/threading/part3.aspx\\n\\n### 메인 클래스 및 중단 클래스\\n\\n```csharp\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading;\\nusing System.Threading.Tasks;\\n\\nnamespace ThreadTest\\n{\\nclass Program\\n{\\nstatic void Main(string[] args)\\n{\\nConsole.WriteLine(\\"press any key for Thread start!\\");\\nConsole.ReadKey();\\n\\n            RulyCanceler canceler = new RulyCanceler();\\n            TestFilter tf = new TestFilter(10000000);\\n\\n            Thread t = new Thread(() =>\\n            {\\n                try\\n                {\\n                    tf.execute(canceler);\\n                }catch(OperationCanceledException)\\n                {\\n                    Console.WriteLine(\\"Canceled!\\");\\n                }\\n            });\\n            t.Start();\\n            Console.ReadKey();\\n            Console.WriteLine(\\"Abort!\\");\\n\\n            canceler.Cancel();\\n            t.Abort();\\n            t.Join();\\n\\n            Console.WriteLine(\\"Aborted!\\");\\n            Console.ReadKey();\\n\\n        }\\n    }\\n    public class RulyCanceler\\n    {\\n        object _cancelLocker = new object();\\n        bool _cancelRequest;\\n        public bool IsCancellationRequested\\n        {\\n            get { lock (_cancelLocker) return _cancelRequest; }\\n        }\\n\\n        public void Cancel() { lock (_cancelLocker) _cancelRequest = true; }\\n\\n        public void ThrowIfCancellationRequested()\\n        {\\n            if (IsCancellationRequested) throw new OperationCanceledException();\\n        }\\n    }\\n\\n}\\n```\\n\\n### 시간이 오래걸리는 작업 클래스\\n\\n```csharp\\nusing System;\\nusing System.Collections.Concurrent;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading;\\nusing System.Threading.Tasks;\\n\\nnamespace ThreadTest\\n{\\npublic class TestFilter\\n{\\nprivate long featureCount;\\nprivate int MULTI_THREAD_COUNT = 10;\\n\\n        EventWaitHandle waitEvent = new EventWaitHandle(true, EventResetMode.AutoReset, \\"SHARED_BY_ALL_PROCESSES\\");\\n        public TestFilter(long featurecount)\\n        {\\n            this.featureCount = featurecount;\\n        }\\n\\n        public void execute(RulyCanceler cancer)\\n        {\\n            int workingRangeSize = 1;\\n            if (featureCount > 100)\\n            {\\n                workingRangeSize = (int)(featureCount / MULTI_THREAD_COUNT);\\n            }\\n            var part = Partitioner.Create(0, featureCount, workingRangeSize);\\n            Parallel.ForEach(part, (num, state) =>\\n            {\\n                for (long featureIdx = num.Item1, cnt = num.Item2; featureIdx < cnt; featureIdx++)\\n                {\\n                    try\\n                    {\\n\\n                        //waitEvent.WaitOne();(파일 쓰기모드일 경우 하나의 스레드만 쓸수 있도록 줄세우기)\\n                        //waitEvent.Set();\\n\\n                        // 중단 요청이있으면 Throw\\n                        cancer.ThrowIfCancellationRequested();\\n\\n                        // 실제 일\\n                        Console.WriteLine(String.Format(\\"{0} - {1}\\", num.Item1, featureIdx));\\n                    }\\n                    catch (OperationCanceledException ex)\\n                    {\\n                        Console.WriteLine(\\"Breaked.\\");\\n                        Console.WriteLine(\\"Clean\\");\\n                        state.Break();\\n                        break;\\n\\n                    }\\n                }\\n            });\\n        }\\n    }\\n\\n}\\n```"}]}}')}}]);