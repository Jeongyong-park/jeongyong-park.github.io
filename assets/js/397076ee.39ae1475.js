"use strict";(self.webpackChunkjeongyong_park_github_io=self.webpackChunkjeongyong_park_github_io||[]).push([[9347],{5482:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>{},default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>i});var a=t(6840),r=t(4848),l=t(8453);let o={title:"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법",date:"2017-01-09",description:"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법",authors:["jypark"],tags:["dotnet","csharp","threading","parallel"],image:"csharp.png",slug:"csharp-thread-parallel-foreach-cancellation",hide_table_of_contents:!1},s={authorsImageUrls:[void 0]},i=[{value:"메인 클래스 및 중단 클래스",id:"메인-클래스-및-중단-클래스",level:3},{value:"시간이 오래걸리는 작업 클래스",id:"시간이-오래걸리는-작업-클래스",level:3}];function c(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"GUI 환경에서 버튼을 클릭하는 등의 이벤트로 시간이 오래 걸리는 작업을 구동하는 경우 스레드를 분리하여 개발하는 방법이 좋다는 방법은 C# 뿐만 아니라 안드로이드나 MFC 등 GUI를 어느 정도 개발한 사람이라면 익숙하리라 생각한다."}),"\n",(0,r.jsx)(n.p,{children:"그렇다면 그 시간이 오래 걸리는 작업을 더욱더 빠르게 하고 싶다면 병렬 처리가 가장 쉽고 빨리 적용할 수 있는 합리적인 방법이라고 생각한다."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TL;DR"}),": Thread.Abort()는 위험하므로 사용하지 마세요."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"이 글에서는 Thread 내부의 Parallel.ForEach 작업을 안전하게 중단하는 방법과 현대적인 비동기 패턴을 소개합니다."}),"\n",(0,r.jsxs)(n.admonition,{title:"Thread.Abort() 사용 금지",type:"danger",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"중요"}),": 이 글의 원본 코드는 2017년에 작성되었으며, ",(0,r.jsx)(n.code,{children:"Thread.Abort()"})," 사용을 포함하고 있습니다."]}),(0,r.jsxs)(n.p,{children:["이 방법은 현재 ",(0,r.jsx)(n.strong,{children:"권장되지 않으며"}),", .NET Core/.NET 5+ 에서는 ",(0,r.jsx)(n.strong,{children:"지원되지 않습니다"}),"."]})]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["이 글의 최신버전은 ",(0,r.jsx)(n.a,{href:"https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-safe-cancellation",children:"https://jypark.pe.kr/blog/csharp-thread-parallel-foreach-safe-cancellation"}),"입니다."]})}),"\n",(0,r.jsx)(n.p,{children:'구글링을 통하여 어찌어찌 병렬 For 문을 적용하였지만, 문제는 "클라이언트가 구동은 했지만 오래 걸리는 프로세스를 작업 도중에 중단하고 싶다"라고 말했을 때 발생하였다.'}),"\n",(0,r.jsxs)(n.p,{children:["다음은 몇 가지 코드를 조합하여 만든 메인 스레드와 분리된 다중 포문 작업 클래스와 그 작업을 중단시키는 예를 콘솔 응용프로그램으로 구성하였다.\n",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-1-afd254",id:"user-content-fnref-1-afd254","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,r.jsx)(n.h3,{id:"메인-클래스-및-중단-클래스",children:"메인 클래스 및 중단 클래스"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ThreadTest\n{\nclass Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine("press any key for Thread start!");\nConsole.ReadKey();\n\n            RulyCanceler canceler = new RulyCanceler();\n            TestFilter tf = new TestFilter(10000000);\n\n            Thread t = new Thread(() =>\n            {\n                try\n                {\n                    tf.execute(canceler);\n                }catch(OperationCanceledException)\n                {\n                    Console.WriteLine("Canceled!");\n                }\n            });\n            t.Start();\n            Console.ReadKey();\n            Console.WriteLine("Abort!");\n\n            canceler.Cancel();\n            t.Abort();\n            t.Join();\n\n            Console.WriteLine("Aborted!");\n            Console.ReadKey();\n\n        }\n    }\n    public class RulyCanceler\n    {\n        object _cancelLocker = new object();\n        bool _cancelRequest;\n        public bool IsCancellationRequested\n        {\n            get { lock (_cancelLocker) return _cancelRequest; }\n        }\n\n        public void Cancel() { lock (_cancelLocker) _cancelRequest = true; }\n\n        public void ThrowIfCancellationRequested()\n        {\n            if (IsCancellationRequested) throw new OperationCanceledException();\n        }\n    }\n\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"시간이-오래걸리는-작업-클래스",children:"시간이 오래걸리는 작업 클래스"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ThreadTest\n{\npublic class TestFilter\n{\nprivate long featureCount;\nprivate int MULTI_THREAD_COUNT = 10;\n\n        EventWaitHandle waitEvent = new EventWaitHandle(true, EventResetMode.AutoReset, "SHARED_BY_ALL_PROCESSES");\n        public TestFilter(long featurecount)\n        {\n            this.featureCount = featurecount;\n        }\n\n        public void execute(RulyCanceler cancer)\n        {\n            int workingRangeSize = 1;\n            if (featureCount > 100)\n            {\n                workingRangeSize = (int)(featureCount / MULTI_THREAD_COUNT);\n            }\n            var part = Partitioner.Create(0, featureCount, workingRangeSize);\n            Parallel.ForEach(part, (num, state) =>\n            {\n                for (long featureIdx = num.Item1, cnt = num.Item2; featureIdx < cnt; featureIdx++)\n                {\n                    try\n                    {\n\n                        //waitEvent.WaitOne();(파일 쓰기모드일 경우 하나의 스레드만 쓸수 있도록 줄세우기)\n                        //waitEvent.Set();\n\n                        // 중단 요청이있으면 Throw\n                        cancer.ThrowIfCancellationRequested();\n\n                        // 실제 일\n                        Console.WriteLine(String.Format("{0} - {1}", num.Item1, featureIdx));\n                    }\n                    catch (OperationCanceledException ex)\n                    {\n                        Console.WriteLine("Breaked.");\n                        Console.WriteLine("Clean");\n                        state.Break();\n                        break;\n\n                    }\n                }\n            });\n        }\n    }\n\n}\n'})}),"\n","\n",(0,r.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{id:"user-content-fn-1-afd254",children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"http://www.albahari.com/threading/part3.aspx",children:"http://www.albahari.com/threading/part3.aspx"})," ",(0,r.jsx)(n.a,{href:"#user-content-fnref-1-afd254","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"↩"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){let{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},6840:e=>{e.exports=JSON.parse('{"permalink":"/blog/csharp-thread-parallel-foreach-cancellation","source":"@site/blog/2017-01-09-post/index.md","title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","description":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2017-01-09T00:00:00.000Z","tags":[{"inline":true,"label":"dotnet","permalink":"/blog/tags/dotnet"},{"inline":true,"label":"csharp","permalink":"/blog/tags/csharp"},{"inline":true,"label":"threading","permalink":"/blog/tags/threading"},{"inline":true,"label":"parallel","permalink":"/blog/tags/parallel"}],"readingTime":1.91,"hasTruncateMarker":true,"authors":[{"name":"Jeongyong Park","title":"쌍팔년생 개발자","url":"https://github.com/jeongyong-park","email":"kladess@gmail.com","socials":{"x":"https://x.com/chisquare88","github":"https://github.com/jeongyong-park"},"imageURL":"/img/avatar.webp","key":"jypark","page":null}],"frontMatter":{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","date":"2017-01-09","description":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","authors":["jypark"],"tags":["dotnet","csharp","threading","parallel"],"image":"csharp.png","slug":"csharp-thread-parallel-foreach-cancellation","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Docker로 GDAL 간편하게 사용하기","permalink":"/blog/docker-gdal-geospatial-data-processing"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(6540);let r={},l=a.createContext(r);function o(e){let n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);