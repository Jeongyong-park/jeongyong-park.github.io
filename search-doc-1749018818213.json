{"searchDocs":[{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","type":0,"sectionRef":"#","url":"/blog/csharp-thread-parallel-foreach-cancellation","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"메인 클래스 및 중단 클래스​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-cancellation#메인-클래스-및-중단-클래스","content":" using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ThreadTest { class Program { static void Main(string[] args) { Console.WriteLine(&quot;press any key for Thread start!&quot;); Console.ReadKey(); RulyCanceler canceler = new RulyCanceler(); TestFilter tf = new TestFilter(10000000); Thread t = new Thread(() =&gt; { try { tf.execute(canceler); }catch(OperationCanceledException) { Console.WriteLine(&quot;Canceled!&quot;); } }); t.Start(); Console.ReadKey(); Console.WriteLine(&quot;Abort!&quot;); canceler.Cancel(); t.Abort(); t.Join(); Console.WriteLine(&quot;Aborted!&quot;); Console.ReadKey(); } } public class RulyCanceler { object _cancelLocker = new object(); bool _cancelRequest; public bool IsCancellationRequested { get { lock (_cancelLocker) return _cancelRequest; } } public void Cancel() { lock (_cancelLocker) _cancelRequest = true; } public void ThrowIfCancellationRequested() { if (IsCancellationRequested) throw new OperationCanceledException(); } } }   ","version":null,"tagName":"h3"},{"title":"시간이 오래걸리는 작업 클래스​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-cancellation#시간이-오래걸리는-작업-클래스","content":" using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ThreadTest { public class TestFilter { private long featureCount; private int MULTI_THREAD_COUNT = 10; EventWaitHandle waitEvent = new EventWaitHandle(true, EventResetMode.AutoReset, &quot;SHARED_BY_ALL_PROCESSES&quot;); public TestFilter(long featurecount) { this.featureCount = featurecount; } public void execute(RulyCanceler cancer) { int workingRangeSize = 1; if (featureCount &gt; 100) { workingRangeSize = (int)(featureCount / MULTI_THREAD_COUNT); } var part = Partitioner.Create(0, featureCount, workingRangeSize); Parallel.ForEach(part, (num, state) =&gt; { for (long featureIdx = num.Item1, cnt = num.Item2; featureIdx &lt; cnt; featureIdx++) { try { //waitEvent.WaitOne();(파일 쓰기모드일 경우 하나의 스레드만 쓸수 있도록 줄세우기) //waitEvent.Set(); // 중단 요청이있으면 Throw cancer.ThrowIfCancellationRequested(); // 실제 일 Console.WriteLine(String.Format(&quot;{0} - {1}&quot;, num.Item1, featureIdx)); } catch (OperationCanceledException ex) { Console.WriteLine(&quot;Breaked.&quot;); Console.WriteLine(&quot;Clean&quot;); state.Break(); break; } } }); } } }     Footnotes​ http://www.albahari.com/threading/part3.aspx ↩ ","version":null,"tagName":"h3"},{"title":"DiffX: 확장 가능한 차세대 Diff 형식","type":0,"sectionRef":"#","url":"/blog/diffx-next-generation-extensible-diff-format","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"현재 Diff 형식들의 모습​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#현재-diff-형식들의-모습","content":" 대부분의 사람과 도구는 Unified Diff를 사용합니다. 다음과 같은 형태들이죠:  --- readme 2016-01-26 16:29:12.000000000 -0800 +++ readme 2016-01-31 11:54:32.000000000 -0800 @@ -1 +1,3 @@ Hello there + +Oh hi!   Git diff:  diff --git a/readme b/readme index d6613f5..5b50866 100644 --- a/readme +++ b/readme @@ -1 +1,3 @@ Hello there + +Oh hi!   SVN diff:  Index: readme =================================================================== --- (revision 123) +++ (working copy) Property changes on: . ------------------------------------------------------------------- Modified: myproperty ## -1 +1 ## -old value +new value   ","version":null,"tagName":"h2"},{"title":"기존 Diff의 근본적 문제점​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#기존-diff의-근본적-문제점","content":" ","version":null,"tagName":"h2"},{"title":"1. 표준화 부족​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#1-표준화-부족","content":" Unified Diff는 diff의 일부만 표준화합니다:  ---/+++ 라인 (파일 식별용)@@ ... @@ 라인 (hunk 오프셋/크기)-/+ (삭제/추가된 라인)  &quot;Unified format은 가장 널리 사용되는 diff 형식이지만, 표준화되지 않은 메타데이터 처리로 인해 도구 간 호환성 문제가 지속적으로 발생하고 있습니다.&quot; - DiffX 문제점 분석 문서1  하지만 다음은 표준화되지 않았습니다:  인코딩리비전 정보메타데이터파일명이나 경로 표현 방식  ","version":null,"tagName":"h3"},{"title":"2. 현대적 요구사항 미충족​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#2-현대적-요구사항-미충족","content":" 단일 diff에 여러 커밋 표현 불가바이너리 패치 표준 형식 없음텍스트 인코딩 정보 없음 (생각보다 큰 문제)메타데이터를 위한 표준 형식 없음 (각자 다른 방식으로 구현)  ","version":null,"tagName":"h3"},{"title":"3. 파싱의 어려움​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#3-파싱의-어려움","content":" 패치 도구, 코드 리뷰 도구, 코드 분석 도구들이 다양한 소스 컨트롤 시스템의 diff를 안정적으로 파싱하기 매우 어렵습니다. 변경된 라인 외의 유용한 정보를 추출하는 것은 더욱 어렵죠.  GNU Patch가 처리해야 하는 복잡성을 보면 이 문제의 심각성을 알 수 있습니다2.  ","version":null,"tagName":"h3"},{"title":"DiffX: 해결책​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx-해결책","content":" DiffX(Extensible Diffs)는 이러한 문제들을 해결하기 위해 설계된 새로운 형식입니다3. 기존 도구와 완전히 호환되면서도 미래 지향적이고 사람이 읽을 수 있는 형태를 유지합니다.  ","version":null,"tagName":"h2"},{"title":"DiffX 파일 예시​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx-파일-예시","content":" 다음은 DiffX 공식 문서에서 제공하는 실제 예시입니다3:  #diffx: encoding=utf-8, version=1.0 #.change: #..preamble: indent=4, length=319, mimetype=text/markdown Convert legacy header building code to Python 3. Header building for messages used old Python 2.6-era list comprehensions with tuples rather than modern dictionary comprehensions in order to build a message list. This change modernizes that, and swaps out six for a 3-friendly `.items()` call. #..meta: format=json, length=270 { &quot;author&quot;: &quot;Christian Hammond &lt;christian@example.com&gt;&quot;, &quot;committer&quot;: &quot;Christian Hammond &lt;christian@example.com&gt;&quot;, &quot;committer date&quot;: &quot;2021-06-02T13:12:06-07:00&quot;, &quot;date&quot;: &quot;2021-06-01T19:26:31-07:00&quot;, &quot;id&quot;: &quot;a25e7b28af5e3184946068f432122c68c1a30b23&quot; } #..file: #...meta: format=json, length=176 { &quot;path&quot;: &quot;/src/message.py&quot;, &quot;revision&quot;: { &quot;new&quot;: &quot;f814cf74766ba3e6d175254996072233ca18a690&quot;, &quot;old&quot;: &quot;9f6a412b3aee0a55808928b43f848202b4ee0f8d&quot; } } #...diff: length=629 --- /src/message.py +++ /src/message.py @@ -164,10 +164,10 @@ not isinstance(headers, MultiValueDict)): # Instantiating a MultiValueDict from a dict does not ensure that # values are lists, so we have to ensure that ourselves. - headers = MultiValueDict(dict( - (key, [value]) - for key, value in six.iteritems(headers) - )) + headers = MultiValueDict({ + key: [value] + for key, value in headers.items() + }) if in_reply_to: headers['In-Reply-To'] = in_reply_to   ","version":null,"tagName":"h3"},{"title":"DiffX의 주요 특징​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx의-주요-특징","content":" ","version":null,"tagName":"h2"},{"title":"1. 구조화된 메타데이터​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#1-구조화된-메타데이터","content":" diff와 각 커밋, 파일에 대한 메타데이터를 표준화된 방식으로 저장JSON 형식으로 구조화된 정보 제공  ","version":null,"tagName":"h3"},{"title":"2. 다중 커밋 지원​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#2-다중-커밋-지원","content":" 하나의 diff 파일에 여러 커밋 표현 가능복잡한 변경사항의 히스토리 보존  ","version":null,"tagName":"h3"},{"title":"3. 바이너리 지원​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#3-바이너리-지원","content":" Git 호환 바이너리 콘텐츠 diff 지원이미지, 실행파일 등의 변경사항도 처리  ","version":null,"tagName":"h3"},{"title":"4. 인코딩 인식​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#4-인코딩-인식","content":" 파일과 diff 메타데이터의 텍스트 인코딩 정보 포함다국어 프로젝트에서 중요한 기능  ","version":null,"tagName":"h3"},{"title":"5. 완전한 호환성​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#5-완전한-호환성","content":" 기존 파서와 패처에서 모든 표준 diff 기능 동작새로운 기능은 추가 도구 지원 필요하지만 파싱은 가능  ","version":null,"tagName":"h3"},{"title":"6. 확장성​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#6-확장성","content":" 기존 파서를 깨뜨리지 않고 형식 확장 가능미래의 요구사항에 대비  ","version":null,"tagName":"h3"},{"title":"7. 변경 가능성​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#7-변경-가능성","content":" 도구가 diff를 쉽게 열고, 새 데이터를 기록하고, 다시 저장 가능메타데이터 수정과 업데이트가 간단  ","version":null,"tagName":"h3"},{"title":"DiffX가 제공하는 것​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx가-제공하는-것","content":" ","version":null,"tagName":"h2"},{"title":"✅ 포함되는 기능​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#-포함되는-기능","content":" diff 파싱을 위한 표준화된 규칙diff, 커밋, 파일별 메타데이터의 공식적 저장 및 명명기존 파서를 깨뜨리지 않는 형식 확장 능력하나의 diff 파일에 다중 커밋 표현Git 호환 바이너리 콘텐츠 diff파일과 diff 메타데이터의 텍스트 인코딩 정보모든 기존 파서 및 패처와의 호환성diff 내용의 변경 및 수정 가능성  ","version":null,"tagName":"h3"},{"title":"❌ DiffX의 목표가 아닌 것​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#-diffx의-목표가-아닌-것","content":" 모든 도구가 새로운 파일 형식을 지원하도록 강제기존 diff를 새 도구에서 깨뜨리거나 도구 재작성 요구벤더 락인 생성  호환성 주의사항 DiffX의 새로운 기능들은 해당 기능을 지원하는 도구에서만 완전히 활용할 수 있습니다. 하지만 기본적인 diff 기능은 모든 기존 도구에서 정상 동작합니다3.  ","version":null,"tagName":"h3"},{"title":"현재 상황과 향후 계획​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#현재-상황과-향후-계획","content":" ","version":null,"tagName":"h2"},{"title":"구현체​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#구현체","content":" Python: pydiffx - 공식 Python 구현체4  ","version":null,"tagName":"h3"},{"title":"사용 중인 제품​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#사용-중인-제품","content":" Review Board (Beanbag): DiffX로 기존 diff 관련 문제들을 해결하고 모든 제품에 지원 추가 예정5  ","version":null,"tagName":"h3"},{"title":"개발 현황​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#개발-현황","content":" 현재 DiffX는 활발히 개발되고 있는 오픈소스 프로젝트입니다. Beanbag에서 주도하고 있으며, Review Board의 실제 운영 환경에서 검증되고 있습니다.  ","version":null,"tagName":"h3"},{"title":"참고 자료​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#참고-자료","content":" ","version":null,"tagName":"h2"},{"title":"공식 문서​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#공식-문서","content":" DiffX 공식 웹사이트 - 프로젝트 홈페이지DiffX 파일 형식 사양서 - 기술 사양 상세 문서DiffX 예제 파일들 - 실제 사용 예시FAQ - 자주 묻는 질문  ","version":null,"tagName":"h3"},{"title":"배경 자료​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#배경-자료","content":" Diff의 문제점 상세 분석 - 기존 diff 형식의 문제점GNU diff 문서 - 전통적인 diff 도구Git diff 형식 문서 - Git diff 형식 설명  ","version":null,"tagName":"h3"},{"title":"관련 프로젝트​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#관련-프로젝트","content":" Review Board - 코드 리뷰 도구Beanbag, Inc. - DiffX 개발사  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#결론","content":" DiffX는 현대적 소프트웨어 개발의 요구사항을 충족하면서도 기존 생태계와의 호환성을 유지하는 차세대 diff 형식입니다. 구조화된 메타데이터, 다중 커밋 지원, 바이너리 처리 등의 기능을 통해 개발 도구들이 더 풍부한 정보를 활용할 수 있게 해줍니다.  기존 Unified Diff의 관용적 특성을 활용하여 점진적 채택이 가능하며, 도구 개발자와 사용자 모두에게 이익을 제공하는 실용적인 해결책입니다.    ","version":null,"tagName":"h2"},{"title":"각주​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#각주","content":"   Footnotes​ The Problems with Diffs - https://diffx.org/problems/ ↩ GNU diff utilities - https://www.gnu.org/software/diffutils/ ↩ DiffX 공식 사양서 - https://diffx.org/spec/ ↩ ↩2 ↩3 pydiffx GitHub 저장소 - https://github.com/beanbaginc/pydiffx ↩ Review Board 공식 웹사이트 - https://www.reviewboard.org/ ↩ ","version":null,"tagName":"h2"},{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","type":0,"sectionRef":"#","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"Thread.Abort()를 사용하면 안 되는 이유​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#threadabort를-사용하면-안-되는-이유","content":" Thread.Abort()는 여러 심각한 문제를 야기할 수 있습니다:  .NET 5 이상에서 지원 중단: 더 이상 사용할 수 없는 방법입니다리소스 누수: 파일 핸들, 데이터베이스 연결 등이 제대로 해제되지 않을 수 있습니다데이터 손상: 작업 중간에 강제 종료되어 일관성이 깨질 수 있습니다예측 불가능한 동작: ThreadAbortException이 예상치 못한 곳에서 발생할 수 있습니다  Thread.Abort() 사용 금지 Thread.Abort()는 .NET 5 이상에서 지원되지 않으며, 이전 버전에서도 안전하지 않습니다. 절대 사용하지 마세요.  ","version":null,"tagName":"h2"},{"title":"Thread 안전하게 중단하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#thread-안전하게-중단하기","content":" ","version":null,"tagName":"h2"},{"title":"1. 플래그 패턴 사용​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#1-플래그-패턴-사용","content":" 가장 간단한 방법은 boolean 플래그를 사용하는 것입니다:  플래그 패턴을 사용한 Thread 중단 public class SafeThread { private volatile bool _stopRequested = false; private Thread _thread; public void Start() { _thread = new Thread(DoWork); _thread.Start(); } public void Stop() { _stopRequested = true; _thread?.Join(); // 스레드가 완전히 종료될 때까지 대기 } private void DoWork() { while (!_stopRequested) { // 실제 작업 수행 ProcessItem(); // 주기적으로 중단 요청 확인 if (_stopRequested) break; Thread.Sleep(100); // 예시: 100ms 대기 } Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } private void ProcessItem() { // 실제 작업 로직 Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h3"},{"title":"2. CancellationToken 사용 (권장)​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#2-cancellationtoken-사용-권장","content":" .NET의 표준 취소 패턴인 CancellationToken을 사용하는 방법입니다 (.NET Framework 4.0 이상):  CancellationToken을 사용한 Thread 중단 public class CancellableThread { private Thread _thread; private CancellationTokenSource _cancellationTokenSource; public void Start() { _cancellationTokenSource = new CancellationTokenSource(); _thread = new Thread(() =&gt; DoWork(_cancellationTokenSource.Token)); _thread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _thread?.Join(); _cancellationTokenSource?.Dispose(); } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { ProcessItem(); // 취소 요청 확인 및 예외 발생 cancellationToken.ThrowIfCancellationRequested(); // 취소 가능한 대기 (.NET Framework 4.8에서는 Thread.Sleep 사용) if (cancellationToken.WaitHandle.WaitOne(100)) { break; // 취소 요청됨 } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } } private void ProcessItem() { Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h3"},{"title":"Parallel.ForEach 안전하게 중단하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#parallelforeach-안전하게-중단하기","content":" Parallel.ForEach는 ParallelOptions를 통해 CancellationToken을 지원합니다 (.NET Framework 4.0 이상):  CancellationToken을 사용한 Parallel.ForEach 중단 public class ParallelProcessor { public async Task ProcessItemsAsync(IEnumerable&lt;int&gt; items) { var cancellationTokenSource = new CancellationTokenSource(); // 5초 후 자동 취소 (예시) cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(5)); var parallelOptions = new ParallelOptions { CancellationToken = cancellationTokenSource.Token, MaxDegreeOfParallelism = Environment.ProcessorCount }; try { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { // 각 반복에서 취소 요청 확인 parallelOptions.CancellationToken.ThrowIfCancellationRequested(); ProcessSingleItem(item, parallelOptions.CancellationToken); }); Console.WriteLine(&quot;모든 작업이 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;병렬 작업이 취소되었습니다.&quot;); } finally { cancellationTokenSource.Dispose(); } } private void ProcessSingleItem(int item, CancellationToken cancellationToken) { // 긴 작업 시뮬레이션 for (int i = 0; i &lt; 10; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); // 실제 작업 시뮬레이션 Console.WriteLine($&quot;Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } } }   ","version":null,"tagName":"h2"},{"title":"외부에서 수동으로 취소하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#외부에서-수동으로-취소하기","content":" 사용자 입력이나 다른 조건에 따라 수동으로 취소하는 예시입니다:  수동 취소가 가능한 병렬 처리 public class ManualCancellationExample { private CancellationTokenSource _cancellationTokenSource; public async Task StartProcessingAsync() { _cancellationTokenSource = new CancellationTokenSource(); var items = Enumerable.Range(1, 1000); var parallelOptions = new ParallelOptions { CancellationToken = _cancellationTokenSource.Token, MaxDegreeOfParallelism = 4 }; try { await Task.Run(() =&gt; { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); // 무거운 작업 시뮬레이션 Thread.Sleep(200); Console.WriteLine($&quot;처리 완료: {item}&quot;); }); }); } catch (OperationCanceledException) { Console.WriteLine(&quot;사용자에 의해 작업이 취소되었습니다.&quot;); } } public void CancelProcessing() { _cancellationTokenSource?.Cancel(); Console.WriteLine(&quot;취소 요청이 전송되었습니다.&quot;); } } // 사용 예시 class Program { static async Task Main(string[] args) { var processor = new ManualCancellationExample(); // 백그라운드에서 처리 시작 var processingTask = processor.StartProcessingAsync(); Console.WriteLine(&quot;Enter 키를 누르면 작업을 취소합니다...&quot;); Console.ReadLine(); // 사용자 입력으로 취소 processor.CancelProcessing(); await processingTask; Console.WriteLine(&quot;프로그램이 종료되었습니다.&quot;); } }   ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8 호환 버전​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48-호환-버전","content":" .NET Framework 4.8에서는 일부 최신 API가 없어서 약간 다른 접근이 필요합니다:  .NET Framework 4.8 호환 CancellationToken 사용 public class NetFramework48Thread { private Thread _thread; private CancellationTokenSource _cancellationTokenSource; public void Start() { _cancellationTokenSource = new CancellationTokenSource(); _thread = new Thread(() =&gt; DoWork(_cancellationTokenSource.Token)); _thread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _thread?.Join(); _cancellationTokenSource?.Dispose(); } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { ProcessItem(); // 취소 요청 확인 cancellationToken.ThrowIfCancellationRequested(); // .NET Framework 4.8에서 취소 가능한 대기 // Task.Delay 대신 WaitHandle 사용 if (cancellationToken.WaitHandle.WaitOne(100)) { break; // 취소 요청됨 } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } } private void ProcessItem() { Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h2"},{"title":".NET Framework 4.8에서 Parallel.ForEach 사용​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48에서-parallelforeach-사용","content":" .NET Framework 4.8 Parallel.ForEach 예제 public class NetFramework48ParallelProcessor { public void ProcessItems(IEnumerable&lt;int&gt; items) { var cancellationTokenSource = new CancellationTokenSource(); // 5초 후 자동 취소 var timer = new System.Threading.Timer(_ =&gt; cancellationTokenSource.Cancel(), null, 5000, Timeout.Infinite); var parallelOptions = new ParallelOptions { CancellationToken = cancellationTokenSource.Token, MaxDegreeOfParallelism = Environment.ProcessorCount }; try { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); ProcessSingleItem(item, parallelOptions.CancellationToken); }); Console.WriteLine(&quot;모든 작업이 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;병렬 작업이 취소되었습니다.&quot;); } finally { timer?.Dispose(); cancellationTokenSource.Dispose(); } } private void ProcessSingleItem(int item, CancellationToken cancellationToken) { for (int i = 0; i &lt; 10; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); Console.WriteLine($&quot;Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } } }   ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8에서 Task 기반 접근​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48에서-task-기반-접근","content":" .NET Framework 4.8에서는 Task를 사용한 접근도 가능합니다:  .NET Framework 4.8 Task 기반 처리 public class NetFramework48TaskProcessor { private CancellationTokenSource _cancellationTokenSource; public async Task StartProcessingAsync() { _cancellationTokenSource = new CancellationTokenSource(); var items = Enumerable.Range(1, 1000); try { // .NET Framework 4.8에서는 Task.Run 대신 Task.Factory.StartNew 사용 권장 await Task.Factory.StartNew(() =&gt; { var parallelOptions = new ParallelOptions { CancellationToken = _cancellationTokenSource.Token, MaxDegreeOfParallelism = 4 }; Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(200); Console.WriteLine($&quot;처리 완료: {item}&quot;); }); }, _cancellationTokenSource.Token); } catch (OperationCanceledException) { Console.WriteLine(&quot;사용자에 의해 작업이 취소되었습니다.&quot;); } } public void CancelProcessing() { _cancellationTokenSource?.Cancel(); Console.WriteLine(&quot;취소 요청이 전송되었습니다.&quot;); } }   ","version":null,"tagName":"h3"},{"title":"Thread와 Parallel.ForEach 조합하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#thread와-parallelforeach-조합하기","content":" 별도 스레드에서 Parallel.ForEach를 실행하고 전체를 안전하게 중단하는 방법입니다:  Thread 내에서 Parallel.ForEach 사용 public class ThreadedParallelProcessor { private Thread _workerThread; private CancellationTokenSource _cancellationTokenSource; public void Start(IEnumerable&lt;int&gt; items) { _cancellationTokenSource = new CancellationTokenSource(); _workerThread = new Thread(() =&gt; ProcessInBackground(items, _cancellationTokenSource.Token)); _workerThread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _workerThread?.Join(TimeSpan.FromSeconds(10)); // 최대 10초 대기 _cancellationTokenSource?.Dispose(); } private void ProcessInBackground(IEnumerable&lt;int&gt; items, CancellationToken cancellationToken) { try { var parallelOptions = new ParallelOptions { CancellationToken = cancellationToken, MaxDegreeOfParallelism = Environment.ProcessorCount / 2 }; Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { cancellationToken.ThrowIfCancellationRequested(); // 실제 작업 처리 ProcessItem(item, cancellationToken); }); Console.WriteLine(&quot;백그라운드 처리가 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;백그라운드 작업이 취소되었습니다.&quot;); } } private void ProcessItem(int item, CancellationToken cancellationToken) { // 긴 작업 중간중간 취소 확인 for (int i = 0; i &lt; 5; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); } Console.WriteLine($&quot;Item {item} 처리 완료&quot;); } }   ","version":null,"tagName":"h2"},{"title":".NET Framework vs .NET 5+ 차이점​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-vs-net-5-차이점","content":" ","version":null,"tagName":"h2"},{"title":"API 차이점 요약​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#api-차이점-요약","content":" 기능\t.NET Framework 4.8\t.NET 5+CancellationToken\t✅ 지원\t✅ 지원 Task.Delay with CancellationToken\t❌ 제한적\t✅ 완전 지원 Task.Run\t❌ 없음\t✅ 지원 CancellationTokenSource.CancelAfter\t❌ 없음\t✅ 지원 Thread.Abort\t⚠️ 사용 가능하지만 위험\t❌ Obsolete  ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8 권장 패턴​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48-권장-패턴","content":" .NET Framework 4.8 권장 패턴 public class RecommendedNetFramework48Pattern { private readonly CancellationTokenSource _cancellationTokenSource; private readonly ManualResetEventSlim _completedEvent; public RecommendedNetFramework48Pattern() { _cancellationTokenSource = new CancellationTokenSource(); _completedEvent = new ManualResetEventSlim(false); } public void StartWork() { Task.Factory.StartNew(() =&gt; DoWork(_cancellationTokenSource.Token), _cancellationTokenSource.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default); } public void StopWork(int timeoutMs = 5000) { _cancellationTokenSource.Cancel(); if (!_completedEvent.Wait(timeoutMs)) { Console.WriteLine(&quot;작업이 제한 시간 내에 완료되지 않았습니다.&quot;); } } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { // 실제 작업 수행 ProcessWorkItem(); // 주기적 취소 확인 (.NET Framework 4.8 호환) if (cancellationToken.WaitHandle.WaitOne(100)) { break; } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { _completedEvent.Set(); Console.WriteLine(&quot;작업이 완료되었습니다.&quot;); } } private void ProcessWorkItem() { // 실제 작업 로직 Thread.Sleep(50); Console.WriteLine($&quot;작업 처리 중... (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } public void Dispose() { _cancellationTokenSource?.Dispose(); _completedEvent?.Dispose(); } }   ","version":null,"tagName":"h3"},{"title":"성능 고려사항​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#성능-고려사항","content":" ","version":null,"tagName":"h2"},{"title":"취소 확인 빈도​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#취소-확인-빈도","content":" 취소 확인을 너무 자주 하면 성능에 영향을 줄 수 있습니다:  효율적인 취소 확인 private void OptimizedWork(CancellationToken cancellationToken) { const int checkInterval = 100; // 100번 작업마다 한 번씩 확인 int counter = 0; while (true) { // 실제 작업 DoSomeWork(); // 주기적으로만 취소 확인 if (++counter % checkInterval == 0) { cancellationToken.ThrowIfCancellationRequested(); } } }   ","version":null,"tagName":"h3"},{"title":"리소스 정리​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#리소스-정리","content":" 취소 시에도 리소스가 제대로 정리되도록 해야 합니다:  리소스 안전 정리 private void SafeResourceHandling(CancellationToken cancellationToken) { using var fileStream = new FileStream(&quot;data.txt&quot;, FileMode.Open); using var reader = new StreamReader(fileStream); try { while (!reader.EndOfStream) { cancellationToken.ThrowIfCancellationRequested(); var line = reader.ReadLine(); ProcessLine(line); } } catch (OperationCanceledException) { Console.WriteLine(&quot;파일 처리가 취소되었습니다.&quot;); // using 문에 의해 자동으로 리소스 정리됨 } }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#결론","content":" C#에서 Thread와 Parallel.ForEach를 안전하게 중단하는 핵심은 다음과 같습니다:  Thread.Abort() 사용 금지: .NET 5 이상에서 지원되지 않으며, .NET Framework에서도 안전하지 않습니다CancellationToken 활용: .NET Framework 4.0부터 지원되는 표준 취소 패턴으로 가장 권장되는 방법입니다플래그 패턴: 간단한 시나리오에서 사용할 수 있는 대안입니다프레임워크별 차이점 고려: .NET Framework 4.8과 .NET 5+ 간의 API 차이를 이해해야 합니다적절한 취소 확인: 성능과 반응성의 균형을 맞춰야 합니다리소스 정리: 취소 시에도 모든 리소스가 안전하게 해제되도록 해야 합니다  이러한 패턴들을 사용하면 리소스 누수나 데이터 손상 없이 멀티스레딩 작업을 안전하게 제어할 수 있습니다. 특히 장시간 실행되는 백그라운드 작업이나 사용자가 중단할 수 있는 작업에서는 반드시 이런 안전한 중단 메커니즘을 구현해야 합니다.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#참고-자료","content":" ","version":null,"tagName":"h2"},{"title":"공식 문서​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#공식-문서","content":" Thread.Abort Method - Microsoft Docs - Thread.Abort() 메서드 공식 문서 및 지원 중단 안내CancellationToken Struct - Microsoft Docs - CancellationToken 구조체 공식 문서Parallel.ForEach Method - Microsoft Docs - Parallel.ForEach 메서드 공식 문서Cancellation in Managed Threads - Microsoft Docs - 관리되는 스레드에서의 취소 패턴 가이드  ","version":null,"tagName":"h3"},{"title":"관련 기술 문서​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#관련-기술-문서","content":" Task-based Asynchronous Pattern (TAP) - Microsoft Docs - 비동기 프로그래밍 패턴Parallel Programming in .NET - Microsoft Docs - .NET 병렬 프로그래밍 가이드Best Practices for Managed Threading - Microsoft Docs - 관리되는 스레딩 모범 사례  ","version":null,"tagName":"h3"},{"title":"추가 학습 자료​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#추가-학습-자료","content":" Stephen Cleary's Blog - Async/Await Best Practices - 비동기 코드 모범 사례Eric Lippert's Blog - Cancellation - 취소 패턴에 대한 심화 설명 ","version":null,"tagName":"h3"},{"title":"Docker로 GDAL 간편하게 사용하기","type":0,"sectionRef":"#","url":"/blog/docker-gdal-geospatial-data-processing","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"Docker에서 GDAL 이미지 찾기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker에서-gdal-이미지-찾기","content":" GitHub Container Registry에서 공식 GDAL 이미지를 제공합니다.    ghcr.io/osgeo/gdal 이미지를 선택하는 것이 좋습니다:  공식 이미지 선택 이유:  공식 지원: OSGeo에서 직접 관리하는 공식 이미지높은 신뢰성: 활발한 업데이트와 커뮤니티 지원다양한 버전: 여러 태그와 변형 버전 제공    ","version":null,"tagName":"h2"},{"title":"적절한 GDAL 이미지 선택하기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#적절한-gdal-이미지-선택하기","content":" Docker 이미지 선택 시 태그를 신중하게 고려해야 합니다.    ","version":null,"tagName":"h2"},{"title":"이미지 유형별 특징​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#이미지-유형별-특징","content":" 이미지 유형\t크기\t특징\t권장 용도ubuntu-full\t~1.5GB\t모든 드라이버 포함\t복잡한 데이터 처리 ubuntu-small\t~800MB\t주요 드라이버만 포함\t일반적인 용도 alpine-normal\t~200MB\tAlpine 기반, 대부분 드라이버\t균형잡힌 선택 alpine-small\t~20MB\t최소 드라이버만 포함\t경량화 우선  latest 이미지의 단점:  큰 용량: Ubuntu 기반으로 압축 상태에서도 936MB실행 시 용량: 압축 해제 후 수 GB의 디스크 공간 사용느린 다운로드: 네트워크 대역폭과 시간 소모  ","version":null,"tagName":"h3"},{"title":"Alpine Linux 기반 이미지 권장​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#alpine-linux-기반-이미지-권장","content":" Ubuntu가 필요하지 않다면 Alpine Linux 기반 이미지를 사용하는 것이 효율적입니다.    Alpine 이미지의 장점:  alpine-small: 약 20MB의 경량 크기빠른 다운로드: Ubuntu 대비 95% 용량 절약동일한 성능: GDAL 기능에 전혀 지장 없음보안 최적화: Alpine Linux의 보안 특화 설계  ","version":null,"tagName":"h3"},{"title":"버전 고정의 중요성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#버전-고정의-중요성","content":" 버전 관리 주의사항 프로덕션 환경에서는 특정 버전을 명시하는 것이 좋습니다: API 안정성: GDAL 버전 업데이트 시 매개변수 변경 가능성호환성 보장: 기존 스크립트와의 호환성 유지재현성: 동일한 환경에서의 일관된 결과  예시: ghcr.io/osgeo/gdal:alpine-small-3.9.0  ","version":null,"tagName":"h3"},{"title":"Docker GDAL 기본 사용법​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker-gdal-기본-사용법","content":" ","version":null,"tagName":"h2"},{"title":"Docker 실행 명령어 구조​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker-실행-명령어-구조","content":" Docker 실행 기본 구조 docker run [실행 파라미터] [도커이미지명:태그명] [컨테이너 안에서 실행할 명령들]   주요 실행 파라미터:  -it: 대화형 터미널 모드--rm: 컨테이너 종료 후 자동 삭제-v: 볼륨 마운트 (로컬 폴더와 컨테이너 폴더 연결)-w: 작업 디렉토리 설정-e: 환경 변수 설정  ","version":null,"tagName":"h3"},{"title":"볼륨 마운트 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#볼륨-마운트-설정","content":" Docker 컨테이너는 독립된 Linux 환경에서 실행됩니다. 로컬 파일에 접근하려면 볼륨 마운트가 필요합니다.  파일 시스템 분리:  컨테이너: 독립된 Linux 파일 시스템로컬: Windows 파일 시스템 (C:, D: 드라이브)해결책: 볼륨 마운트로 두 공간 연결  볼륨 마운트 문법 # Windows docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어] # macOS/Linux docker run -it --rm -v /home/user/data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   ","version":null,"tagName":"h3"},{"title":"실제 GDAL 도구 활용하기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#실제-gdal-도구-활용하기","content":" ","version":null,"tagName":"h2"},{"title":"1. gdalinfo - 파일 정보 확인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-gdalinfo---파일-정보-확인","content":" 기본 파일 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /workspace/sample.tif   상세 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo -stats -hist -checksum /workspace/sample.tif     ","version":null,"tagName":"h3"},{"title":"2. gdal_translate - 파일 형식 변환​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-gdal_translate---파일-형식-변환","content":" TIFF를 PNG로 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of PNG /workspace/input.tif /workspace/output.png   압축 옵션과 함께 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co COMPRESS=LZW -co TILED=YES \\ /workspace/input.tif /workspace/compressed.tif   특정 밴드만 추출 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -b 1 -b 2 -b 3 /workspace/multispectral.tif /workspace/rgb.tif   ","version":null,"tagName":"h3"},{"title":"3. gdalwarp - 좌표계 변환 및 리프로젝션​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-gdalwarp---좌표계-변환-및-리프로젝션","content":" 좌표계 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:4326 /workspace/input.tif /workspace/wgs84.tif   리샘플링과 함께 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:3857 -r bilinear -tr 10 10 \\ /workspace/input.tif /workspace/webmercator.tif   여러 파일 모자이크 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp /workspace/tile1.tif /workspace/tile2.tif /workspace/tile3.tif \\ /workspace/mosaic.tif   ","version":null,"tagName":"h3"},{"title":"4. gdalbuildvrt - 가상 래스터 생성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#4-gdalbuildvrt---가상-래스터-생성","content":" 여러 파일을 하나의 VRT로 결합 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt /workspace/mosaic.vrt /workspace/*.tif   해상도별 오버뷰 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt -resolution highest /workspace/high_res.vrt /workspace/*.tif   ","version":null,"tagName":"h3"},{"title":"5. gdaldem - 지형 분석​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#5-gdaldem---지형-분석","content":" 경사도 계산 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem slope /workspace/dem.tif /workspace/slope.tif   음영기복도 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem hillshade -z 2 -s 1 /workspace/dem.tif /workspace/hillshade.tif   등고선 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_contour -a elevation -i 10 /workspace/dem.tif /workspace/contours.shp   ","version":null,"tagName":"h3"},{"title":"6. gdal_calc.py - 래스터 계산​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#6-gdal_calcpy---래스터-계산","content":" NDVI 계산 (밴드 4: NIR, 밴드 3: Red) docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_calc.py -A /workspace/multispectral.tif --A_band=4 \\ -B /workspace/multispectral.tif --B_band=3 \\ --outfile=/workspace/ndvi.tif --calc=&quot;(A-B)/(A+B)&quot;   래스터 마스킹 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_calc.py -A /workspace/input.tif -B /workspace/mask.tif \\ --outfile=/workspace/masked.tif --calc=&quot;A*B&quot;   ","version":null,"tagName":"h3"},{"title":"벡터 데이터 처리 (OGR)​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#벡터-데이터-처리-ogr","content":" ","version":null,"tagName":"h2"},{"title":"1. ogrinfo - 벡터 파일 정보 확인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-ogrinfo---벡터-파일-정보-확인","content":" Shapefile 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogrinfo /workspace/boundaries.shp   상세 정보와 속성 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogrinfo -al -so /workspace/boundaries.shp   ","version":null,"tagName":"h3"},{"title":"2. ogr2ogr - 벡터 데이터 변환​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-ogr2ogr---벡터-데이터-변환","content":" Shapefile을 GeoJSON으로 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON /workspace/output.geojson /workspace/input.shp   좌표계 변환과 함께 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON -t_srs EPSG:4326 \\ /workspace/wgs84.geojson /workspace/input.shp   속성 필터링 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON -where &quot;POPULATION &gt; 100000&quot; \\ /workspace/large_cities.geojson /workspace/cities.shp   ","version":null,"tagName":"h3"},{"title":"실제 업무 시나리오​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#실제-업무-시나리오","content":" ","version":null,"tagName":"h2"},{"title":"시나리오 1: 위성영상 전처리 파이프라인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-1-위성영상-전처리-파이프라인","content":" 1. 원본 영상 정보 확인 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /data/landsat8_raw.tif   2. 좌표계를 UTM으로 변환 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:32652 -r cubic \\ /data/landsat8_raw.tif /data/landsat8_utm.tif   3. RGB 밴드만 추출하여 압축 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -b 4 -b 3 -b 2 -of GTiff -co COMPRESS=JPEG -co QUALITY=85 \\ /data/landsat8_utm.tif /data/landsat8_rgb.tif   ","version":null,"tagName":"h3"},{"title":"시나리오 2: DEM 데이터 분석​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-2-dem-데이터-분석","content":" 1. 여러 DEM 타일 병합 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt /data/merged_dem.vrt /data/dem_*.tif   2. 병합된 DEM을 단일 파일로 변환 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co COMPRESS=LZW \\ /data/merged_dem.vrt /data/merged_dem.tif   3. 경사도와 음영기복도 생성 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem slope /data/merged_dem.tif /data/slope.tif docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem hillshade -z 2 /data/merged_dem.tif /data/hillshade.tif   ","version":null,"tagName":"h3"},{"title":"시나리오 3: 배치 처리 스크립트​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-3-배치-처리-스크립트","content":" Windows 배치 파일 (process_images.bat) @echo off set IMAGE_NAME=ghcr.io/osgeo/gdal:alpine-small-3.9.0 set DATA_DIR=c:\\gis_data echo 이미지 처리 시작... for %%f in (%DATA_DIR%\\*.tif) do ( echo 처리 중: %%f docker run --rm -v %DATA_DIR%:/data %IMAGE_NAME% ^ gdal_translate -of GTiff -co COMPRESS=LZW &quot;%%f&quot; &quot;/data/compressed_%%~nf.tif&quot; ) echo 처리 완료!   ","version":null,"tagName":"h3"},{"title":"성능 최적화 팁​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#성능-최적화-팁","content":" ","version":null,"tagName":"h2"},{"title":"1. 메모리 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-메모리-설정","content":" 메모리 캐시 크기 설정 docker run -it --rm -v c:\\data:/workspace \\ -e GDAL_CACHEMAX=512 \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -wm 1024 /workspace/large_file.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"2. 멀티스레딩 활용​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-멀티스레딩-활용","content":" 멀티스레드 처리 docker run -it --rm -v c:\\data:/workspace \\ -e GDAL_NUM_THREADS=ALL_CPUS \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -multi /workspace/input.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"3. 타일링 최적화​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-타일링-최적화","content":" 타일 크기 최적화 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=512 -co BLOCKYSIZE=512 \\ /workspace/input.tif /workspace/tiled.tif   ","version":null,"tagName":"h3"},{"title":"문제 해결 가이드​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#문제-해결-가이드","content":" ","version":null,"tagName":"h2"},{"title":"자주 발생하는 문제들​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#자주-발생하는-문제들","content":" 1. 권한 문제​  문제: 컨테이너에서 생성된 파일에 접근할 수 없음  해결책: 사용자 ID 매핑 사용  docker run -it --rm -v c:\\data:/workspace \\ --user $(id -u):$(id -g) \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   2. 메모리 부족​  문제: 대용량 파일 처리 시 메모리 부족  해결책:  Docker 메모리 제한 증가GDAL 캐시 크기 조정타일 단위 처리  docker run -it --rm -m 4g -v c:\\data:/workspace \\ -e GDAL_CACHEMAX=1024 \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   3. 좌표계 오류​  문제: 좌표계 정보가 없거나 잘못됨  해결책: 명시적 좌표계 지정  docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -s_srs EPSG:4326 -t_srs EPSG:3857 \\ /workspace/input.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"디버깅 팁​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#디버깅-팁","content":" 상세 로그 출력 docker run -it --rm -v c:\\data:/workspace \\ -e CPL_DEBUG=ON \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /workspace/problematic.tif   지원되는 형식 확인 docker run -it --rm ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo --formats   ","version":null,"tagName":"h3"},{"title":"고급 활용법​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#고급-활용법","content":" ","version":null,"tagName":"h2"},{"title":"1. Docker Compose 활용​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-docker-compose-활용","content":" docker-compose.yml version: '3.8' services: gdal: image: ghcr.io/osgeo/gdal:alpine-small-3.9.0 volumes: - ./data:/workspace working_dir: /workspace environment: - GDAL_CACHEMAX=512 - GDAL_NUM_THREADS=ALL_CPUS command: tail -f /dev/null # 컨테이너 유지   사용법 docker-compose up -d docker-compose exec gdal gdalinfo /workspace/sample.tif docker-compose down   ","version":null,"tagName":"h3"},{"title":"2. 별칭(Alias) 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-별칭alias-설정","content":" Linux/macOS (.bashrc 또는 .zshrc) alias dgdal='docker run -it --rm -v $(pwd):/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0' alias dgdalinfo='dgdal gdalinfo' alias dgdaltranslate='dgdal gdal_translate' alias dgdalwarp='dgdal gdalwarp'   Windows (doskey 명령어) doskey dgdal=docker run -it --rm -v %cd%:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 $* doskey dgdalinfo=dgdal gdalinfo $*   ","version":null,"tagName":"h3"},{"title":"3. 사용자 정의 이미지 생성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-사용자-정의-이미지-생성","content":" Dockerfile FROM ghcr.io/osgeo/gdal:alpine-small-3.9.0 # 추가 패키지 설치 RUN apk add --no-cache python3 py3-pip # Python 라이브러리 설치 RUN pip3 install numpy rasterio # 작업 디렉토리 설정 WORKDIR /workspace # 사용자 정의 스크립트 복사 COPY scripts/ /usr/local/bin/ # 실행 권한 부여 RUN chmod +x /usr/local/bin/*   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#결론","content":" Docker GDAL 사용의 핵심 장점:  설치 간소화: 복잡한 컴파일 과정 생략환경 독립성: 시스템 설정에 영향 없음일관된 결과: 운영체제 무관하게 동일한 실행 환경즉시 사용: 몇 분 만에 GDAL 활용 가능확장성: 필요에 따라 사용자 정의 이미지 생성 가능  Docker를 활용하면 GDAL 설치의 복잡함을 해결하고 지리공간 데이터 처리에 집중할 수 있습니다. 이 글에서 소개한 다양한 예제와 팁들을 활용하여 효율적인 GIS 워크플로우를 구축해보세요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#참고-자료","content":" GDAL 공식 문서GitHub Container Registry - osgeo/gdalGDAL Docker 이미지 소스코드Alpine Linux 공식 사이트Docker 공식 문서OGR 벡터 드라이버 목록GDAL 래스터 드라이버 목록 ","version":null,"tagName":"h2"},{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","type":0,"sectionRef":"#","url":"/blog/lm-studio-local-ai-guide","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"LM Studio란?​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#lm-studio란","content":" LM Studio는 Windows, macOS, Linux 등 다양한 운영체제에서 동작하며, 인터넷 연결 없이도 LLM을 내 PC에서 실행할 수 있는 프로그램입니다. Hugging Face 등에서 공개된 다양한 오픈소스 AI 모델(Llama, MPT, StarCoder 등)을 쉽게 다운로드하고, 설치와 구동까지 한 번에 처리할 수 있습니다.  ChatGPT처럼 대화형 인터페이스를 제공해 누구나 쉽게 AI와 채팅하거나 실험해볼 수 있으며, 개발자라면 OpenAI API와 호환되는 로컬 서버 기능도 활용할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"주요 특징과 장점​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#주요-특징과-장점","content":" ","version":null,"tagName":"h2"},{"title":"🔒 완전 오프라인 사용​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-완전-오프라인-사용","content":" 모델 다운로드 후에는 인터넷 없이도 AI를 사용할 수 있어 개인정보 보호에 탁월합니다. 민감한 데이터나 기업 내부 정보를 다룰 때 특히 유용합니다.  ","version":null,"tagName":"h3"},{"title":"🎨 사용자 친화적 UI​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-사용자-친화적-ui","content":" 복잡한 명령어나 설정 없이도 직관적인 그래픽 인터페이스에서 모델 검색, 다운로드, 실행, 채팅이 가능합니다. 기술적 배경이 없어도 쉽게 시작할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🤖 다양한 모델 지원​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-다양한-모델-지원","content":" Hugging Face의 다양한 GGML/GGUF 포맷 모델을 지원하며, 여러 모델을 동시에 로드해 비교하거나 용도별로 활용할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🌐 로컬 서버 기능​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-로컬-서버-기능","content":" OpenAI API와 호환되는 로컬 HTTP 서버를 제공해, 기존 OpenAI API를 사용하는 애플리케이션과도 쉽게 연동할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"💰 비용 효율성​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-비용-효율성","content":" 클라우드 기반 AI 서비스 대비 훨씬 저렴하게, 혹은 무료로 LLM을 활용할 수 있습니다. 초기 하드웨어 투자 후에는 추가 비용이 거의 발생하지 않습니다.  ","version":null,"tagName":"h3"},{"title":"설치 및 시작 방법​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#설치-및-시작-방법","content":" ","version":null,"tagName":"h2"},{"title":"1. 다운로드 및 설치​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#1-다운로드-및-설치","content":" LM Studio 공식 홈페이지(lmstudio.ai)에서 자신의 OS에 맞는 설치 파일을 다운로드합니다. 설치 과정은 일반적인 데스크탑 애플리케이션과 동일하게 간단합니다.    ","version":null,"tagName":"h3"},{"title":"2. 모델 다운로드​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#2-모델-다운로드","content":" 프로그램을 실행하면 인기 모델을 추천받거나 직접 검색해 다운로드할 수 있습니다. 처음 사용자라면 Llama 2 7B 모델부터 시작하는 것을 권장합니다.  시스템 메모리 확인 필수 사용하는 시스템의 비디오 메모리에 따라 실행할 수 있는 모델의 용량이 제한됩니다. 모델을 다운로드하기 전에 시스템의 VRAM을 먼저 확인하세요.    ","version":null,"tagName":"h3"},{"title":"3. 모델 실행 및 채팅​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#3-모델-실행-및-채팅","content":" 모델을 다운로드한 후에는 채팅 UI에서 바로 AI와 대화하거나, 로컬 서버를 시작해 API로도 활용할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"실제 테스트 결과​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#실제-테스트-결과","content":" ","version":null,"tagName":"h2"},{"title":"첫 번째 테스트: DeepSeek R1-distill-qwen-7b​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#첫-번째-테스트-deepseek-r1-distill-qwen-7b","content":" 4.68GB 크기의 DeepSeek R1-distill-qwen-7b 모델로 첫 테스트를 진행했습니다.    한국어로 &quot;안녕&quot;을 입력했으나, 모델에서는 한국어 &quot;안녕!&quot;과 함께 알 수 없는 문자가 추가로 출력되었습니다. 한국어 처리에 한계가 있는 것으로 보입니다.  ","version":null,"tagName":"h3"},{"title":"두 번째 테스트: DeepSeek R1-0528​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#두-번째-테스트-deepseek-r1-0528","content":" 더 최신 버전인 DeepSeek R1-0528 모델로 재테스트를 진행했습니다.    간단한 질문에 28.31초가 소요되었지만, 정상적인 한글 문장으로 답변이 생성되었습니다. 오프라인 환경에서 로컬 노트북이 AI 답변을 생성한다는 점은 놀랍지만, 응답 속도는 아쉬운 부분입니다.  ","version":null,"tagName":"h3"},{"title":"테스트 환경​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#테스트-환경","content":"   테스트에 사용된 노트북은 100만원대의 평범한 AMD CPU 계열 내장그래픽으로, VRAM이 512MB에 불과해 원활한 테스트에는 한계가 있었습니다.  하지만 고성능 하드웨어를 보유한 사용자라면 인터넷 서비스를 거치지 않고 자체 장비에서 AI 모델을 구동하여 채팅은 물론, Cursor나 다른 Llama 계열 API를 사용하는 프로그램과도 연동할 수 있을 것입니다.  ","version":null,"tagName":"h3"},{"title":"시스템 요구사항​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#시스템-요구사항","content":" ","version":null,"tagName":"h2"},{"title":"최소 사양​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#최소-사양","content":" macOS: M1/M2/M3 칩, macOS 13.6 이상Windows/Linux: AVX2 지원 CPU, 8GB RAM, 4GB 이상 VRAM  ","version":null,"tagName":"h3"},{"title":"권장 사양​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#권장-사양","content":" RAM: 16GB 이상 (큰 모델의 경우 32GB 권장)GPU: NVIDIA RTX 시리즈 또는 Apple Silicon 칩저장공간: 모델 크기에 따라 10GB~100GB 이상  더 큰 모델이나 빠른 응답을 원한다면 고성능 GPU와 충분한 메모리가 필수입니다.  ","version":null,"tagName":"h3"},{"title":"LM Studio가 적합한 사용자​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#lm-studio가-적합한-사용자","content":" ","version":null,"tagName":"h2"},{"title":"🔬 AI 연구자/개발자​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-ai-연구자개발자","content":" 다양한 LLM을 실험하고, API 연동을 통해 애플리케이션에 통합하고 싶은 개발자에게 이상적입니다.  ","version":null,"tagName":"h3"},{"title":"🛡️ 프라이버시 중시 사용자​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#️-프라이버시-중시-사용자","content":" 내 데이터가 외부로 전송되지 않는 완전한 오프라인 환경이 필요한 사용자에게 적합합니다.  ","version":null,"tagName":"h3"},{"title":"🎓 AI 입문자/취미 개발자​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-ai-입문자취미-개발자","content":" 복잡한 설정 없이 쉽게 LLM을 체험하고 학습하고 싶은 분들에게 훌륭한 시작점이 됩니다.  ","version":null,"tagName":"h3"},{"title":"Ollama와의 비교​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#ollama와의-비교","content":" 특징\tLM Studio\tOllama인터페이스\t그래픽(GUI)\t명령줄(CLI) 모델 지원\t다양한 GGML/GGUF 모델\t특정 모델 최적화 오픈소스 여부\t비오픈소스\t완전 오픈소스 API\tOpenAI 호환 API 제공\tREST API 제공 플랫폼\tWindows, Mac, Linux\tMac, Linux, Windows 사용 편의성\t초보자 친화적\t개발자 중심 모델 관리\tGUI 기반 직관적 관리\tCLI 명령어 기반  LM Studio는 GUI를 선호하는 사용자에게, Ollama는 CLI 환경에 익숙한 개발자에게 더 적합합니다.  ","version":null,"tagName":"h2"},{"title":"실제 활용 사례​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#실제-활용-사례","content":" ","version":null,"tagName":"h2"},{"title":"💻 코드 리뷰 및 생성​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-코드-리뷰-및-생성","content":" StarCoder나 CodeLlama 모델을 사용해 코드 리뷰, 버그 찾기, 코드 생성 등의 작업을 로컬에서 안전하게 수행할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"📝 문서 작성 지원​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-문서-작성-지원","content":" 기술 문서, 블로그 포스트, 이메일 등의 작성을 도와주는 개인 AI 어시스턴트로 활용할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🌍 언어 학습 및 번역​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-언어-학습-및-번역","content":" 다양한 언어로 대화하며 언어 학습을 지원하거나, 번역 작업을 수행할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🎯 맞춤형 AI 어시스턴트​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-맞춤형-ai-어시스턴트","content":" 특정 도메인에 특화된 모델을 사용해 전문 분야의 질문 답변이나 분석 작업을 수행할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"성능 최적화 팁​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#성능-최적화-팁","content":" ","version":null,"tagName":"h2"},{"title":"하드웨어 최적화​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#하드웨어-최적화","content":" GPU 가속 활용: CUDA(NVIDIA) 또는 Metal(Apple) 가속을 활성화해 성능 향상메모리 관리: 다른 애플리케이션을 종료해 더 많은 메모리 확보SSD 사용: 모델 로딩 속도 향상을 위해 SSD에 모델 저장  ","version":null,"tagName":"h3"},{"title":"모델 선택 전략​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#모델-선택-전략","content":" 7B 모델부터 시작: 처음에는 작은 모델로 시작해 점진적으로 업그레이드양자화 모델 활용: Q4_K_M, Q5_K_M 등 양자화된 모델로 메모리 사용량 절약용도별 모델 선택: 코딩용, 대화용, 번역용 등 목적에 맞는 모델 선택  ","version":null,"tagName":"h3"},{"title":"주의사항​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#주의사항","content":" 라이선스 확인 필수 상업적 용도로 사용할 경우 각 모델의 라이선스를 반드시 확인하세요. 일부 모델은 상업적 사용이 제한될 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"기타 고려사항​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#기타-고려사항","content":" 전력 소비: 고성능 GPU 사용 시 전력 소비량이 크게 증가할 수 있습니다발열 관리: 장시간 사용 시 시스템 발열에 주의하세요모델 업데이트: 정기적으로 새로운 모델을 확인하고 업데이트하세요  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#결론","content":" LM Studio는 누구나 쉽고 안전하게 AI 언어모델을 체험하고, 나만의 AI 환경을 구축할 수 있는 최고의 로컬 LLM 도구입니다. 복잡한 설정 없이 내 PC에서 직접 AI를 만나보세요.  개인정보 보호, 비용 절약, 사용 편의성을 모두 만족하는 LM Studio로 AI의 새로운 가능성을 탐험해보시기 바랍니다. 특히 개발자라면 로컬 API 서버 기능을 통해 기존 워크플로우에 쉽게 통합할 수 있어 더욱 유용할 것입니다.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#참고-자료","content":" LM Studio 공식 홈페이지Hugging Face 모델 허브GGML/GGUF 포맷 가이드LM Studio 공식 문서로컬 LLM 성능 벤치마크 ","version":null,"tagName":"h2"},{"title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","type":0,"sectionRef":"#","url":"/blog/microsoft-typescript-native-go-project-analysis","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"프로젝트 배경 및 필요성​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#프로젝트-배경-및-필요성","content":" ","version":null,"tagName":"h2"},{"title":"기존 TypeScript의 성능 한계​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#기존-typescript의-성능-한계","content":" TypeScript는 JavaScript 생태계에서 정적 타입 검사와 구조화된 개발 경험을 제공하는 핵심 도구로 자리잡았습니다. 하지만 코드베이스가 대규모로 확장됨에 따라 심각한 성능 문제가 드러나기 시작했습니다.  마이크로소프트의 공식 발표에 따르면, 현재 TypeScript 컴파일러가 직면한 주요 성능 문제는 다음과 같습니다:  주요 성능 문제점​  느린 로딩 시간: 고성능 머신에서도 Visual Studio Code를 통해 전체 프로젝트를 로드하는 데 약 9.6초 소요긴 타입 검사 프로세스: 대규모 프로젝트에서 개발자의 작업 흐름을 크게 방해과도한 메모리 사용: 시스템 리소스를 비효율적으로 사용하는 문제점확장성 한계: 엔터프라이즈급 대규모 코드베이스에서의 성능 저하  개발자들은 포괄적인 타입 분석과 반응성이 뛰어난 코딩 환경 사이에서 지속적으로 절충안을 찾아야 했습니다. 이는 TypeScript의 핵심 가치 제안을 훼손하는 결과를 초래했으며, 마이크로소프트로 하여금 근본적인 해결책을 모색하게 만든 주요 동인이 되었습니다.  ","version":null,"tagName":"h3"},{"title":"Go 언어 선택의 전략적 근거​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#go-언어-선택의-전략적-근거","content":" 마이크로소프트가 TypeScript 재구현을 위해 Go 언어를 선택한 것은 단순한 성능 향상을 넘어선 전략적 결정이었습니다. 마이크로소프트 TypeScript 팀의 Ryan Cavanaugh는 공식 블로그에서 이러한 선택의 근거를 상세히 설명했습니다.  Go 선택의 핵심 이유​  구조적 타입 호환성: JavaScript의 동적 특성과 매우 유사한 타입 시스템기존 코드베이스 호환성: TypeScript 코드와의 호환성 유지 가능자동 가비지 수집: TypeScript의 기존 메모리 모델과 자연스럽게 어우러짐교차 플랫폼 지원: 다양한 개발 환경에서 원활한 배포 가능컴파일 속도: Go의 빠른 컴파일 시간이 개발 생산성에 기여  Ryan Cavanaugh를 비롯한 마이크로소프트의 엔지니어링 리드들은 다른 대안들과 비교 분석한 결과 Go가 가장 실용적인 선택이라고 판단했습니다:  Rust: 뛰어난 성능을 제공하지만 소유권 모델과 엄격한 메모리 관리로 인해 TypeScript의 직접적인 번역에 부적합C#: 객체 지향 패러다임 의존성으로 인해 TypeScript 아키텍처의 근본적 변경 필요C++: 메모리 관리의 복잡성과 개발 생산성 저하 우려  ","version":null,"tagName":"h3"},{"title":"기술적 구현 및 아키텍처​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#기술적-구현-및-아키텍처","content":" ","version":null,"tagName":"h2"},{"title":"성능 최적화 목표​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#성능-최적화-목표","content":" 마이크로소프트는 Go 기반 TypeScript Native 컴파일러를 통해 달성하고자 하는 구체적인 성능 목표를 공식 발표에서 제시했습니다:  핵심 성능 개선 목표​  항목\t기존 성능\t목표 성능\t개선 배율빌드 시간\t기준값\t기준값의 1/10\t10배 단축 에디터 응답 시간\t9.6초\t1.2초\t8배 향상 메모리 사용량\t기준값\t기준값의 50% 이하\t대폭 감소 타입 검사 속도\t기준값\t기준값의 1/5\t5배 향상  Visual Studio Code에서의 내부 벤치마크 결과에 따르면, 기존에 9.6초가 걸리던 전체 프로젝트 로딩 시간이 Go 기반 구현에서는 1.2초로 단축되어 약 8배의 성능 향상을 보여주고 있습니다.  이러한 성능 개선은 단순히 숫자상의 향상을 넘어서 개발자의 작업 흐름을 더욱 자연스럽고 끊김없게 만들어 줄 것으로 기대됩니다.  ","version":null,"tagName":"h3"},{"title":"TypeScript Native의 핵심 기술​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#typescript-native의-핵심-기술","content":" 마이크로소프트는 TypeScript Native 프로젝트에서 다음과 같은 핵심 기술들을 적용하고 있습니다:  아키텍처 혁신​  병렬 처리 최적화: Go의 고루틴을 활용한 동시성 처리메모리 풀링: 효율적인 메모리 관리를 통한 가비지 수집 최적화증분 컴파일: 변경된 부분만 재컴파일하는 스마트 빌드 시스템캐싱 전략: 타입 정보와 컴파일 결과의 지능적 캐싱  ","version":null,"tagName":"h3"},{"title":"개발 진행 상황 및 CI/CD​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#개발-진행-상황-및-cicd","content":" GitHub 레포지토리에서 확인할 수 있는 개발 진행 상황을 보면, 마이크로소프트 팀은 체계적인 개발 프로세스를 통해 프로젝트를 추진하고 있습니다.  최근 개발 활동​  2025년 4월 12일: &quot;Fix some bugs in tsc -w&quot; 관련 Pull Request 제출CI/CD 파이프라인: 포괄적인 검증 과정 구축호환성 테스트: 기존 TypeScript 코드베이스와의 100% 호환성 검증  CI/CD 테스트 매트릭스​  CI/CD 파이프라인은 다음과 같은 포괄적인 검증 과정을 거치고 있습니다:  lint - 코드 품질 검사test - 단위 테스트 및 통합 테스트build - 빌드 검증format - 코드 포맷팅generate - 코드 생성tidy - 정리 작업smoke - 스모크 테스트extension - VS Code 확장 기능 테스트misc - 기타 테스트baselines - 기준선 테스트 (3분 30초, 가장 긴 실행 시간)  총 실행 시간 10분 31초로 기록된 CI 워크플로우는 프로젝트의 안정성과 품질을 보장하기 위한 엄격한 검증 체계가 구축되어 있음을 보여줍니다.  ","version":null,"tagName":"h3"},{"title":"출시 계획 및 호환성 전략​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#출시-계획-및-호환성-전략","content":" ","version":null,"tagName":"h2"},{"title":"단계적 출시 로드맵​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#단계적-출시-로드맵","content":" 마이크로소프트는 TypeScript Native의 안정적인 도입을 위해 신중하게 설계된 단계적 출시 계획을 수립했습니다.  2025년 출시 일정​  🚀 2025년 중반 - TypeScript Native 미리보기 버전  명령줄 타입 검사 지원새로운 성능 개선사항 체험 기회개발자 피드백 수집기존 워크플로우에 최소한의 변화선택적 도입 가능  🎯 2025년 후반 - TypeScript Native 완전 기능 버전  프로젝트 빌드 및 언어 서비스 통합Visual Studio Code 완전 통합실시간 타입 검사자동 완성 기능 개선디버깅 도구 통합  이러한 단계적 접근 방식은 대규모 엔터프라이즈 환경에서 새로운 도구를 안전하게 도입할 수 있도록 하는 실용적인 전략입니다.  ","version":null,"tagName":"h3"},{"title":"이중 유지 관리 전략​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#이중-유지-관리-전략","content":" 마이크로소프트는 Go 기반 구현으로의 전환이 기존 JavaScript 기반 구현의 즉각적인 폐기를 의미하지 않는다는 점을 명확히 했습니다.  버전 관리 전략​  버전\t구현 언어\t상태\t대상\t지원 기간TypeScript 6.x\tJavaScript\t지속 유지\t기존 사용자\t최소 3년 TypeScript Native 7.x\tGo\t신규 출시\t새로운 &quot;네이티브&quot; 버전\t장기 지원  이러한 이중 유지 관리 전략은 다음과 같은 장점을 제공합니다:  TypeScript의 안정성에 크게 의존하는 기업들에게 충분한 전환 시간 제공프로젝트 요구사항과 일정에 맞춘 유연한 마이그레이션 가능운영상의 위험 최소화점진적 기능 검증 및 피드백 수집  ","version":null,"tagName":"h3"},{"title":"생태계 영향 및 경쟁 환경​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#생태계-영향-및-경쟁-환경","content":" ","version":null,"tagName":"h2"},{"title":"TypeScript 생태계에 미치는 파급효과​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#typescript-생태계에-미치는-파급효과","content":" TypeScript Native의 도입은 단순한 성능 개선을 넘어서 전체 TypeScript 생태계에 광범위한 파급효과를 미칠 것으로 예상됩니다.  예상되는 긍정적 효과​  📈 개발 생산성 향상  대규모 프로젝트에서의 개발 경험 근본적 개선TypeScript 채택률 증가 (특히 엔터프라이즈 환경)JavaScript 생태계 전반의 개발 품질 향상개발자 만족도 증가  ⚡ CI/CD 효율성 개선  빌드 시간의 획기적인 단축으로 배포 주기 단축DevOps 문화에 긍정적 영향클라우드 컴퓨팅 비용 절감 효과  🌐 접근성 확대  리소스가 제한된 환경에서도 TypeScript 효과적 활용 가능스타트업이나 중소 규모 개발팀의 엔터프라이즈급 도구 접근성 향상TypeScript 도입 장벽 감소교육 환경에서의 활용도 증가  ","version":null,"tagName":"h3"},{"title":"다른 도구들과의 관계​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#다른-도구들과의-관계","content":" 현재 JavaScript/TypeScript 생태계에는 성능 개선을 목표로 하는 다양한 도구들이 존재하며, Microsoft의 TypeScript Native는 이러한 경쟁 환경에서 독특한 위치를 차지하게 될 것입니다.  기존 성능 도구들과의 차별점​  🦀 Rust 기반 도구들  SWC, Biome, Turbopack: 주로 번들링이나 특정 기능에 초점TypeScript Native: TypeScript 언어 자체의 핵심 기능 개선에 집중  🔧 상호 운용성 도구들  bel, tygo: Go 구조체에서 TypeScript 인터페이스 생성에 초점TypeScript Native: TypeScript 자체의 성능과 확장성 근본적 개선  🚀 기타 컴파일러 도구들  esbuild, Vite: 빠른 번들링과 개발 서버에 특화TypeScript Native: 타입 검사와 언어 서비스의 전면적 개선  이러한 차별화된 접근 방식은 다른 도구들과 경쟁하기보다는 상호 보완적인 관계를 형성할 가능성이 높으며, 전체 생태계의 성능 향상에 기여할 것으로 예상됩니다.  ","version":null,"tagName":"h3"},{"title":"기술적 도전과 해결 방안​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#기술적-도전과-해결-방안","content":" ","version":null,"tagName":"h2"},{"title":"호환성 보장​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#호환성-보장","content":" TypeScript Native 프로젝트의 가장 큰 도전 중 하나는 기존 TypeScript 코드베이스와의 100% 호환성을 보장하는 것입니다.  호환성 전략​  AST(Abstract Syntax Tree) 호환성: 기존 TypeScript AST와 동일한 구조 유지API 호환성: TypeScript Compiler API의 완전한 호환성 보장설정 파일 호환성: tsconfig.json 등 기존 설정 파일 완전 지원플러그인 생태계: 기존 TypeScript 플러그인들과의 호환성 유지  ","version":null,"tagName":"h3"},{"title":"성능 최적화 기법​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#성능-최적화-기법","content":" 마이크로소프트는 Go의 특성을 최대한 활용하여 다음과 같은 최적화 기법들을 적용하고 있습니다:  메모리 풀링: 빈번한 할당/해제를 피하는 메모리 관리병렬 타입 검사: 독립적인 모듈들의 동시 처리지능적 캐싱: 타입 정보의 효율적 캐싱 전략증분 빌드: 변경된 부분만 재처리하는 스마트 빌드  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#결론","content":" Microsoft의 TypeScript Native 프로젝트는 현대 소프트웨어 개발에서 TypeScript가 차지하는 중요성을 인정하고, 그 한계를 극복하기 위한 혁신적인 시도로 평가됩니다.  ","version":null,"tagName":"h2"},{"title":"핵심 성과 목표​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#핵심-성과-목표","content":" JavaScript에서 Go로의 핵심 엔진 전환은 단순한 기술적 개선을 넘어서 개발자 경험의 근본적인 변화를 가져올 것으로 기대됩니다:  ⚡ 빌드 시간 10배 단축으로 개발 생산성 극대화💾 메모리 사용량 대폭 감소로 시스템 효율성 향상🚀 에디터 응답 시간 8배 향상으로 개발 경험 개선🔧 타입 검사 속도 5배 향상으로 실시간 피드백 강화  ","version":null,"tagName":"h3"},{"title":"전략적 의미​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#전략적-의미","content":" 신중한 접근 방식  2025년 중반 미리보기 버전과 후반 완전 기능 버전의 단계적 출시 계획기존 JavaScript 기반 구현과의 이중 유지 관리 전략안정성과 혁신 사이의 균형엔터프라이즈 환경을 고려한 점진적 전환 지원  기술적 타당성  Go 언어 선택의 전략적 근거와 기술적 적합성구조적 타입 호환성과 가비지 수집 최적화TypeScript의 특성과 잘 어울리는 기술적 결정기존 생태계와의 완벽한 호환성 보장  이 프로젝트가 성공적으로 완성된다면 TypeScript 생태계 전반에 긍정적인 파급효과를 미치며, 현대 웹 개발의 생산성과 품질을 한 단계 끌어올리는 중요한 이정표가 될 것으로 전망됩니다. 특히 대규모 엔터프라이즈 환경에서 TypeScript의 활용도가 크게 증가할 것으로 예상되며, 이는 전체 JavaScript 생태계의 성숙도 향상에도 기여할 것입니다.  ","version":null,"tagName":"h3"},{"title":"참고 자료​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#참고-자료","content":" ","version":null,"tagName":"h2"},{"title":"공식 문서 및 발표​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#공식-문서-및-발표","content":" Microsoft TypeScript Native 공식 블로그TypeScript Native 미리보기 발표Microsoft TypeScript-Go GitHub 레포지토리  ","version":null,"tagName":"h3"},{"title":"기술 분석 및 리뷰​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#기술-분석-및-리뷰","content":" CTOL-KR: Microsoft TypeScript Go 성능 및 확장성 분석FastCampus: Microsoft TypeScript Go 프로젝트 인사이트Hacker News: TypeScript Native 논의  ","version":null,"tagName":"h3"},{"title":"관련 도구 및 프로젝트​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#관련-도구-및-프로젝트","content":" bel: Go 구조체에서 TypeScript 인터페이스 생성tygo: Go에서 TypeScript 정의 생성ts-readme: TypeScript 문서화 도구  ","version":null,"tagName":"h3"},{"title":"커뮤니티 반응​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#커뮤니티-반응","content":" Reddit: TypeScript Go 재작성 논의Twitter: TypeScript 공식 계정 발표디지털 부르주아: TypeScript Native 분석 ","version":null,"tagName":"h3"},{"title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","type":0,"sectionRef":"#","url":"/blog/oklch-color-space-web-design","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"왜 새로운 색상 모델이 필요할까?​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#왜-새로운-색상-모델이-필요할까","content":" 다음 두 색상을 보세요:  hsl(240, 100%, 50%) (파란색)hsl(60, 100%, 50%) (노란색)  HSL에서는 둘 다 밝기(L)가 50%로 동일하지만, 실제로는 노란색이 훨씬 밝게 보입니다. 이것이 바로 기존 색상 모델의 한계입니다.    OKLCH는 이런 문제를 해결하기 위해 인간의 시각 인지 방식에 맞게 설계된 색상 공간입니다.  ","version":null,"tagName":"h2"},{"title":"OKLCH 기본 개념​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#oklch-기본-개념","content":" OKLCH는 세 가지 요소로 구성됩니다:  요소\t의미\t범위\t설명L\tLightness (밝기)\t0-1\t0은 검정, 1은 흰색 C\tChroma (채도)\t0-0.4+\t0은 무채색, 높을수록 선명 H\tHue (색상)\t0-360\t색상환의 각도 (빨강=30°, 파랑=250°)  /* OKLCH 문법 */ color: oklch(L C H); /* 예시: 밝은 파란색 */ color: oklch(0.7 0.25 250);   ","version":null,"tagName":"h2"},{"title":"기존 색상 모델과의 비교​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#기존-색상-모델과의-비교","content":" ","version":null,"tagName":"h2"},{"title":"RGB vs HSL vs OKLCH​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#rgb-vs-hsl-vs-oklch","content":" /* 같은 빨간색을 다른 방식으로 표현 */ .red-rgb { color: rgb(255, 65, 54); } .red-hsl { color: hsl(4, 100%, 61%); } .red-oklch { color: oklch(0.63 0.26 29); }     핵심 차이점:  RGB: 기계 중심적, 직관적이지 않음HSL: 인간 친화적이지만 지각적으로 부정확OKLCH: 인간의 시각 인지와 일치하는 정확성  ","version":null,"tagName":"h3"},{"title":"OKLCH의 3가지 핵심 장점​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#oklch의-3가지-핵심-장점","content":" ","version":null,"tagName":"h2"},{"title":"1. 🎯 지각적 균일성 (Perceptual Uniformity)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#1--지각적-균일성-perceptual-uniformity","content":" 문제: HSL에서 밝기 50%인 모든 색상이 실제로는 다르게 보임해결: OKLCH에서 같은 L값은 실제로 같은 밝기로 인지됨  /* HSL: 같은 밝기(50%)지만 실제로는 다르게 보임 */ .hsl-colors { --yellow: hsl(60, 100%, 50%); /* 매우 밝게 보임 */ --blue: hsl(240, 100%, 50%); /* 상대적으로 어둡게 보임 */ } /* OKLCH: 실제로 같은 밝기로 인지됨 */ .oklch-colors { --yellow: oklch(0.9 0.2 90); /* 지각적으로 같은 밝기 */ --blue: oklch(0.9 0.2 250); /* 지각적으로 같은 밝기 */ }   실용적 이점:  ✅ 일관된 색상 팔레트 생성✅ 정확한 접근성 대비율 계산✅ 자연스러운 색상 애니메이션  ","version":null,"tagName":"h3"},{"title":"2. 🌈 넓은 색영역 지원 (Wide Gamut)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#2--넓은-색영역-지원-wide-gamut","content":" sRGB vs P3 색영역:  sRGB: 1990년대 표준, 제한적인 색상 범위P3: 현대 디스플레이 표준, 25% 더 넓은 색상 범위  /* sRGB 범위 내의 일반적인 빨간색 */ .normal-red { background: rgb(255, 0, 0); } /* P3 색영역을 활용한 더 생생한 빨간색 */ .vivid-red { background: oklch(0.6 0.35 30); /* sRGB 범위를 넘어서는 값 */ }     지원 기기:  iPhone 7 이후 모든 iPhone2016년 이후 MacBook Pro최신 Android 플래그십 기기고급 모니터 (DCI-P3, Adobe RGB 지원)  ","version":null,"tagName":"h3"},{"title":"3. 🎨 직관적인 색상 조작​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#3--직관적인-색상-조작","content":" OKLCH는 각 요소를 독립적으로 조절할 수 있어 디자인 시스템 구축이 쉽습니다:  :root { /* 기본 브랜드 색상 */ --brand-primary: oklch(0.6 0.25 250); /* 밝기 변형 (색상과 채도는 유지) */ --brand-light: oklch(0.8 0.25 250); --brand-dark: oklch(0.4 0.25 250); /* 채도 변형 (색상과 밝기는 유지) */ --brand-vibrant: oklch(0.6 0.35 250); --brand-muted: oklch(0.6 0.1 250); /* 색상 변형 (밝기와 채도는 유지) */ --brand-warm: oklch(0.6 0.25 30); /* 빨간색 계열 */ --brand-cool: oklch(0.6 0.25 200); /* 청록색 계열 */ }   ","version":null,"tagName":"h3"},{"title":"실전 활용 사례​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#실전-활용-사례","content":" ","version":null,"tagName":"h2"},{"title":"🎨 완벽한 색상 팔레트 만들기​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-완벽한-색상-팔레트-만들기","content":" /* 지각적으로 균일한 무지개 색상 */ .rainbow-palette { --red: oklch(0.65 0.25 30); --orange: oklch(0.65 0.25 60); --yellow: oklch(0.65 0.25 90); --green: oklch(0.65 0.25 140); --blue: oklch(0.65 0.25 250); --purple: oklch(0.65 0.25 320); }   결과: 모든 색상이 동일한 밝기와 채도로 느껴져서 조화로운 팔레트 완성  ","version":null,"tagName":"h3"},{"title":"🌓 다크/라이트 모드 전환​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-다크라이트-모드-전환","content":" :root { /* 라이트 모드 */ --text: oklch(0.2 0 0); /* 거의 검정 */ --background: oklch(0.98 0 0); /* 거의 흰색 */ --accent: oklch(0.6 0.25 250); /* 브랜드 블루 */ } @media (prefers-color-scheme: dark) { :root { /* 다크 모드: 밝기만 반전, 색상은 유지 */ --text: oklch(0.98 0 0); --background: oklch(0.15 0 0); --accent: oklch(0.7 0.25 250); /* 다크 모드에서는 조금 더 밝게 */ } }   ","version":null,"tagName":"h3"},{"title":"🎬 자연스러운 색상 애니메이션​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-자연스러운-색상-애니메이션","content":" .button { background: oklch(0.6 0.2 250); transition: background-color 0.3s ease; } .button:hover { /* 채도만 증가시켜서 자연스러운 강조 효과 */ background: oklch(0.6 0.3 250); } .button:active { /* 밝기를 줄여서 눌린 효과 */ background: oklch(0.5 0.3 250); }     ","version":null,"tagName":"h3"},{"title":"브라우저 지원 및 사용법​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#브라우저-지원-및-사용법","content":" ","version":null,"tagName":"h2"},{"title":"현재 지원 현황 (2025년 기준)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#현재-지원-현황-2025년-기준","content":" 브라우저\t지원 버전\t시장 점유율Chrome\t111+\t✅ 95%+ Safari\t15.4+\t✅ 95%+ Firefox\t113+\t✅ 90%+ Edge\t111+\t✅ 95%+  ","version":null,"tagName":"h3"},{"title":"안전한 사용법 (Fallback 제공)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#안전한-사용법-fallback-제공","content":" .element { /* 구형 브라우저용 fallback */ background: #3b82f6; /* 최신 브라우저용 OKLCH */ background: oklch(0.6 0.25 250); } /* 또는 @supports를 사용한 점진적 향상 */ @supports (color: oklch(0 0 0)) { .element { background: oklch(0.6 0.25 250); } }   ","version":null,"tagName":"h3"},{"title":"유용한 도구들​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#유용한-도구들","content":" ","version":null,"tagName":"h2"},{"title":"1. 🎨 OKLCH 색상 피커​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#1--oklch-색상-피커","content":" 직관적인 색상 선택 인터페이스실시간 RGB/HSL 변환접근성 대비율 확인  ","version":null,"tagName":"h3"},{"title":"2. 🔧 Colorjs.io​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#2--colorjsio","content":" 색상 변환 JavaScript 라이브러리다양한 색상 공간 지원색상 계산 및 조작 기능  ","version":null,"tagName":"h3"},{"title":"3. 📊 CSS 색상 변환기​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#3--css-색상-변환기","content":" 기존 색상을 OKLCH로 변환배치 변환 지원색상 팔레트 생성  ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"단계별 전환 방법​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#단계별-전환-방법","content":" 1단계: 주요 브랜드 색상부터 시작  /* 기존 */ --primary: #3b82f6; /* 변환 후 */ --primary: #3b82f6; /* fallback */ --primary: oklch(0.6 0.25 250); /* modern */   2단계: 색상 팔레트 체계화  /* 기존: 일관성 없는 색상들 */ --blue-100: #dbeafe; --blue-500: #3b82f6; --blue-900: #1e3a8a; /* 개선: OKLCH로 체계적인 팔레트 */ --blue-100: oklch(0.95 0.05 250); --blue-500: oklch(0.6 0.25 250); --blue-900: oklch(0.3 0.25 250);   3단계: 애니메이션 및 상호작용 개선  /* 더 자연스러운 hover 효과 */ .card:hover { background: oklch(from var(--card-bg) calc(l + 0.05) c h); }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#결론","content":" OKLCH는 웹 디자인의 색상 처리 방식을 근본적으로 개선하는 혁신적인 도구입니다:  ","version":null,"tagName":"h2"},{"title":"🎯 핵심 이점​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-핵심-이점","content":" 정확성: 인간의 시각 인지와 일치하는 색상 제어일관성: 지각적으로 균일한 색상 팔레트 생성미래성: 차세대 디스플레이 기술 완벽 지원효율성: 직관적인 색상 조작으로 개발 시간 단축  ","version":null,"tagName":"h3"},{"title":"🚀 지금 시작해야 하는 이유​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-지금-시작해야-하는-이유","content":" 광범위한 브라우저 지원: 이미 95% 이상의 최신 브라우저에서 지원점진적 도입 가능: fallback을 통해 안전하게 전환 가능경쟁 우위: 더 정교하고 아름다운 색상 디자인으로 차별화접근성 향상: WCAG 기준을 더 쉽게 충족  OKLCH는 단순한 트렌드가 아닌 웹 디자인의 새로운 표준입니다. 지금 시작해서 더 나은 사용자 경험을 만들어보세요.    ","version":null,"tagName":"h3"},{"title":"참고 자료​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#참고-자료","content":" DaleSeo - CSS에서 OKLCH 색상 사용하기Velog - CSS RGB, HSL 그리고 OklchEvil Martians - OKLCH in CSS: why quit RGB &amp; HSLOKLCH 공식 사이트CSS Color Module Level 4 명세 ","version":null,"tagName":"h2"},{"title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","type":0,"sectionRef":"#","url":"/blog/next-yak-nextjs-css-in-js","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"next-yak가 해결하는 문제​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#next-yak가-해결하는-문제","content":" 기존 CSS-in-JS 라이브러리들의 주요 문제점:  런타임 성능 오버헤드  스타일 생성과 주입이 런타임에 발생JavaScript 번들 크기 증가 (styled-components: ~40KB)초기 렌더링 지연과 hydration 성능 저하  Server-Side Rendering 복잡성  서버와 클라이언트 간 스타일 동기화 문제추가적인 설정과 보일러플레이트 코드 필요React Server Components와의 제한적 호환성  next-yak는 이러한 문제들을 빌드 타임 CSS 추출을 통해 근본적으로 해결합니다.  ","version":null,"tagName":"h2"},{"title":"핵심 특징​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#핵심-특징","content":" ","version":null,"tagName":"h2"},{"title":"1. Zero-runtime 아키텍처​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#1-zero-runtime-아키텍처","content":" 빌드 타임에 모든 스타일을 정적 CSS로 변환하여 런타임 오버헤드를 제거합니다:  개발 시 작성하는 코드 import { styled } from 'next-yak'; const Button = styled.button` background: #007bff; color: white; padding: 12px 24px; border-radius: 6px; border: none; cursor: pointer; &amp;:hover { background: #0056b3; } `;   빌드 후 생성되는 코드 const Button = ({ children, ...props }) =&gt; ( &lt;button className=&quot;button-abc123&quot; {...props}&gt; {children} &lt;/button&gt; );   생성되는 CSS 파일 .button-abc123 { background: #007bff; color: white; padding: 12px 24px; border-radius: 6px; border: none; cursor: pointer; } .button-abc123:hover { background: #0056b3; }   ","version":null,"tagName":"h3"},{"title":"2. React Server Components 완벽 지원​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#2-react-server-components-완벽-지원","content":" Next.js 13+의 App Router와 Server Components에서 추가 설정 없이 작동합니다:  app/components/ServerButton.tsx import { styled } from 'next-yak'; const ServerButton = styled.button` background: linear-gradient(45deg, #fe6b8b 30%, #ff8e53 90%); border: 0; border-radius: 8px; color: white; padding: 12px 24px; font-weight: 500; `; export default function Page() { return ( &lt;ServerButton&gt; 서버에서 렌더링되는 버튼 &lt;/ServerButton&gt; ); }   ","version":null,"tagName":"h3"},{"title":"3. 동적 스타일링 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#3-동적-스타일링-최적화","content":" props를 통한 동적 스타일링도 빌드 타임에 최적화됩니다:  동적 스타일링 예제 import { styled, css } from 'next-yak'; const Alert = styled.div&lt;{ $variant: 'success' | 'warning' | 'error'; $size?: 'small' | 'large'; }&gt;` padding: ${props =&gt; props.$size === 'small' ? '8px 12px' : '16px 24px'}; border-radius: 6px; font-weight: 500; ${props =&gt; { switch (props.$variant) { case 'success': return css` background: #d4edda; color: #155724; border: 1px solid #c3e6cb; `; case 'warning': return css` background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; `; case 'error': return css` background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; `; } }} `;   ","version":null,"tagName":"h3"},{"title":"설치 및 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#설치-및-설정","content":" ","version":null,"tagName":"h2"},{"title":"패키지 설치​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#패키지-설치","content":" npm install next-yak   ","version":null,"tagName":"h3"},{"title":"Next.js 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#nextjs-설정","content":" next.config.js 파일에 next-yak 플러그인을 추가합니다:  next.config.js const { withYak } = require('next-yak/withYak'); /** @type {import('next').NextConfig} */ const nextConfig = { // 기존 설정들... }; module.exports = withYak(nextConfig);   ","version":null,"tagName":"h3"},{"title":"TypeScript 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#typescript-설정","content":" TypeScript 프로젝트에서는 타입 정의를 추가합니다:  tsconfig.json { &quot;compilerOptions&quot;: { &quot;types&quot;: [&quot;next-yak&quot;] } }   ","version":null,"tagName":"h3"},{"title":"실무 활용 패턴​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#실무-활용-패턴","content":" ","version":null,"tagName":"h2"},{"title":"1. 컴포넌트 시스템 구축​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#1-컴포넌트-시스템-구축","content":" components/Button.tsx import { styled, css } from 'next-yak'; const sizes = { small: css` padding: 6px 12px; font-size: 14px; min-height: 32px; `, medium: css` padding: 8px 16px; font-size: 16px; min-height: 40px; `, large: css` padding: 12px 24px; font-size: 18px; min-height: 48px; `, }; const variants = { primary: css` background: #007bff; color: white; &amp;:hover:not(:disabled) { background: #0056b3; } `, outline: css` background: transparent; color: #007bff; border: 1px solid #007bff; &amp;:hover:not(:disabled) { background: #007bff; color: white; } `, }; export const Button = styled.button&lt;{ $size?: keyof typeof sizes; $variant?: keyof typeof variants; }&gt;` display: inline-flex; align-items: center; justify-content: center; border: none; border-radius: 6px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; &amp;:disabled { opacity: 0.6; cursor: not-allowed; } ${props =&gt; sizes[props.$size || 'medium']} ${props =&gt; variants[props.$variant || 'primary']} `;   ","version":null,"tagName":"h3"},{"title":"2. 반응형 레이아웃​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#2-반응형-레이아웃","content":" components/Grid.tsx import { styled } from 'next-yak'; export const Grid = styled.div&lt;{ $columns?: number }&gt;` display: grid; gap: 20px; padding: 20px; /* 모바일 */ grid-template-columns: 1fr; /* 태블릿 */ @media (min-width: 768px) { grid-template-columns: repeat(2, 1fr); gap: 30px; } /* 데스크톱 */ @media (min-width: 1024px) { grid-template-columns: repeat(${props =&gt; props.$columns || 3}, 1fr); gap: 40px; } `; export const GridItem = styled.div` background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: transform 0.2s ease; &amp;:hover { transform: translateY(-4px); } `;   ","version":null,"tagName":"h3"},{"title":"성능 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#성능-최적화","content":" ","version":null,"tagName":"h2"},{"title":"빌드 설정 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#빌드-설정-최적화","content":" next.config.js const { withYak } = require('next-yak/withYak'); const isDev = process.env.NODE_ENV === 'development'; const nextConfig = { // 기존 설정들... }; module.exports = withYak(nextConfig, { cssOptimization: { // 프로덕션에서만 최적화 활성화 minify: !isDev, removeDuplicates: !isDev, purgeUnused: !isDev, }, });   ","version":null,"tagName":"h3"},{"title":"성능 측정 결과​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#성능-측정-결과","content":" 실제 프로덕션 환경에서 측정한 성능 개선 결과:  메트릭\tstyled-components\tnext-yak\t개선율JavaScript 번들 크기\t245KB\t198KB\t19% 감소 First Contentful Paint\t1.2s\t0.9s\t25% 향상 Time to Interactive\t2.8s\t2.3s\t18% 향상 Cumulative Layout Shift\t0.15\t0.08\t47% 향상  ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"styled-components에서 마이그레이션​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#styled-components에서-마이그레이션","content":" 기존 styled-components 코드를 next-yak로 마이그레이션하는 방법:  // Before (styled-components) import styled from 'styled-components'; const Button = styled.button` background: ${props =&gt; props.primary ? 'blue' : 'white'}; color: ${props =&gt; props.primary ? 'white' : 'blue'}; `; // 사용법: &lt;Button primary&gt;Click me&lt;/Button&gt;   // After (next-yak) import { styled } from 'next-yak'; const Button = styled.button&lt;{ $primary?: boolean }&gt;` background: ${props =&gt; props.$primary ? 'blue' : 'white'}; color: ${props =&gt; props.$primary ? 'white' : 'blue'}; `; // 사용법: &lt;Button $primary&gt;Click me&lt;/Button&gt;   주요 변경사항:  props 이름에 $ 접두사 추가 (DOM에 전달되지 않는 props)import 구문 변경기본 API는 동일하게 유지  ","version":null,"tagName":"h3"},{"title":"점진적 마이그레이션 전략​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#점진적-마이그레이션-전략","content":" 혼합 사용 예제 // 기존 컴포넌트와 새 컴포넌트를 함께 사용 import StyledButton from './legacy/StyledButton'; // styled-components import { Button } from './components/Button'; // next-yak export default function MixedPage() { return ( &lt;div&gt; &lt;StyledButton&gt;기존 버튼&lt;/StyledButton&gt; &lt;Button $variant=&quot;primary&quot;&gt;새 버튼&lt;/Button&gt; &lt;/div&gt; ); }   ","version":null,"tagName":"h3"},{"title":"트러블슈팅​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#트러블슈팅","content":" ","version":null,"tagName":"h2"},{"title":"자주 발생하는 문제​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#자주-발생하는-문제","content":" 빌드 에러 해결  # 캐시 클리어 후 재설치 rm -rf .next node_modules package-lock.json npm install   타입 에러 해결  // 명시적 타입 정의로 해결 interface ButtonProps { $variant: 'primary' | 'secondary'; $size: 'small' | 'medium' | 'large'; } const Button = styled.button&lt;ButtonProps&gt;` /* 스타일 정의 */ `;   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#결론","content":" next-yak는 Next.js 프로젝트에서 CSS-in-JS의 성능 문제를 근본적으로 해결하는 실용적인 솔루션입니다.  핵심 이점:  성능: 런타임 오버헤드 완전 제거로 20% 이상 성능 향상호환성: React Server Components 완벽 지원개발자 경험: 기존 styled-components와 동일한 API확장성: 대규모 프로젝트에서도 안정적인 성능  특히 성능이 중요한 프로덕션 환경에서 기존 CSS-in-JS 라이브러리의 한계를 뛰어넘는 탁월한 대안입니다. 점진적 마이그레이션이 가능하므로 기존 프로젝트에서도 부담 없이 도입할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#참고-자료","content":" next-yak 공식 문서GitHub 저장소Next.js App Router 가이드React Server Components 문서 ","version":null,"tagName":"h2"},{"title":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","type":0,"sectionRef":"#","url":"/blog/shell-script-no-such-file-directory-fix","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"문제 상황​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#문제-상황","content":" Linux, WSL, Git Bash 등에서 Windows에서 작성한 스크립트를 실행할 때 다음과 같은 오류가 발생합니다.  ","version":null,"tagName":"h2"},{"title":"에러 메시지​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#에러-메시지","content":" line 1: #!/bin/sh: No such file or directory   또는  line 1: #!/bin/bash: No such file or directory   ","version":null,"tagName":"h3"},{"title":"문제 진단 방법​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#문제-진단-방법","content":" 파일의 줄바꿈 형식을 확인하려면 다음 명령어를 사용하세요:  # 파일의 줄바꿈 문자를 시각적으로 확인 cat -v script.sh # 16진수로 파일 내용 확인 hexdump -C script.sh | head # od 명령어로 8진수 확인 od -bc script.sh   Windows 스타일 줄바꿈이 있다면 ^M 문자나 \\r\\n 시퀀스를 볼 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"원인 분석​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#원인-분석","content":" ","version":null,"tagName":"h2"},{"title":"운영체제별 줄바꿈 방식​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#운영체제별-줄바꿈-방식","content":" 운영체제\t줄바꿈 문자\t16진수 표현\t설명Windows/DOS\t\\r\\n\t0D 0A\tCarriage Return + Line Feed Unix/Linux\t\\n\t0A\tLine Feed만 사용 Mac (구버전)\t\\r\t0D\tCarriage Return만 사용 Mac (현재)\t\\n\t0A\tUnix와 동일  ","version":null,"tagName":"h3"},{"title":"왜 오류가 발생하는가?​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#왜-오류가-발생하는가","content":" Linux 쉘에서 Windows 스타일의 줄바꿈이 포함된 스크립트를 실행하면, shebang(#!/bin/bash) 뒤에 보이지 않는 \\r 문자가 붙어서 /bin/bash\\r라는 존재하지 않는 경로를 찾게 됩니다.  주의사항: 이 문제는 스크립트 파일뿐만 아니라 설정 파일, 데이터 파일에서도 발생할 수 있습니다. 특히 CSV 파일이나 설정 파일을 처리할 때 예상치 못한 동작을 일으킬 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"해결방법​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#해결방법","content":" ","version":null,"tagName":"h2"},{"title":"1. dos2unix 명령어 사용 (권장)​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#1-dos2unix-명령어-사용-권장","content":" 가장 간단하고 안전한 방법입니다.  # dos2unix 설치 # Ubuntu/Debian sudo apt-get install dos2unix # CentOS/RHEL/Fedora sudo yum install dos2unix # 또는 최신 버전에서 sudo dnf install dos2unix # 파일 변환 dos2unix script.sh # 원본 파일 백업하면서 변환 dos2unix -b script.sh # 여러 파일 한번에 변환 dos2unix *.sh # 재귀적으로 모든 .sh 파일 변환 find . -name &quot;*.sh&quot; -type f -exec dos2unix {} \\;   ","version":null,"tagName":"h3"},{"title":"2. sed 명령어 사용​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#2-sed-명령어-사용","content":" # 기본 사용법 sed -i 's/\\r$//' script.sh # 원본 파일 백업하면서 변환 sed -i.bak 's/\\r$//' script.sh # 새 파일로 출력 sed 's/\\r$//' script.sh &gt; script_fixed.sh # 여러 파일 처리 sed -i 's/\\r$//' *.sh   ","version":null,"tagName":"h3"},{"title":"3. tr 명령어 사용​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#3-tr-명령어-사용","content":" # 캐리지 리턴 문자 제거 tr -d '\\r' &lt; script.sh &gt; script_fixed.sh # 또는 cat script.sh | tr -d '\\r' &gt; script_fixed.sh # 8진수 표현 사용 tr -d '\\015' &lt; script.sh &gt; script_fixed.sh   ","version":null,"tagName":"h3"},{"title":"4. vim/vi 에디터에서 직접 변환​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#4-vimvi-에디터에서-직접-변환","content":" # vim으로 파일 열기 vim script.sh # 명령 모드에서 다음 명령 실행 :set ff=unix :wq # 또는 한 번에 :set fileformat=unix | wq   ","version":null,"tagName":"h3"},{"title":"5. awk 명령어 사용​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#5-awk-명령어-사용","content":" # awk로 줄바꿈 변환 awk '{ sub(/\\r$/, &quot;&quot;); print }' script.sh &gt; script_fixed.sh # 또는 awk '{ gsub(/\\r/, &quot;&quot;); print }' script.sh &gt; script_fixed.sh   ","version":null,"tagName":"h3"},{"title":"6. Perl 원라이너 사용​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#6-perl-원라이너-사용","content":" # Perl로 in-place 변환 perl -pi -e 's/\\r\\n/\\n/g' script.sh # 백업 파일 생성하면서 변환 perl -pi.bak -e 's/\\r\\n/\\n/g' script.sh   ","version":null,"tagName":"h3"},{"title":"예방 방법​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#예방-방법","content":" ","version":null,"tagName":"h2"},{"title":"1. Git 설정으로 자동 변환​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#1-git-설정으로-자동-변환","content":" # Windows에서: 체크아웃 시 CRLF로, 커밋 시 LF로 자동 변환 git config --global core.autocrlf true # Linux/Mac에서: 커밋 시 CRLF를 LF로 변환, 체크아웃 시 변환 안함 git config --global core.autocrlf input # 모든 플랫폼에서 LF만 사용 (권장) git config --global core.autocrlf false git config --global core.eol lf   ","version":null,"tagName":"h3"},{"title":"2. .gitattributes 파일 설정​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#2-gitattributes-파일-설정","content":" 프로젝트 루트에 .gitattributes 파일을 생성하여 파일별로 줄바꿈 설정:  # 모든 텍스트 파일은 LF 사용 * text=auto eol=lf # 스크립트 파일은 반드시 LF 사용 *.sh text eol=lf *.bash text eol=lf # Windows 배치 파일은 CRLF 사용 *.bat text eol=crlf *.cmd text eol=crlf # 바이너리 파일은 변환하지 않음 *.png binary *.jpg binary *.exe binary   ","version":null,"tagName":"h3"},{"title":"3. 에디터 설정​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#3-에디터-설정","content":" VS Code​  { &quot;files.eol&quot;: &quot;\\n&quot;, &quot;files.insertFinalNewline&quot;: true, &quot;files.trimFinalNewlines&quot;: true }   Sublime Text​  View → Line Endings → Unix  Notepad++​  편집 → EOL 변경 → Unix (LF)  Atom​  Packages → Line Ending Selector → LF  ","version":null,"tagName":"h3"},{"title":"4. EditorConfig 사용​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#4-editorconfig-사용","content":" 프로젝트 루트에 .editorconfig 파일 생성:  root = true [*] end_of_line = lf insert_final_newline = true trim_trailing_whitespace = true [*.{sh,bash}] end_of_line = lf   ","version":null,"tagName":"h3"},{"title":"고급 활용법​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#고급-활용법","content":" ","version":null,"tagName":"h2"},{"title":"대량 파일 처리​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#대량-파일-처리","content":" # 디렉토리 전체의 스크립트 파일 변환 find /path/to/scripts -name &quot;*.sh&quot; -type f -print0 | xargs -0 dos2unix # 특정 확장자 파일들 일괄 변환 find . -type f \\( -name &quot;*.sh&quot; -o -name &quot;*.bash&quot; -o -name &quot;*.py&quot; \\) -exec dos2unix {} + # 변환 전 백업 생성 find . -name &quot;*.sh&quot; -type f -exec cp {} {}.bak \\; -exec dos2unix {} \\;   ","version":null,"tagName":"h3"},{"title":"스크립트로 자동화​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#스크립트로-자동화","content":" #!/bin/bash # fix_line_endings.sh # 변환할 파일 확장자 목록 EXTENSIONS=(&quot;sh&quot; &quot;bash&quot; &quot;py&quot; &quot;pl&quot; &quot;rb&quot;) for ext in &quot;${EXTENSIONS[@]}&quot;; do echo &quot;Converting *.${ext} files...&quot; find . -name &quot;*.${ext}&quot; -type f -exec dos2unix {} \\; done echo &quot;Line ending conversion completed!&quot;   ","version":null,"tagName":"h3"},{"title":"파일 형식 확인 스크립트​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#파일-형식-확인-스크립트","content":" #!/bin/bash # check_line_endings.sh check_file() { local file=&quot;$1&quot; if file &quot;$file&quot; | grep -q &quot;CRLF&quot;; then echo &quot;DOS/Windows: $file&quot; elif file &quot;$file&quot; | grep -q &quot;CR&quot;; then echo &quot;Mac (old): $file&quot; else echo &quot;Unix/Linux: $file&quot; fi } if [ $# -eq 0 ]; then echo &quot;Usage: $0 &lt;file1&gt; [file2] ...&quot; exit 1 fi for file in &quot;$@&quot;; do if [ -f &quot;$file&quot; ]; then check_file &quot;$file&quot; else echo &quot;File not found: $file&quot; fi done   ","version":null,"tagName":"h3"},{"title":"문제 해결 팁​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#문제-해결-팁","content":" ","version":null,"tagName":"h2"},{"title":"1. 권한 문제 해결​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#1-권한-문제-해결","content":" # 파일 권한 확인 ls -la script.sh # 실행 권한 추가 chmod +x script.sh # 소유자 변경 (필요한 경우) sudo chown $USER:$USER script.sh   ","version":null,"tagName":"h3"},{"title":"2. 숨겨진 문자 확인​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#2-숨겨진-문자-확인","content":" # 모든 비출력 문자 표시 cat -A script.sh # 줄 번호와 함께 표시 cat -n script.sh | head -5   ","version":null,"tagName":"h3"},{"title":"3. 대용량 파일 처리​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#3-대용량-파일-처리","content":" # 큰 파일의 경우 메모리 효율적인 방법 sed 's/\\r$//' large_script.sh &gt; temp_file &amp;&amp; mv temp_file large_script.sh   ","version":null,"tagName":"h3"},{"title":"실무 팁​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#실무-팁","content":" 팀 프로젝트에서는 .gitattributes와 .editorconfig 파일을 반드시 설정하세요CI/CD 파이프라인에서 스크립트 실행 전 자동으로 줄바꿈을 확인하는 단계를 추가하는 것이 좋습니다Windows에서 개발할 때는 WSL을 사용하여 Linux 환경에서 테스트해보세요  ","version":null,"tagName":"h3"},{"title":"참고 자료​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#참고-자료","content":" dos2unix 공식 문서Git 줄바꿈 설정 가이드EditorConfig 공식 사이트Atlassian 기술 문서 ","version":null,"tagName":"h2"},{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","type":0,"sectionRef":"#","url":"/blog/supabase-complete-guide-firebase-alternative","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"Supabase란 무엇인가?​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#supabase란-무엇인가","content":" ","version":null,"tagName":"h2"},{"title":"핵심 개념과 철학​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#핵심-개념과-철학","content":" Supabase는 2020년에 창립된 회사로, **&quot;The Open Source Firebase Alternative&quot;**라는 명확한 비전을 가지고 시작되었습니다. 하지만 단순한 Firebase 클론이 아닌, PostgreSQL의 강력함을 기반으로 한 더 나은 백엔드 솔루션을 제공하는 것이 목표입니다.  Supabase의 핵심 철학​  오픈소스 우선: 모든 핵심 기능이 오픈소스로 제공SQL 네이티브: PostgreSQL의 모든 기능을 그대로 활용개발자 경험 최우선: 직관적이고 강력한 API 제공확장성: 스타트업부터 엔터프라이즈까지 모든 규모 지원  ","version":null,"tagName":"h3"},{"title":"Firebase와의 차이점​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#firebase와의-차이점","content":" 기능\tFirebase\tSupabase데이터베이스\tNoSQL (Firestore)\tPostgreSQL (관계형) 쿼리 언어\t제한적 쿼리\t완전한 SQL 지원 실시간 기능\t실시간 리스너\tPostgreSQL 실시간 구독 인증\tFirebase Auth\t자체 인증 + 외부 제공자 스토리지\tCloud Storage\tS3 호환 스토리지 함수\tCloud Functions\tEdge Functions (Deno) 오픈소스\t부분적\t완전한 오픈소스 벤더 락인\t높음\t낮음 (PostgreSQL 표준)  ","version":null,"tagName":"h3"},{"title":"주요 기능 심화 분석​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#주요-기능-심화-분석","content":" ","version":null,"tagName":"h2"},{"title":"1. PostgreSQL 기반 데이터베이스​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#1-postgresql-기반-데이터베이스","content":" Supabase의 가장 큰 강점은 PostgreSQL을 그대로 사용한다는 점입니다. 이는 단순히 데이터베이스를 제공하는 것을 넘어서, SQL의 모든 강력한 기능을 웹 애플리케이션에서 직접 활용할 수 있게 해줍니다.  PostgreSQL의 고급 기능 활용​  복잡한 쿼리 예시 -- 복잡한 조인과 집계 쿼리 SELECT u.name, COUNT(p.id) as post_count, AVG(p.likes) as avg_likes, RANK() OVER (ORDER BY COUNT(p.id) DESC) as author_rank FROM users u LEFT JOIN posts p ON u.id = p.author_id WHERE u.created_at &gt;= '2024-01-01' GROUP BY u.id, u.name HAVING COUNT(p.id) &gt; 5 ORDER BY author_rank; -- JSON 필드 쿼리 (PostgreSQL의 강력한 JSON 지원) SELECT * FROM products WHERE metadata-&gt;&gt;'category' = 'electronics' AND (metadata-&gt;'specifications'-&gt;&gt;'ram')::int &gt;= 8; -- 전문 검색 (Full-text Search) SELECT * FROM articles WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', 'javascript performance optimization');   Row Level Security (RLS)​  Supabase의 보안 모델은 PostgreSQL의 Row Level Security를 기반으로 합니다. 이를 통해 데이터베이스 레벨에서 세밀한 권한 제어가 가능합니다.  RLS 정책 설정 -- 사용자는 자신의 게시물만 볼 수 있도록 설정 CREATE POLICY &quot;Users can view own posts&quot; ON posts FOR SELECT USING (auth.uid() = user_id); -- 관리자는 모든 게시물을 볼 수 있도록 설정 CREATE POLICY &quot;Admins can view all posts&quot; ON posts FOR SELECT USING ( auth.jwt() -&gt;&gt; 'role' = 'admin' ); -- 게시물 작성자만 수정 가능 CREATE POLICY &quot;Users can update own posts&quot; ON posts FOR UPDATE USING (auth.uid() = user_id);   ","version":null,"tagName":"h3"},{"title":"2. 실시간 기능 (Realtime)​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#2-실시간-기능-realtime","content":" Supabase의 실시간 기능은 PostgreSQL의 LISTEN/NOTIFY 메커니즘을 웹소켓으로 확장한 혁신적인 구현입니다.  실시간 구독 구현​  lib/realtime.ts import { createClient } from '@supabase/supabase-js' const supabase = createClient( process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY! ) // 특정 테이블의 모든 변경사항 실시간 구독 const subscription = supabase .channel('public:posts') .on('postgres_changes', { event: '*', // INSERT, UPDATE, DELETE 모든 이벤트 schema: 'public', table: 'posts' }, (payload) =&gt; { console.log('Change received!', payload) // 실시간으로 UI 업데이트 handlePostChange(payload) }) .subscribe() // 특정 조건에 맞는 데이터만 구독 const filteredSubscription = supabase .channel('public:posts:author_id=eq.123') .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'posts', filter: 'author_id=eq.123' }, (payload) =&gt; { console.log('New post from author 123:', payload.new) }) .subscribe() // Presence 기능으로 온라인 사용자 추적 const presenceChannel = supabase.channel('online-users', { config: { presence: { key: user.id, }, }, }) presenceChannel .on('presence', { event: 'sync' }, () =&gt; { const state = presenceChannel.presenceState() console.log('Online users:', Object.keys(state)) }) .on('presence', { event: 'join' }, ({ key, newPresences }) =&gt; { console.log('User joined:', key, newPresences) }) .on('presence', { event: 'leave' }, ({ key, leftPresences }) =&gt; { console.log('User left:', key, leftPresences) }) .subscribe() // 사용자 온라인 상태 전송 presenceChannel.track({ user_id: user.id, username: user.username, last_seen: new Date().toISOString() })   ","version":null,"tagName":"h3"},{"title":"3. 인증 시스템 (Auth)​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#3-인증-시스템-auth","content":" Supabase Auth는 JWT 기반의 현대적인 인증 시스템으로, 다양한 인증 방식을 지원합니다.  이메일/비밀번호 인증​  lib/auth.ts // 회원가입 const { data, error } = await supabase.auth.signUp({ email: 'user@example.com', password: 'securepassword123', options: { data: { first_name: 'John', last_name: 'Doe', age: 27, } } }) // 로그인 const { data, error } = await supabase.auth.signInWithPassword({ email: 'user@example.com', password: 'securepassword123' }) // 로그아웃 const { error } = await supabase.auth.signOut() // 현재 사용자 정보 가져오기 const { data: { user } } = await supabase.auth.getUser() // 사용자 정보 업데이트 const { data, error } = await supabase.auth.updateUser({ data: { first_name: 'Jane', age: 28 } })   소셜 로그인​  components/SocialLogin.tsx // Google 로그인 const { data, error } = await supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: 'https://yourapp.com/dashboard', scopes: 'profile email' } }) // GitHub 로그인 const { data, error } = await supabase.auth.signInWithOAuth({ provider: 'github' }) // 다중 제공자 지원 const providers = [ 'google', 'github', 'apple', 'azure', 'bitbucket', 'discord', 'facebook', 'figma', 'gitlab', 'linkedin', 'notion', 'slack', 'spotify', 'twitch', 'twitter', 'workos' ]   인증 상태 관리​  hooks/useAuth.ts // React에서 인증 상태 관리 import { useEffect, useState } from 'react' import type { User } from '@supabase/supabase-js' function useAuth() { const [user, setUser] = useState&lt;User | null&gt;(null) const [loading, setLoading] = useState(true) useEffect(() =&gt; { // 초기 세션 가져오기 const getInitialSession = async () =&gt; { const { data: { session } } = await supabase.auth.getSession() setUser(session?.user ?? null) setLoading(false) } getInitialSession() // 인증 상태 변경 리스너 const { data: { subscription } } = supabase.auth.onAuthStateChange( (event, session) =&gt; { setUser(session?.user ?? null) setLoading(false) } ) return () =&gt; subscription.unsubscribe() }, []) return { user, loading } } // 사용 예시 function App() { const { user, loading } = useAuth() if (loading) return &lt;div&gt;Loading...&lt;/div&gt; if (!user) return &lt;LoginForm /&gt; return &lt;Dashboard user={user} /&gt; }   ","version":null,"tagName":"h3"},{"title":"4. 스토리지 (Storage)​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#4-스토리지-storage","content":" Supabase Storage는 S3 호환 객체 스토리지로, 파일 업로드, 다운로드, 변환 기능을 제공합니다.  파일 업로드 및 관리​  lib/storage.ts // 파일 업로드 const uploadFile = async (file: File) =&gt; { const fileExt = file.name.split('.').pop() const fileName = `${Date.now()}.${fileExt}` const filePath = `uploads/${fileName}` const { data, error } = await supabase.storage .from('public-files') .upload(filePath, file, { cacheControl: '3600', upsert: false }) if (error) { console.error('Upload error:', error) return null } // 업로드된 파일의 공개 URL 가져오기 const { data: { publicUrl } } = supabase.storage .from('public-files') .getPublicUrl(filePath) return publicUrl } // 이미지 변환 및 최적화 const getOptimizedImageUrl = (path: string, options: { width?: number height?: number quality?: number format?: 'webp' | 'jpeg' | 'png' } = {}) =&gt; { const { data } = supabase.storage .from('images') .getPublicUrl(path, { transform: { width: options.width || 800, height: options.height || 600, resize: 'cover', format: options.format || 'webp', quality: options.quality || 80 } }) return data.publicUrl } // 파일 다운로드 const downloadFile = async (path: string) =&gt; { const { data, error } = await supabase.storage .from('private-files') .download(path) if (error) { console.error('Download error:', error) return null } // Blob을 URL로 변환 const url = URL.createObjectURL(data) return url } // 파일 삭제 const deleteFile = async (path: string) =&gt; { const { error } = await supabase.storage .from('public-files') .remove([path]) return !error }   보안 및 권한 관리​  스토리지 RLS 정책 -- 스토리지 RLS 정책 설정 -- 사용자는 자신의 폴더에만 업로드 가능 CREATE POLICY &quot;Users can upload to own folder&quot; ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'user-files' AND auth.uid()::text = (storage.foldername(name))[1] ); -- 사용자는 자신의 파일만 볼 수 있음 CREATE POLICY &quot;Users can view own files&quot; ON storage.objects FOR SELECT USING ( bucket_id = 'user-files' AND auth.uid()::text = (storage.foldername(name))[1] );   ","version":null,"tagName":"h3"},{"title":"5. Edge Functions​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#5-edge-functions","content":" Supabase Edge Functions는 Deno 런타임을 기반으로 하는 서버리스 함수로, 전 세계 엣지 로케이션에서 실행됩니다.  Edge Function 예시​  supabase/functions/send-email/index.ts import { serve } from &quot;https://deno.land/std@0.168.0/http/server.ts&quot; import { createClient } from 'https://esm.sh/@supabase/supabase-js@2' const corsHeaders = { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type', } serve(async (req) =&gt; { if (req.method === 'OPTIONS') { return new Response('ok', { headers: corsHeaders }) } try { const { to, subject, html } = await req.json() // 이메일 발송 로직 const response = await fetch('https://api.resend.com/emails', { method: 'POST', headers: { 'Authorization': `Bearer ${Deno.env.get('RESEND_API_KEY')}`, 'Content-Type': 'application/json', }, body: JSON.stringify({ from: 'noreply@yourapp.com', to, subject, html, }), }) const result = await response.json() return new Response( JSON.stringify(result), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 200 } ) } catch (error) { return new Response( JSON.stringify({ error: error.message }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 } ) } })   클라이언트에서 Edge Function 호출​  lib/functions.ts // 클라이언트에서 Edge Function 호출 const sendEmail = async (emailData: { to: string subject: string html: string }) =&gt; { const { data, error } = await supabase.functions.invoke('send-email', { body: emailData }) if (error) { console.error('Function error:', error) return false } return data } // 사용 예시 const handleSendWelcomeEmail = async (userEmail: string, userName: string) =&gt; { const result = await sendEmail({ to: userEmail, subject: '환영합니다!', html: ` &lt;h1&gt;안녕하세요, ${userName}님!&lt;/h1&gt; &lt;p&gt;회원가입을 축하드립니다.&lt;/p&gt; ` }) if (result) { console.log('이메일이 성공적으로 발송되었습니다.') } }   ","version":null,"tagName":"h3"},{"title":"실제 프로젝트 구현 예시​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#실제-프로젝트-구현-예시","content":" ","version":null,"tagName":"h2"},{"title":"블로그 플랫폼 구축​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#블로그-플랫폼-구축","content":" 실제 프로젝트 예시로 Supabase를 활용한 블로그 플랫폼을 구축해보겠습니다.  데이터베이스 스키마 설계​  database/schema.sql -- 사용자 프로필 테이블 CREATE TABLE profiles ( id UUID REFERENCES auth.users(id) PRIMARY KEY, username TEXT UNIQUE NOT NULL, full_name TEXT, bio TEXT, avatar_url TEXT, website TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() ); -- 블로그 포스트 테이블 CREATE TABLE posts ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY, title TEXT NOT NULL, slug TEXT UNIQUE NOT NULL, content TEXT NOT NULL, excerpt TEXT, featured_image TEXT, author_id UUID REFERENCES profiles(id) NOT NULL, published BOOLEAN DEFAULT FALSE, published_at TIMESTAMP WITH TIME ZONE, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() ); -- 댓글 테이블 CREATE TABLE comments ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY, post_id UUID REFERENCES posts(id) ON DELETE CASCADE, author_id UUID REFERENCES profiles(id), content TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() ); -- 좋아요 테이블 CREATE TABLE likes ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY, post_id UUID REFERENCES posts(id) ON DELETE CASCADE, user_id UUID REFERENCES profiles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), UNIQUE(post_id, user_id) ); -- RLS 정책 설정 ALTER TABLE profiles ENABLE ROW LEVEL SECURITY; ALTER TABLE posts ENABLE ROW LEVEL SECURITY; ALTER TABLE comments ENABLE ROW LEVEL SECURITY; ALTER TABLE likes ENABLE ROW LEVEL SECURITY; -- 프로필 정책 CREATE POLICY &quot;Public profiles are viewable by everyone&quot; ON profiles FOR SELECT USING (true); CREATE POLICY &quot;Users can update own profile&quot; ON profiles FOR UPDATE USING (auth.uid() = id); -- 포스트 정책 CREATE POLICY &quot;Published posts are viewable by everyone&quot; ON posts FOR SELECT USING (published = true); CREATE POLICY &quot;Authors can view own posts&quot; ON posts FOR SELECT USING (auth.uid() = author_id); CREATE POLICY &quot;Authors can create posts&quot; ON posts FOR INSERT WITH CHECK (auth.uid() = author_id); CREATE POLICY &quot;Authors can update own posts&quot; ON posts FOR UPDATE USING (auth.uid() = author_id);   React 컴포넌트 구현​  types/database.types.ts // types/database.types.ts export interface Profile { id: string username: string full_name?: string bio?: string avatar_url?: string website?: string } export interface Post { id: string title: string slug: string content: string excerpt?: string featured_image?: string author_id: string published: boolean published_at?: string created_at: string updated_at: string profiles?: Profile likes_count?: number comments_count?: number }   hooks/usePosts.ts // hooks/usePosts.ts import { useState, useEffect } from 'react' import { supabase } from '../lib/supabase' export function usePosts() { const [posts, setPosts] = useState&lt;Post[]&gt;([]) const [loading, setLoading] = useState(true) useEffect(() =&gt; { const fetchPosts = async () =&gt; { const { data, error } = await supabase .from('posts') .select(` *, profiles (username, full_name, avatar_url), likes (count), comments (count) `) .eq('published', true) .order('published_at', { ascending: false }) if (error) { console.error('Error fetching posts:', error) } else { setPosts(data || []) } setLoading(false) } fetchPosts() // 실시간 구독 const subscription = supabase .channel('public:posts') .on('postgres_changes', { event: '*', schema: 'public', table: 'posts', filter: 'published=eq.true' }, () =&gt; { fetchPosts() // 변경사항 발생 시 다시 fetch }) .subscribe() return () =&gt; { subscription.unsubscribe() } }, []) return { posts, loading } }   components/PostCard.tsx // components/PostCard.tsx interface PostCardProps { post: Post } export function PostCard({ post }: PostCardProps) { const [liked, setLiked] = useState(false) const [likesCount, setLikesCount] = useState(post.likes_count || 0) const handleLike = async () =&gt; { const { data: { user } } = await supabase.auth.getUser() if (!user) return if (liked) { // 좋아요 취소 await supabase .from('likes') .delete() .eq('post_id', post.id) .eq('user_id', user.id) setLiked(false) setLikesCount(prev =&gt; prev - 1) } else { // 좋아요 추가 await supabase .from('likes') .insert({ post_id: post.id, user_id: user.id }) setLiked(true) setLikesCount(prev =&gt; prev + 1) } } return ( &lt;article className=&quot;bg-white rounded-lg shadow-md overflow-hidden&quot;&gt; {post.featured_image &amp;&amp; ( &lt;img src={post.featured_image} alt={post.title} className=&quot;w-full h-48 object-cover&quot; /&gt; )} &lt;div className=&quot;p-6&quot;&gt; &lt;h2 className=&quot;text-xl font-bold mb-2&quot;&gt; &lt;Link href={`/posts/${post.slug}`}&gt; {post.title} &lt;/Link&gt; &lt;/h2&gt; {post.excerpt &amp;&amp; ( &lt;p className=&quot;text-gray-600 mb-4&quot;&gt;{post.excerpt}&lt;/p&gt; )} &lt;div className=&quot;flex items-center justify-between&quot;&gt; &lt;div className=&quot;flex items-center space-x-2&quot;&gt; &lt;img src={post.profiles?.avatar_url || '/default-avatar.png'} alt={post.profiles?.username} className=&quot;w-8 h-8 rounded-full&quot; /&gt; &lt;span className=&quot;text-sm text-gray-700&quot;&gt; {post.profiles?.full_name || post.profiles?.username} &lt;/span&gt; &lt;/div&gt; &lt;button onClick={handleLike} className={`flex items-center space-x-1 ${ liked ? 'text-red-500' : 'text-gray-500' }`} &gt; &lt;HeartIcon className=&quot;w-5 h-5&quot; fill={liked ? 'currentColor' : 'none'} /&gt; &lt;span&gt;{likesCount}&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; ) }   ","version":null,"tagName":"h3"},{"title":"성능 최적화 전략​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#성능-최적화-전략","content":" ","version":null,"tagName":"h2"},{"title":"데이터베이스 최적화​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#데이터베이스-최적화","content":" database/indexes.sql -- 성능 최적화를 위한 인덱스 생성 CREATE INDEX idx_posts_author_published ON posts(author_id, published); CREATE INDEX idx_posts_published_at ON posts(published_at DESC) WHERE published = true; CREATE INDEX idx_posts_slug ON posts(slug); CREATE INDEX idx_comments_post_id ON comments(post_id); CREATE INDEX idx_likes_post_user ON likes(post_id, user_id); -- 전문 검색을 위한 인덱스 CREATE INDEX idx_posts_search ON posts USING gin(to_tsvector('english', title || ' ' || content));   ","version":null,"tagName":"h3"},{"title":"쿼리 최적화​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#쿼리-최적화","content":" lib/optimized-queries.ts // 페이지네이션과 함께 최적화된 쿼리 const getPostsWithPagination = async (page: number = 1, limit: number = 10) =&gt; { const offset = (page - 1) * limit const { data, error, count } = await supabase .from('posts') .select(` id, title, excerpt, published_at, slug, profiles!inner(username, avatar_url) `, { count: 'exact' }) .eq('published', true) .order('published_at', { ascending: false }) .range(offset, offset + limit - 1) return { posts: data || [], totalCount: count || 0, totalPages: Math.ceil((count || 0) / limit), currentPage: page } } // 캐싱을 활용한 최적화 import { unstable_cache } from 'next/cache' const getCachedPosts = unstable_cache( async () =&gt; { const { data } = await supabase .from('posts') .select('*') .eq('published', true) .order('published_at', { ascending: false }) .limit(10) return data }, ['featured-posts'], { revalidate: 300, // 5분 캐시 tags: ['posts'] } )   ","version":null,"tagName":"h3"},{"title":"장점과 한계​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#장점과-한계","content":" ","version":null,"tagName":"h2"},{"title":"Supabase의 주요 장점​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#supabase의-주요-장점","content":" 1. 개발 생산성​  즉시 사용 가능한 백엔드: 복잡한 서버 설정 없이 바로 개발 시작통합된 도구: 데이터베이스, 인증, 스토리지, 함수를 한 곳에서 관리직관적인 대시보드: 비개발자도 쉽게 이해할 수 있는 관리 인터페이스  2. 기술적 우수성​  PostgreSQL의 강력함: 복잡한 쿼리, 트랜잭션, ACID 보장실시간 성능: WebSocket 기반의 빠른 실시간 업데이트확장성: 수평적, 수직적 확장 모두 지원  3. 개발자 경험​  타입 안전성: TypeScript 완벽 지원으로 컴파일 타임 에러 방지자동 API 생성: 데이터베이스 스키마 기반 REST API 자동 생성풍부한 생태계: React, Vue, Svelte, Flutter 등 다양한 프레임워크 지원  ","version":null,"tagName":"h3"},{"title":"현재의 한계점​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#현재의-한계점","content":" 고려해야 할 제한사항 Supabase는 강력한 플랫폼이지만, 특정 상황에서는 제약이 있을 수 있습니다.  1. 복잡한 비즈니스 로직​  Edge Functions의 기능이 AWS Lambda나 Google Cloud Functions 대비 제한적복잡한 백엔드 로직은 여전히 별도 서버가 필요할 수 있음  2. 대용량 데이터 처리​  매우 큰 규모의 데이터 분석이나 ETL 작업에는 전문 도구가 더 적합복잡한 데이터 파이프라인 구축에는 추가 도구 필요  3. 특수한 요구사항​  특정 규정 준수나 보안 요구사항이 있는 엔터프라이즈 환경기존 레거시 시스템과의 복잡한 통합  ","version":null,"tagName":"h3"},{"title":"가격 정책과 확장성​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#가격-정책과-확장성","content":" ","version":null,"tagName":"h2"},{"title":"요금 구조​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#요금-구조","content":" Supabase는 사용량 기반 요금 정책을 채택하여 스타트업부터 대기업까지 합리적인 비용으로 이용할 수 있습니다.  플랜\t월 요금\t주요 특징Free\t$0\t• 2개 프로젝트 • 500MB 데이터베이스 • 1GB 스토리지 • 50MB Edge Functions Pro\t$25\t• 무제한 프로젝트 • 8GB 데이터베이스 • 100GB 스토리지 • 2GB Edge Functions Team\t$599\t• 팀 협업 기능 • 우선 지원 • 고급 보안 기능 Enterprise\t별도 문의\t• 전용 지원 • SLA 보장 • 커스텀 보안 정책  ","version":null,"tagName":"h3"},{"title":"확장성 전략​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#확장성-전략","content":" lib/performance.ts // 성능 최적화를 위한 실무 팁 // 1. 연결 풀링 최적화 const supabase = createClient(supabaseUrl, supabaseKey, { db: { schema: 'public', }, auth: { autoRefreshToken: true, persistSession: true, detectSessionInUrl: true }, realtime: { params: { eventsPerSecond: 10 } } }) // 2. 배치 처리 최적화 const batchInsertPosts = async (posts: Post[]) =&gt; { const batchSize = 100 const results = [] for (let i = 0; i &lt; posts.length; i += batchSize) { const batch = posts.slice(i, i + batchSize) const { data, error } = await supabase .from('posts') .insert(batch) if (error) { console.error(`Batch ${i / batchSize + 1} failed:`, error) } else { results.push(...(data || [])) } } return results } // 3. 읽기 전용 복제본 활용 const readOnlySupabase = createClient( process.env.SUPABASE_READ_REPLICA_URL!, process.env.SUPABASE_ANON_KEY! ) const getAnalyticsData = async () =&gt; { // 읽기 전용 복제본에서 분석 쿼리 실행 return await readOnlySupabase .from('posts') .select('created_at, author_id') .gte('created_at', '2024-01-01') }   ","version":null,"tagName":"h3"},{"title":"실무 도입 가이드​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#실무-도입-가이드","content":" ","version":null,"tagName":"h2"},{"title":"프로젝트 시작하기​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#프로젝트-시작하기","content":" 1. 프로젝트 초기 설정​  프로젝트 설정 # Next.js 프로젝트 생성 npx create-next-app@latest my-supabase-app --typescript --tailwind --app # Supabase 클라이언트 설치 npm install @supabase/supabase-js # 개발 도구 설치 npm install -D @supabase/cli # 환경변수 설정 (.env.local) NEXT_PUBLIC_SUPABASE_URL=your_supabase_url NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key SUPABASE_SERVICE_ROLE_KEY=your_service_role_key   2. Supabase 클라이언트 설정​  lib/supabase.ts import { createClient } from '@supabase/supabase-js' const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL! const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY! export const supabase = createClient(supabaseUrl, supabaseAnonKey) // 서버사이드용 클라이언트 (관리자 권한) export const supabaseAdmin = createClient( supabaseUrl, process.env.SUPABASE_SERVICE_ROLE_KEY!, { auth: { autoRefreshToken: false, persistSession: false } } )   ","version":null,"tagName":"h3"},{"title":"마이그레이션 전략​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#마이그레이션-전략","content":" 기존 Firebase 프로젝트에서 Supabase로 마이그레이션하는 경우의 전략입니다.  1. 데이터 마이그레이션​  scripts/migrate-firebase.ts // Firebase에서 Supabase로 데이터 마이그레이션 import { initializeApp } from 'firebase/app' import { getFirestore, collection, getDocs } from 'firebase/firestore' import { supabaseAdmin } from './lib/supabase' const migrateFirestoreToSupabase = async () =&gt; { // Firebase 초기화 const firebaseApp = initializeApp(firebaseConfig) const db = getFirestore(firebaseApp) // Firestore 데이터 가져오기 const postsSnapshot = await getDocs(collection(db, 'posts')) const posts = postsSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() })) // Supabase에 데이터 삽입 for (const post of posts) { const { error } = await supabaseAdmin .from('posts') .insert({ title: post.title, content: post.content, author_id: post.authorId, created_at: post.createdAt.toDate().toISOString() }) if (error) { console.error('Migration error:', error) } } }   2. 점진적 마이그레이션​  lib/hybrid-data.ts // 하이브리드 접근: Firebase와 Supabase 동시 사용 const useHybridData = () =&gt; { const [data, setData] = useState([]) useEffect(() =&gt; { const fetchData = async () =&gt; { // 우선 Supabase에서 시도 let { data: supabaseData, error } = await supabase .from('posts') .select('*') if (error || !supabaseData.length) { // Supabase에 데이터가 없으면 Firebase에서 가져오기 const firebaseData = await getFirebaseData() setData(firebaseData) } else { setData(supabaseData) } } fetchData() }, []) return data }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#결론","content":" Supabase는 PostgreSQL의 강력함과 NoSQL의 편의성을 결합한 혁신적인 백엔드 플랫폼으로, 현대 웹 애플리케이션 개발에 새로운 패러다임을 제시하고 있습니다. 특히 오픈소스 철학을 바탕으로 한 투명성과 개발자 중심의 경험은 Firebase의 훌륭한 대안이 되고 있습니다.  ","version":null,"tagName":"h2"},{"title":"주요 성과​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#주요-성과","content":" 2백만 명 이상의 개발자 커뮤니티 형성Fortune 500 기업들의 도입 증가지속적인 기능 업데이트와 성능 개선강력한 생태계와 써드파티 통합  ","version":null,"tagName":"h3"},{"title":"Supabase를 선택해야 하는 경우​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#supabase를-선택해야-하는-경우","content":" 관계형 데이터베이스의 강력함이 필요한 프로젝트빠른 프로토타이핑과 MVP 개발오픈소스 솔루션을 선호하는 조직벤더 락인을 피하고 싶은 경우SQL 숙련도가 있는 개발팀  ","version":null,"tagName":"h3"},{"title":"미래 전망​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#미래-전망","content":" Supabase는 단순한 백엔드 서비스를 넘어서 개발자 플랫폼으로 진화하고 있습니다. AI 기능 통합, 더 강력한 Edge Computing, 그리고 기업용 기능 강화를 통해 앞으로도 지속적인 성장이 예상됩니다.  모든 프로젝트에 완벽한 솔루션은 없지만, Supabase는 현대적인 웹 애플리케이션 개발에 있어서 가장 균형 잡힌 선택지 중 하나입니다. 특히 개발 속도와 확장성, 그리고 개발자 경험을 모두 고려했을 때 매우 경쟁력 있는 플랫폼입니다.    참고 자료  Supabase 공식 문서PostgreSQL 공식 문서Supabase GitHub RepositorySupabase vs Firebase 비교 분석 ","version":null,"tagName":"h3"},{"title":"PostgreSQL 18에 UUIDv7이 도입됩니다","type":0,"sectionRef":"#","url":"/blog/uuidv7-postgresql-18","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"PostgreSQL 18​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#postgresql-18","content":" PostgreSQL 18 베타 1이 며칠 전에 출시되었습니다. 이번 릴리스는 새로운 기능, 개선사항, 버그 수정으로 가득 차 있습니다. 평소와 같이 커뮤니티는 이를 시도해보고 문제를 보고하도록 권장하고 있으며, 9월에 고품질 릴리스를 출시하는 것이 목표입니다.  이번 릴리스의 주요 특징은 다음과 같습니다:  비동기 I/O (io_uring 사용) — 순차 스캔, 배큠에서 2-3배 속도 향상다중 컬럼 B-tree 인덱스의 Skip scan + 더 스마트한 OR/IN 최적화메이저 업그레이드 중 플래너 통계 유지UUIDv7 함수가상 생성 컬럼OAuth 로그인 + md5 사용 중단 경고EXPLAIN ANALYZE에서 I/O, CPU, WAL 표시시간적 제약조건, 비결정적 콜레이션의 LIKE, 케이스 폴딩새로운 와이어 프로토콜 버전: 3.2 (2003년 이후 첫 번째!)  uuidv7()이 가장 흥미로운 기능은 아니지만(그것은 비동기 I/O일 것입니다), 아마도 가장 기다려진 기능일 것입니다. PostgreSQL 17에 추가될 뻔했지만 포함되지 않아서 많은 사용자들이 실망했습니다. 저는 이 기능에 대해 너무 흥미로워서 베타 버전을 사용해보고 이에 대한 블로그 글을 쓰기로 결정했습니다.  ","version":null,"tagName":"h2"},{"title":"UUID란 무엇이며 왜 유용한가요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#uuid란-무엇이며-왜-유용한가요","content":" UUID는 트랜잭션부터 회사까지 다양한 항목의 식별자로 사용되는 128비트 값입니다. 공간과 시간에 걸쳐 고유하도록 설계되었으며, 중앙화된 서비스에 의존하지 않고도 높은 속도로 효율적으로 생성할 수 있습니다.  전통적으로 관계형 데이터베이스는 고유 식별자를 생성하기 위해 자동 증가 타입(SERIAL 또는 identity와 같은)을 사용했습니다. 이는 단일 머신에서 효율적으로 수행할 수 있지만(이 경우에도 단점이 있습니다), 확장이 필요한 경우 모든 노드에서 고유한 식별자를 생성하는 방법이 필요합니다. Instagram 팀은 PostgreSQL 데이터베이스를 샤딩하면서 UUID로 마이그레이션한 과정에 대한 짧은 블로그를 작성했습니다.  UUID는 다음과 같은 일반적인 시나리오에서 데이터베이스의 기본 키로 유용합니다:  분산 데이터베이스에서 고유 ID 생성: 많은 분산 데이터베이스가 자동 증가(identity) 컬럼을 지원할 수 있지만, 제한사항과 성능 문제가 있습니다. 추측할 수 없는 공개 식별자: 적절히 생성된 UUID는 추측하거나 예측할 수 없으며, 시스템에 대한 정보를 추론하는 데 사용할 수 없습니다. 예를 들어, 고객 식별자로 자동 증가를 사용하면 공격자가 모든 기존 식별자를 스캔하여 사용을 시도할 수 있고, 다음 식별자를 추측하여 고객 수를 추정할 수 있습니다. 클라이언트가 식별자를 생성할 수 있도록 허용: UUID를 사용하면 클라이언트가 서버와 조정하지 않고도 사용할 수 있는 식별자를 생성할 수 있습니다. 이는 서버와의 통신을 최소화하려는 모바일 앱과 서버리스 환경에서 유용합니다.  이러한 이점의 결과로 UUID는 많은 데이터베이스에서 기본 키로 사용됩니다. 하지만 데이터베이스에서 UUID 사용에 대한 3가지 우려사항도 있습니다:  정렬: UUID는 값으로 의미 있게 정렬할 수 없습니다.인덱스 지역성: 새로운 UUID는 인덱스에서 서로 가깝지 않습니다. 즉, 삽입이 임의의 위치에서 수행됩니다. 이는 인덱스 팽창과 기타 성능 문제를 일으킬 수 있습니다.크기: UUID는 128비트 값입니다. 대부분의 개발자는 기본 키로 INT(32비트) 또는 BIGINT(64비트)를 기본적으로 사용합니다. 매우 작은 레코드가 많은 테이블의 경우 이는 의미 있는 오버헤드가 될 수 있습니다.  다음 섹션에서 설명하겠지만, UUIDv7은 이 3가지 우려사항 중 2가지를 해결합니다.  UUID의 크기는 디스크 공간이나 네트워크 대역폭이 제한적일 때 문제가 될 수 있지만, 최신 CPU는 단일 명령어(CMEQ, SIMD 명령어의 일부)로 128비트 값을 비교할 수 있으므로 UUID에 대한 데이터베이스 작업이 고도로 최적화되어 있다는 점을 주목할 가치가 있습니다. 여기서 핵심은 데이터베이스와 애플리케이션 모두에서 UUID의 바이너리 표현(적절한 UUID 타입)을 사용하고 문자열 표현을 사용하지 않는 것입니다.  ","version":null,"tagName":"h2"},{"title":"왜 UUIDv7인가요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#왜-uuidv7인가요","content":" UUID는 2005년 RFC 4122에서 처음 표준화되었습니다. 이 RFC는 UUID의 5가지 변형을 정의하며, 그 중 변형 1과 4가 가장 일반적입니다. 이 사양은 나중에 2024년 5월에 발표된 RFC 9562에서 변형 6-8을 추가하도록 개정되었습니다(첫 번째 공개 작업 초안은 2020년에 발표되었지만). RFC 9562와 UUIDv7 생일 축하합니다!  사양 업데이트의 동기를 설명하기 위해 RFC 9562는 데이터베이스 키로 UUID를 사용하는 일반적인 사용 사례에 대해 논의합니다:  UUID가 인기를 얻은 한 영역은 데이터베이스 키입니다... 하지만 [RFC4122]에서 원래 정의된 UUID 버전 1-5는 다음과 같은 다른 바람직한 특성이 부족합니다: UUIDv4(섹션 5.4에서 설명)와 같이 시간 순서가 아닌 UUID 버전은 데이터베이스 인덱스 지역성이 좋지 않습니다. 이는 연속적으로 생성된 새 값이 인덱스에서 서로 가깝지 않다는 것을 의미합니다. 따라서 임의의 위치에서 삽입을 수행해야 합니다. 이를 위해 사용되는 일반적인 구조(B-tree 및 그 변형)에 대한 결과적인 부정적인 성능 영향은 극적일 수 있습니다. 널리 분산된 많은 데이터베이스 애플리케이션과 대형 애플리케이션 공급업체는 데이터베이스 키로 사용할 더 나은 시간 기반의 정렬 가능한 고유 식별자를 만드는 문제를 해결하려고 했습니다. 이로 인해 지난 10년 이상 동안 약간씩 다른 방식으로 동일한 문제를 해결하는 수많은 구현이 생겨났습니다.  RFC는 계속해서 16개(!)의 서로 다른 비표준 UUID 구현을 명시하며, 각각 고유한 장단점을 가지고 있습니다. 여기에는 인기 있는 ULID, Twitter의 Snowflake, Instagram의 ShardId 등이 포함됩니다. 이 모든 구현은 새로운 사양을 설계할 때 평가되었습니다.  새로운 RFC가 3개의 새로운 UUID 변형을 명시하지만, 흥미로운 것은 UUIDv7뿐입니다. UUIDv6은 하위 호환성을 위해서만 도입되었습니다 - RFC는 &quot;레거시 UUIDv1을 포함하지 않는 시스템은 대신 UUIDv7을 사용해야 합니다&quot;라고 말합니다. UUIDv8은 실험적이고 공급업체별 확장을 위한 형식을 제공합니다.  UUIDv7은 정렬과 인덱스 지역성 우려사항을 모두 해결합니다. 가장 중요한 48비트로 Unix Epoch 타임스탬프를 사용하고, 나머지 74비트를 랜덤 값으로 유지합니다(추가 비트는 버전과 변형에 사용됩니다). 이로 인해 UUID가 시간 순서로 정렬 가능하고 고유해집니다. 표준은 또한 UUID에 밀리초 타임스탬프를 포함하거나 신중하게 시드된 카운터를 포함하여 단일 초 내에서 순서를 지원하는 옵션을 제공합니다(필요한 경우). 결과적으로 UUIDv7은 데이터베이스의 기본 키로 사용하기에 매우 적합합니다 - 고유성이 보장되고, 정렬 가능하며, 좋은 인덱스 지역성을 가집니다.  ","version":null,"tagName":"h2"},{"title":"PostgreSQL 18의 UUIDv7​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#postgresql-18의-uuidv7","content":" PostgreSQL 18 이전까지는 UUIDv7이 기본적으로 지원되지 않았습니다. 내장된 gen_random_uuid() 함수는 UUIDv4를 생성했고, 인기 있는 uuid-ossp 확장이 추가 UUID 변형에 대한 지원을 추가했지만 RFC 4122에서 명시된 변형으로 제한되었습니다.  PostgreSQL 18은 새로운 함수인 uuidv7()을 추가하여 UUIDv7 값을 생성합니다. PostgreSQL 구현은 타임스탬프 바로 다음에 12비트 서브 밀리초 타임스탬프 분수를 포함합니다(표준에서 허용되지만 필수는 아님). 이는 동일한 PostgreSQL 세션(동일한 백엔드 프로세스)에서 생성된 모든 UUIDv7 값의 단조성을 보장합니다.  일관성을 위해 PostgreSQL 18은 명명을 맞추기 위해 gen_random_uuid()의 별칭으로 uuidv4()를 추가했습니다.  uuidv7()을 호출하면 타임스탬프가 현재 시간인 새로운 UUIDv7 값이 생성됩니다. 다른 시간에 대한 UUIDv7 값을 생성해야 하는 경우 함수에 선택적 interval을 전달할 수 있습니다.  UUID에서 타임스탬프와 버전을 추출하는 PostgreSQL의 기존 함수도 UUIDv7을 지원하도록 업데이트되었습니다. 다음은 새로운 함수를 사용하는 방법의 예입니다:  postgres=# select uuidv7(); uuidv7 -------------------------------------- 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd (1 row) postgres=# select uuidv7(INTERVAL '1 day'); uuidv7 -------------------------------------- 0196ef74-8d09-77b0-a84b-5301262f05ad (1 row) postgres=# SELECT uuid_extract_version(uuidv4()); uuid_extract_version ---------------------- 4 (1 row) postgres=# SELECT uuid_extract_version(uuidv7()); uuid_extract_version ---------------------- 7 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7()); uuid_extract_timestamp ---------------------------- 2025-05-19 20:50:40.381+00 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL '1 hour')); uuid_extract_timestamp ---------------------------- 2025-05-19 21:50:59.388+00 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL '-1 day')); uuid_extract_timestamp ---------------------------- 2025-05-18 20:51:15.774+00 (1 row)   테이블에서 uuidv7()을 기본 키로 사용하는 것은 간단하며, 타임스탬프를 추출하는 기능과 함께 UUID를 정렬 가능한 키로 사용하고 레코드의 생성 시간을 검사하기도 쉽게 만듭니다:  CREATE TABLE test ( id uuid DEFAULT uuidv7() PRIMARY KEY, name text ); INSERT INTO test (name) VALUES ('foo'); INSERT INTO test (name) VALUES ('bar'); -- 다른 두 개보다 1시간 이전으로 만들어서 목록의 시작 부분으로 정렬됩니다 INSERT INTO test (id, name) VALUES (uuidv7(INTERVAL '-1 hour'), 'oldest'); SELECT uuid_extract_timestamp(id), name FROM test ORDER BY id; uuid_extract_timestamp | name ----------------------------+-------- 2025-05-19 19:55:43.87+00 | oldest 2025-05-19 20:55:01.304+00 | foo 2025-05-19 20:55:01.305+00 | bar (3 rows)   이 모든 함수는 PostgreSQL 문서에 문서화되어 있으며, 구현 세부사항에 관심이 있다면 패치를 검토할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"직접 사용해보세요!​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#직접-사용해보세요","content":" PostgreSQL 18이 출시되면 평소와 같이 설치하여 uuidv7()과 다른 모든 새로운 기능을 사용할 수 있습니다. 공식 릴리스는 9월에 계획되어 있지만, Beta 1 버전이 이미 사용 가능하며 커뮤니티는 사용자들이 이를 시도해보고 문제를 보고하도록 권장합니다.  베타 버전과 야간 스냅샷의 설치 지침은 여기에서 확인할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"이전 버전에서 UUIDv7 사용하기: pg_uuidv7 확장​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#이전-버전에서-uuidv7-사용하기-pg_uuidv7-확장","content":" PostgreSQL 18을 기다릴 수 없다면, 이미 사용 가능한 서드파티 확장이 있습니다. pg_uuidv7은 PostgreSQL Extension Network(PGXN)에서 제공하는 확장으로, 이전 버전의 PostgreSQL에서도 UUIDv7 기능을 사용할 수 있게 해줍니다.  ","version":null,"tagName":"h2"},{"title":"pg_uuidv7 확장의 특징​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#pg_uuidv7-확장의-특징","content":" 이 확장은 PostgreSQL 18의 네이티브 구현과 유사한 기능을 제공합니다:  -- UUIDv7 생성 SELECT uuid_generate_v7(); uuid_generate_v7 -------------------------------------- 018570bb-4a7d-7c7e-8df4-6d47afd8c8fc (1 row) -- 타임스탬프 추출 SELECT uuid_v7_to_timestamptz('018570bb-4a7d-7c7e-8df4-6d47afd8c8fc'); uuid_v7_to_timestamptz ---------------------------- 2023-01-02 04:26:40.637+00 (1 row) -- 타임스탬프를 UUIDv7로 변환 SELECT uuid_timestamptz_to_v7('2023-01-02 04:26:40.637+00'); uuid_timestamptz_to_v7 -------------------------------------- 018570bb-4a7d-7630-a5c4-89b795024c5d (1 row)   ","version":null,"tagName":"h3"},{"title":"성능​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#성능","content":" pg_uuidv7 확장의 uuid_generate_v7() 함수는 PostgreSQL의 네이티브 gen_random_uuid() 함수와 거의 동일한 성능을 제공합니다. 이는 프로덕션 환경에서도 안심하고 사용할 수 있음을 의미합니다.  ","version":null,"tagName":"h3"},{"title":"설치 방법​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#설치-방법","content":" x86_64 Linux 시스템에서는 다음과 같이 간단히 설치할 수 있습니다:  # 임시 디렉토리에서 작업 cd &quot;$(mktemp -d)&quot; # 최신 릴리스 다운로드 curl -LO &quot;https://github.com/fboulnois/pg_uuidv7/releases/download/v1.6.0/{pg_uuidv7.tar.gz,SHA256SUMS}&quot; # 압축 해제 및 검증 tar xf pg_uuidv7.tar.gz sha256sum -c SHA256SUMS # PostgreSQL 버전 확인 및 설치 PG_MAJOR=$(pg_config --version | sed 's/^.* \\([0-9]\\{1,\\}\\).*$/\\1/') cp &quot;$PG_MAJOR/pg_uuidv7.so&quot; &quot;$(pg_config --pkglibdir)&quot; cp pg_uuidv7--1.6.sql pg_uuidv7.control &quot;$(pg_config --sharedir)/extension&quot; # 확장 활성화 psql -c &quot;CREATE EXTENSION pg_uuidv7;&quot;   다른 아키텍처(Apple M1, Raspberry Pi 등)에서는 소스에서 직접 빌드해야 합니다.  ","version":null,"tagName":"h3"},{"title":"언제 사용해야 할까요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#언제-사용해야-할까요","content":" pg_uuidv7 확장은 다음과 같은 경우에 유용합니다:  현재 PostgreSQL 버전을 유지해야 하는 경우: PostgreSQL 18로 업그레이드할 수 없지만 UUIDv7의 이점을 누리고 싶을 때즉시 UUIDv7을 사용하고 싶은 경우: PostgreSQL 18 출시를 기다리지 않고 지금 당장 UUIDv7을 사용하고 싶을 때마이그레이션 준비: PostgreSQL 18로 업그레이드하기 전에 UUIDv7을 미리 테스트해보고 싶을 때  PostgreSQL 18이 출시되면 네이티브 함수로 마이그레이션할 수 있으며, 함수 이름만 약간 다를 뿐 기본적인 기능은 동일합니다.  ","version":null,"tagName":"h3"},{"title":"마무리​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#마무리","content":" PostgreSQL 18은 경험 많은 개발자들이 정말로 감사할 실용적인 개선사항을 제공합니다. UUIDv7에 대한 기본 지원은 조용하지만 영향력 있는 추가 기능으로, 데이터베이스 설계에서 오랫동안 지속된 문제점을 해결합니다.  UUID는 항상 트레이드오프였습니다: 안전하고, 고유성이 보장되며, 분산 시스템에서 효율적으로 생성할 수 있지만 B-tree 인덱스 사용 시 성능 단점이 있었습니다. UUIDv7은 두 세계의 장점을 모두 가져옵니다 — 전역적으로 고유하면서도 B-tree 인덱스와 쓰기 집약적 워크로드와 잘 호환되는 방식으로 정렬됩니다. PostgreSQL 18은 이를 훨씬 더 편리하게 사용할 수 있게 만듭니다.  기본 키에 UUID 사용을 주저했다면, 이제 그 결정을 재검토할 기회입니다. 베타를 시도해보고, 스키마에서 테스트해보고, 어떻게 작동하는지 확인해보세요. 멀티 테넌트 앱을 구축하든 단순히 더 안정적인 ID 생성을 원하든, UUIDv7은 살펴볼 가치가 있습니다.  PostgreSQL의 미래를 형성하는 가장 좋은 방법은 일찍 참여하는 것입니다 — 그러니 테스트 인스턴스를 실행하고 발견한 것을 커뮤니티에 알려주세요.    참고 자료:  The Nile Blog - UUIDv7 Comes to PostgreSQL 18PGXN - pg_uuidv7 확장 ","version":null,"tagName":"h2"},{"title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","type":0,"sectionRef":"#","url":"/blog/tailwind-css-v4-complete-guide","content":"","keywords":"blog  react  typescript  frontend  development  프론트엔드  개발자  쌍팔년생","version":null},{"title":"v4.0: 성능과 현대 CSS의 혁신​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v40-성능과-현대-css의-혁신","content":" ","version":null,"tagName":"h2"},{"title":"🚀 Oxide 엔진: 빌드 성능의 혁명​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-oxide-엔진-빌드-성능의-혁명","content":" Tailwind CSS v4.0의 가장 큰 변화는 Rust로 작성된 Oxide 엔진 도입입니다.    성능 개선 수치:  전체 빌드: 최대 5배 향상증분 빌드: 100배 이상 향상대규모 프로젝트에서도 쾌적한 개발 경험  # v3.x 빌드 시간 예시 npm run build # ~15초 # v4.0 빌드 시간 예시 npm run build # ~3초   ","version":null,"tagName":"h3"},{"title":"🎨 CSS-first 설정: JavaScript에서 CSS로​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-css-first-설정-javascript에서-css로","content":" 기존의 복잡한 JavaScript 설정 파일을 CSS로 대체했습니다.  styles/tailwind.css @import &quot;tailwindcss&quot;; /* 커스텀 유틸리티 정의 */ @layer utilities { .btn-primary { @apply bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors; } .card-shadow { @apply shadow-lg shadow-gray-200/50 dark:shadow-gray-800/50; } } /* 커스텀 속성 정의 */ @property --brand-color { syntax: &quot;&lt;color&gt;&quot;; initial-value: #3b82f6; inherits: false; }   기존 방식과 비교:  tailwind.config.js (v3.x) module.exports = { theme: { extend: { colors: { brand: '#3b82f6' }, boxShadow: { 'card': '0 10px 15px -3px rgba(0, 0, 0, 0.1)' } } }, plugins: [ function({ addUtilities }) { addUtilities({ '.btn-primary': { backgroundColor: '#3b82f6', color: 'white', // ... } }) } ] }   ","version":null,"tagName":"h3"},{"title":"🌈 최신 CSS 기능 완전 지원​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-최신-css-기능-완전-지원","content":" v4.0은 최신 CSS 기능을 적극적으로 활용합니다:  1. OKLCH 색상 시스템  /* 더 정확하고 일관된 색상 표현 */ .text-blue-500 { color: oklch(0.6 0.2 250); }   2. 컨테이너 쿼리  &lt;div class=&quot;@container&quot;&gt; &lt;div class=&quot;@sm:text-lg @md:text-xl @lg:text-2xl&quot;&gt; 반응형 텍스트 &lt;/div&gt; &lt;/div&gt;   3. Cascade Layers  @layer base, components, utilities; @layer base { /* 기본 스타일 */ } @layer components { /* 컴포넌트 스타일 */ }   ","version":null,"tagName":"h3"},{"title":"🛠️ 새로운 유틸리티 클래스​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#️-새로운-유틸리티-클래스","content":" 박스 섀도우 확장:  &lt;!-- 4단계 섀도우 지원 --&gt; &lt;div class=&quot;shadow-xs shadow-sm shadow-md shadow-lg shadow-xl&quot;&gt; 다양한 섀도우 레벨 &lt;/div&gt; &lt;!-- 인셋 섀도우 --&gt; &lt;div class=&quot;inset-shadow-sm inset-shadow-md&quot;&gt; 내부 그림자 효과 &lt;/div&gt;   새로운 variant:  &lt;!-- nth-* variant --&gt; &lt;div class=&quot;nth-2:bg-gray-100 nth-odd:bg-blue-50&quot;&gt; &lt;!-- 2번째, 홀수 번째 요소 스타일링 --&gt; &lt;/div&gt; &lt;!-- not-* variant --&gt; &lt;div class=&quot;not-first:border-t not-last:border-b&quot;&gt; &lt;!-- 첫 번째가 아닌, 마지막이 아닌 요소 --&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"v4.1: 실전 유틸리티와 호환성 강화​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v41-실전-유틸리티와-호환성-강화","content":" ","version":null,"tagName":"h2"},{"title":"✨ 텍스트 섀도우 공식 지원​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-텍스트-섀도우-공식-지원","content":" 드디어 텍스트 섀도우가 공식 유틸리티로 추가되었습니다.  텍스트 섀도우 예시 &lt;!-- 기본 텍스트 섀도우 --&gt; &lt;h1 class=&quot;text-shadow-sm text-4xl font-bold&quot;&gt; 부드러운 텍스트 섀도우 &lt;/h1&gt; &lt;h2 class=&quot;text-shadow-md text-3xl font-semibold text-blue-600&quot;&gt; 중간 강도 섀도우 &lt;/h2&gt; &lt;h3 class=&quot;text-shadow-lg text-2xl font-bold text-white&quot;&gt; 강한 텍스트 섀도우 &lt;/h3&gt; &lt;!-- 알파값 조절 --&gt; &lt;p class=&quot;text-shadow-md/50 text-gray-800&quot;&gt; 50% 투명도 섀도우 &lt;/p&gt;   CSS 출력 결과:  .text-shadow-sm { text-shadow: 0 1px 2px rgb(0 0 0 / 0.05); } .text-shadow-md { text-shadow: 0 4px 6px rgb(0 0 0 / 0.1); } .text-shadow-lg { text-shadow: 0 8px 16px rgb(0 0 0 / 0.15); }   ","version":null,"tagName":"h3"},{"title":"🎭 마스킹 유틸리티​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-마스킹-유틸리티","content":" 복잡한 시각 효과를 간단하게 구현할 수 있는 마스킹 유틸리티가 추가되었습니다.  마스킹 효과 예시 &lt;!-- 그라디언트 마스킹 --&gt; &lt;div class=&quot;mask-gradient-to-r from-transparent to-black&quot;&gt; &lt;img src=&quot;hero-image.jpg&quot; alt=&quot;그라디언트 마스킹된 이미지&quot; /&gt; &lt;/div&gt; &lt;!-- 원형 마스킹 --&gt; &lt;div class=&quot;mask-circle&quot;&gt; &lt;img src=&quot;profile.jpg&quot; alt=&quot;원형 마스킹된 프로필&quot; /&gt; &lt;/div&gt; &lt;!-- 커스텀 SVG 마스킹 --&gt; &lt;div class=&quot;mask-[url(#custom-mask)]&quot;&gt; &lt;div class=&quot;bg-gradient-to-r from-blue-500 to-purple-600 h-32&quot;&gt; 커스텀 마스킹 영역 &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"🌐 구형 브라우저 호환성 대폭 개선​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-구형-브라우저-호환성-대폭-개선","content":" v4.1의 가장 실용적인 개선사항은 구형 브라우저 지원입니다.  OKLCH 자동 fallback:  /* v4.1에서 자동 생성되는 CSS */ .bg-blue-500 { background-color: #3b82f6; /* fallback */ background-color: oklch(0.6 0.2 250); } .text-red-500/50 { color: rgba(239, 68, 68, 0.5); /* fallback */ color: oklch(0.6 0.2 25 / 0.5); }   @property 미지원 브라우저 처리:  /* 지원 브라우저 */ @property --tw-shadow-color { syntax: &quot;&lt;color&gt;&quot;; initial-value: transparent; inherits: false; } /* 미지원 브라우저에서는 자동으로 비활성화 */   ","version":null,"tagName":"h3"},{"title":"📝 세밀한 텍스트 제어​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-세밀한-텍스트-제어","content":" overflow-wrap 유틸리티:  &lt;!-- 긴 URL이나 단어 처리 --&gt; &lt;div class=&quot;overflow-wrap-break-word max-w-xs&quot;&gt; https://very-long-domain-name-that-might-break-layout.com/path &lt;/div&gt; &lt;div class=&quot;overflow-wrap-anywhere&quot;&gt; supercalifragilisticexpialidocious &lt;/div&gt;   baseline 정렬 확장:  &lt;div class=&quot;flex items-baseline-last gap-4&quot;&gt; &lt;div class=&quot;text-sm leading-relaxed&quot;&gt; 여러 줄의&lt;br&gt; 텍스트 내용 &lt;/div&gt; &lt;div class=&quot;text-lg&quot;&gt; 마지막 줄 기준으로&lt;br&gt; 정렬됩니다 &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"🎯 새로운 상태 variant​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-새로운-상태-variant","content":" 입력 장치별 스타일링:  &lt;!-- 터치 디바이스 감지 --&gt; &lt;button class=&quot;pointer-coarse:p-4 pointer-fine:p-2&quot;&gt; 디바이스별 패딩 &lt;/button&gt; &lt;!-- 호버 가능 여부 감지 --&gt; &lt;div class=&quot;any-hover:hover:bg-blue-100&quot;&gt; 호버 지원 시에만 호버 효과 &lt;/div&gt;   접근성 및 환경 variant:  &lt;!-- JavaScript 비활성화 상태 --&gt; &lt;div class=&quot;noscript:block hidden&quot;&gt; JavaScript가 비활성화되었습니다. &lt;/div&gt; &lt;!-- 색상 반전 모드 --&gt; &lt;div class=&quot;inverted-colors:bg-white inverted-colors:text-black&quot;&gt; 고대비 모드 대응 &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"v3.x에서 v4.x로 업그레이드​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v3x에서-v4x로-업그레이드","content":" 1. 설치 및 설정 변경:  # 기존 패키지 제거 npm uninstall tailwindcss autoprefixer postcss # v4 설치 npm install tailwindcss@next   2. 설정 파일 변경:  src/styles/tailwind.css /* 기존 */ @tailwind base; @tailwind components; @tailwind utilities; /* v4.x */ @import &quot;tailwindcss&quot;;   3. 커스텀 설정 마이그레이션:  src/styles/tailwind.css @import &quot;tailwindcss&quot;; /* JavaScript 설정을 CSS로 이전 */ @layer utilities { .btn-custom { @apply bg-brand-500 text-white px-4 py-2 rounded; } } /* 커스텀 속성 정의 */ @property --brand-500 { syntax: &quot;&lt;color&gt;&quot;; initial-value: #3b82f6; inherits: false; }   ","version":null,"tagName":"h3"},{"title":"주의사항 및 호환성​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#주의사항-및-호환성","content":" Breaking Changes:  Node.js 18+ 필수일부 플러그인 API 변경PostCSS 설정 방식 변경  점진적 마이그레이션 전략:  새 프로젝트에서 v4 테스트기존 프로젝트는 v3.x 유지하며 점진적 업그레이드커스텀 플러그인 호환성 확인  ","version":null,"tagName":"h3"},{"title":"성능 벤치마크​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#성능-벤치마크","content":" 실제 프로젝트에서 측정한 성능 개선 결과입니다:  프로젝트 규모\tv3.x 빌드 시간\tv4.x 빌드 시간\t개선율소규모 (&lt; 100 컴포넌트)\t2.3초\t0.8초\t65% ↓ 중규모 (100-500 컴포넌트)\t8.7초\t2.1초\t76% ↓ 대규모 (500+ 컴포넌트)\t23.4초\t4.6초\t80% ↓  ","version":null,"tagName":"h2"},{"title":"실무 활용 팁​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#실무-활용-팁","content":" ","version":null,"tagName":"h2"},{"title":"1. 텍스트 섀도우 활용법​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#1-텍스트-섀도우-활용법","content":" &lt;!-- 헤더 텍스트에 깊이감 추가 --&gt; &lt;h1 class=&quot;text-4xl font-bold text-white text-shadow-lg&quot;&gt; 임팩트 있는 제목 &lt;/h1&gt; &lt;!-- 버튼 텍스트 가독성 향상 --&gt; &lt;button class=&quot;bg-gradient-to-r from-blue-500 to-purple-600 text-white text-shadow-sm px-6 py-3 rounded-lg&quot;&gt; 그라디언트 버튼 &lt;/button&gt;   ","version":null,"tagName":"h3"},{"title":"2. 마스킹으로 고급 효과​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#2-마스킹으로-고급-효과","content":" &lt;!-- 이미지 페이드 아웃 효과 --&gt; &lt;div class=&quot;relative&quot;&gt; &lt;img src=&quot;hero.jpg&quot; alt=&quot;히어로 이미지&quot; class=&quot;w-full h-64 object-cover&quot; /&gt; &lt;div class=&quot;absolute inset-0 mask-gradient-to-t from-black/80 to-transparent&quot;&gt; &lt;div class=&quot;absolute bottom-4 left-4 text-white&quot;&gt; &lt;h2 class=&quot;text-2xl font-bold&quot;&gt;오버레이 텍스트&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"3. 반응형 컨테이너 쿼리​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#3-반응형-컨테이너-쿼리","content":" &lt;div class=&quot;@container bg-white rounded-lg shadow-lg p-4&quot;&gt; &lt;h3 class=&quot;@xs:text-lg @sm:text-xl @md:text-2xl font-semibold&quot;&gt; 컨테이너 크기에 따른 반응형 제목 &lt;/h3&gt; &lt;p class=&quot;@sm:block hidden text-gray-600 mt-2&quot;&gt; 컨테이너가 충분히 클 때만 표시되는 설명 &lt;/p&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#결론","content":" Tailwind CSS v4.0과 v4.1은 단순한 버전 업그레이드를 넘어 프론트엔드 개발 방식의 패러다임 전환을 제시합니다.  v4.0의 핵심 가치:  성능: Oxide 엔진으로 개발 생산성 극대화현대성: 최신 CSS 기능 완전 활용단순성: CSS-first 접근법으로 설정 복잡도 감소  v4.1의 실용적 개선:  시각적 완성도: 텍스트 섀도우, 마스킹 등 디자인 유틸리티호환성: 구형 브라우저 graceful degradation세밀함: 텍스트 제어, 상태 관리 등 디테일 향상  특히 구형 브라우저 지원과 텍스트 섀도우, 마스킹 유틸리티는 v4.1에서만 제공되므로, 실무 프로젝트에서는 최신 버전 사용을 강력히 권장합니다.  앞으로 Tailwind CSS는 성능과 개발자 경험, 그리고 실용성 모든 면에서 프론트엔드 개발의 새로운 표준을 제시할 것으로 기대됩니다. ","version":null,"tagName":"h2"}],"options":{"languages":["ko","en"],"id":"default"}}