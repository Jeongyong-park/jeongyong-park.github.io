{"searchDocs":[{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","type":0,"sectionRef":"#","url":"/blog/csharp-thread-parallel-foreach-cancellation","content":"","keywords":"","version":null},{"title":"메인 클래스 및 중단 클래스​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-cancellation#메인-클래스-및-중단-클래스","content":" using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ThreadTest { class Program { static void Main(string[] args) { Console.WriteLine(&quot;press any key for Thread start!&quot;); Console.ReadKey(); RulyCanceler canceler = new RulyCanceler(); TestFilter tf = new TestFilter(10000000); Thread t = new Thread(() =&gt; { try { tf.execute(canceler); }catch(OperationCanceledException) { Console.WriteLine(&quot;Canceled!&quot;); } }); t.Start(); Console.ReadKey(); Console.WriteLine(&quot;Abort!&quot;); canceler.Cancel(); t.Abort(); t.Join(); Console.WriteLine(&quot;Aborted!&quot;); Console.ReadKey(); } } public class RulyCanceler { object _cancelLocker = new object(); bool _cancelRequest; public bool IsCancellationRequested { get { lock (_cancelLocker) return _cancelRequest; } } public void Cancel() { lock (_cancelLocker) _cancelRequest = true; } public void ThrowIfCancellationRequested() { if (IsCancellationRequested) throw new OperationCanceledException(); } } }   ","version":null,"tagName":"h3"},{"title":"시간이 오래걸리는 작업 클래스​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-cancellation#시간이-오래걸리는-작업-클래스","content":" using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ThreadTest { public class TestFilter { private long featureCount; private int MULTI_THREAD_COUNT = 10; EventWaitHandle waitEvent = new EventWaitHandle(true, EventResetMode.AutoReset, &quot;SHARED_BY_ALL_PROCESSES&quot;); public TestFilter(long featurecount) { this.featureCount = featurecount; } public void execute(RulyCanceler cancer) { int workingRangeSize = 1; if (featureCount &gt; 100) { workingRangeSize = (int)(featureCount / MULTI_THREAD_COUNT); } var part = Partitioner.Create(0, featureCount, workingRangeSize); Parallel.ForEach(part, (num, state) =&gt; { for (long featureIdx = num.Item1, cnt = num.Item2; featureIdx &lt; cnt; featureIdx++) { try { //waitEvent.WaitOne();(파일 쓰기모드일 경우 하나의 스레드만 쓸수 있도록 줄세우기) //waitEvent.Set(); // 중단 요청이있으면 Throw cancer.ThrowIfCancellationRequested(); // 실제 일 Console.WriteLine(String.Format(&quot;{0} - {1}&quot;, num.Item1, featureIdx)); } catch (OperationCanceledException ex) { Console.WriteLine(&quot;Breaked.&quot;); Console.WriteLine(&quot;Clean&quot;); state.Break(); break; } } }); } } }     Footnotes​ http://www.albahari.com/threading/part3.aspx ↩ ","version":null,"tagName":"h3"},{"title":"DiffX: 확장 가능한 차세대 Diff 형식","type":0,"sectionRef":"#","url":"/blog/diffx-next-generation-extensible-diff-format","content":"","keywords":"","version":null},{"title":"저희가 겪었던 diff 형식의 문제들​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#저희가-겪었던-diff-형식의-문제들","content":" ","version":null,"tagName":"h2"},{"title":"1. 서로 다른 플랫폼, 서로 다른 형식​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#1-서로-다른-플랫폼-서로-다른-형식","content":" 프로젝트를 진행하면서 이런 상황들을 자주 마주했어요:  Git diff:  diff --git a/readme b/readme index d6613f5..5b50866 100644 --- a/readme +++ b/readme @@ -1 +1,3 @@ Hello there + +Oh hi!   SVN diff:  Index: readme =================================================================== --- (revision 123) +++ (working copy) Property changes on: . ------------------------------------------------------------------- Modified: myproperty ## -1 +1 ## -old value +new value   일반 unified diff:  --- readme 2016-01-26 16:29:12.000000000 -0800 +++ readme 2016-01-31 11:54:32.000000000 -0800 @@ -1 +1,3 @@ Hello there + +Oh hi!   각각 다른 형식이다 보니 저희가 만든 리뷰 도구에서 파싱할 때마다 예외 처리를 따로 해야 했어요. 정말 번거로웠죠.  ","version":null,"tagName":"h3"},{"title":"2. 바이너리 파일의 난관​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#2-바이너리-파일의-난관","content":" 가장 속상했던 건 바이너리 파일 처리였어요. 이미지나 문서 파일이 변경되면 diff에서는 그냥 &quot;Binary files differ&quot;라고만 나오거든요. 실제로 뭐가 바뀌었는지 알 수 있는 방법이 없었죠.  동료분이 &quot;이미지 diff도 보여줄 수 있으면 좋겠는데...&quot;라고 하셨는데, 기존 diff 형식으론 한계가 있었어요.  ","version":null,"tagName":"h3"},{"title":"3. 메타데이터의 부재​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#3-메타데이터의-부재","content":" 커밋 정보나 작성자 정보를 diff에 포함시키고 싶어도 표준화된 방법이 없었어요. 각자 다른 방식으로 구현하다 보니 호환성 문제가 계속 발생했습니다.  ","version":null,"tagName":"h3"},{"title":"DiffX 발견과 첫 인상​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx-발견과-첫-인상","content":" ","version":null,"tagName":"h2"},{"title":"동료의 추천​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#동료의-추천","content":" 그때 저희 팀의 시니어 개발자분이 오픈소스 컨퍼런스에서 들은 이야기를 공유해주셨어요. &quot;DiffX라는 새로운 형식이 나왔는데, 우리가 고민하던 문제들을 해결해줄 수 있을 것 같아&quot;라고 하시더라고요.  처음에는 반신반의했죠. &quot;또 새로운 표준을 배워야 하나?&quot;라는 생각이었거든요.  ","version":null,"tagName":"h3"},{"title":"실제 DiffX 파일을 보고 놀란 점​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#실제-diffx-파일을-보고-놀란-점","content":" 공식 문서에서 제공하는 예시를 보고 정말 깜짝 놀랐어요:  #diffx: encoding=utf-8, version=1.0 #.change: #..preamble: indent=4, length=319, mimetype=text/markdown Convert legacy header building code to Python 3. Header building for messages used old Python 2.6-era list comprehensions with tuples rather than modern dictionary comprehensions in order to build a message list. This change modernizes that, and swaps out six for a 3-friendly `.items()` call. #..meta: format=json, length=270 { &quot;author&quot;: &quot;Christian Hammond &lt;christian@example.com&gt;&quot;, &quot;committer&quot;: &quot;Christian Hammond &lt;christian@example.com&gt;&quot;, &quot;committer date&quot;: &quot;2021-06-02T13:12:06-07:00&quot;, &quot;date&quot;: &quot;2021-06-01T19:26:31-07:00&quot;, &quot;id&quot;: &quot;a25e7b28af5e3184946068f432122c68c1a30b23&quot; } #..file: #...meta: format=json, length=176 { &quot;path&quot;: &quot;/src/message.py&quot;, &quot;revision&quot;: { &quot;new&quot;: &quot;f814cf74766ba3e6d175254996072233ca18a690&quot;, &quot;old&quot;: &quot;9f6a412b3aee0a55808928b43f848202b4ee0f8d&quot; } } #...diff: length=629 --- /src/message.py +++ /src/message.py @@ -164,10 +164,10 @@ not isinstance(headers, MultiValueDict)): # Instantiating a MultiValueDict from a dict does not ensure that # values are lists, so we have to ensure that ourselves. - headers = MultiValueDict(dict( - (key, [value]) - for key, value in six.iteritems(headers) - )) + headers = MultiValueDict({ + key: [value] + for key, value in headers.items() + }) if in_reply_to: headers['In-Reply-To'] = in_reply_to   &quot;아, 이거구나!&quot; 하는 순간이었어요. 구조화된 메타데이터, 인코딩 정보, 커밋 정보까지 모든 게 체계적으로 들어있더라고요.  ","version":null,"tagName":"h3"},{"title":"DiffX의 혁신적인 특징들​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#diffx의-혁신적인-특징들","content":" ","version":null,"tagName":"h2"},{"title":"1. 구조화된 메타데이터 지원​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#1-구조화된-메타데이터-지원","content":" 저희가 가장 아쉬워했던 부분인데, DiffX는 JSON 형식으로 체계적인 메타데이터를 제공해요:  작성자 정보: 누가, 언제 변경했는지커밋 정보: 커밋 ID, 메시지 등파일 정보: 경로, 리비전 정보인코딩 정보: 텍스트 인코딩 명시  ","version":null,"tagName":"h3"},{"title":"2. 멀티 커밋 지원​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#2-멀티-커밋-지원","content":" 하나의 diff 파일에 여러 커밋을 포함할 수 있어요. 저희가 PR 리뷰할 때 &quot;이전 커밋과 비교해서 보고 싶은데...&quot;라고 했던 그 니즈를 정확히 해결해주더라고요.  ","version":null,"tagName":"h3"},{"title":"3. 바이너리 파일 처리​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#3-바이너리-파일-처리","content":" Git과 호환되는 바이너리 diff를 지원해서, 이미지나 문서 파일 변경사항도 제대로 표현할 수 있어요. 더 이상 &quot;Binary files differ&quot;만 보고 좌절할 필요가 없어졌죠!  ","version":null,"tagName":"h3"},{"title":"4. 기존 도구와의 완벽한 호환성​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#4-기존-도구와의-완벽한-호환성","content":" 가장 마음에 든 점은 기존 diff 파서들이 그대로 동작한다는 거예요. 새로운 기능은 추가로 파싱해야 하지만, 기본적인 diff 기능은 모든 기존 도구에서 정상 작동합니다.  ","version":null,"tagName":"h3"},{"title":"실제 도입 경험​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#실제-도입-경험","content":" ","version":null,"tagName":"h2"},{"title":"팀 내 검토 과정​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#팀-내-검토-과정","content":" 동료분 추천을 받고 저희 팀에서 실제로 테스트해봤어요. 처음에는 &quot;학습 비용이 클까?&quot;라는 우려가 있었는데, 생각보다 간단하더라고요.  ","version":null,"tagName":"h3"},{"title":"기존 워크플로우와의 통합​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#기존-워크플로우와의-통합","content":" 다행히 DiffX는 기존 도구를 깨뜨리지 않으면서도 새로운 기능을 제공하더라고요. 점진적으로 도입할 수 있어서 리스크가 적었어요.  // 기존 diff 파서는 그대로 동작 const standardDiff = parseDiff(diffContent) // DiffX 기능은 별도로 파싱 if (isDiffX(diffContent)) { const metadata = parseDiffXMetadata(diffContent) // 추가 정보 활용 }   ","version":null,"tagName":"h3"},{"title":"성과와 개선점​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#성과와-개선점","content":" 도입 후 저희 리뷰 도구에서 다음과 같은 개선을 볼 수 있었어요:  파싱 에러 90% 감소: 표준화된 형식 덕분바이너리 파일 지원: 이미지 diff도 표시 가능리뷰 품질 향상: 더 많은 메타데이터로 컨텍스트 제공멀티 플랫폼 호환성: Git, SVN 등 모든 VCS 지원  ","version":null,"tagName":"h3"},{"title":"현재 상황과 전망​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#현재-상황과-전망","content":" ","version":null,"tagName":"h2"},{"title":"실제 사용 중인 곳들​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#실제-사용-중인-곳들","content":" Review Board: Beanbag에서 이미 실제 운영환경에서 사용 중Python 구현체: pydiffx로 쉽게 테스트 가능  ","version":null,"tagName":"h3"},{"title":"저희 팀의 향후 계획​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#저희-팀의-향후-계획","content":" 아직 모든 프로젝트에 적용하지는 못했지만, 새로운 프로젝트부터 DiffX를 기본으로 사용하려고 해요. 특히 멀티 클라이언트 환경에서는 정말 유용하더라고요.  ","version":null,"tagName":"h3"},{"title":"한계점과 고려사항​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#한계점과-고려사항","content":" 완벽한 해결책은 아니에요. 여전히 고려해야 할 점들이 있어요:  ","version":null,"tagName":"h2"},{"title":"1. 새로운 기능 지원 필요​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#1-새로운-기능-지원-필요","content":" DiffX의 모든 기능을 활용하려면 도구들이 업데이트되어야 해요. 당장은 기본적인 diff 기능만 모든 곳에서 동작합니다.  ","version":null,"tagName":"h3"},{"title":"2. 학습 곡선​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#2-학습-곡선","content":" 팀원들이 새로운 형식에 익숙해지는 시간이 필요했어요. 다행히 기존 diff와 크게 다르지 않아서 금방 적응하셨지만요.  ","version":null,"tagName":"h3"},{"title":"3. 도구 생태계​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#3-도구-생태계","content":" 아직 DiffX를 완전히 지원하는 도구가 많지 않아요. 하지만 점차 늘어나고 있는 추세입니다.  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#결론","content":" 저희 팀에서 DiffX를 도입한 경험을 돌아보면, 확실히 기존 diff 형식의 한계를 극복한 혁신적인 해결책이라고 생각해요. 특히 멀티 플랫폼 환경이나 바이너리 파일을 자주 다루는 프로젝트에서는 정말 유용하더라고요.  물론 아직 생태계가 완전히 성숙하지는 않았지만, 기존 도구와의 호환성이 보장되어 있어서 점진적으로 도입할 수 있다는 점이 큰 장점입니다.  혹시 저희와 비슷한 문제로 고민하고 계신 분들이 있다면 한번 시도해보시기를 추천드려요. 동료분이 알려주신 덕분에 저희 팀의 diff 처리 워크플로우가 정말 많이 개선되었거든요.  더 궁금한 점이 있으시거나 실제 도입 경험을 공유하고 싶으시면 언제든 댓글로 남겨주세요! 함께 고민해보면 좋겠어요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#참고-자료","content":" ","version":null,"tagName":"h2"},{"title":"공식 문서​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#공식-문서","content":" DiffX 공식 웹사이트 - 프로젝트 홈페이지DiffX 파일 형식 사양서 - 기술 사양 상세 문서DiffX 예제 파일들 - 실제 사용 예시FAQ - 자주 묻는 질문  ","version":null,"tagName":"h3"},{"title":"배경 자료​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#배경-자료","content":" Diff의 문제점 상세 분석 - 기존 diff 형식의 문제점GNU diff 문서 - 전통적인 diff 도구Git diff 형식 문서 - Git diff 형식 설명  ","version":null,"tagName":"h3"},{"title":"관련 프로젝트​","type":1,"pageTitle":"DiffX: 확장 가능한 차세대 Diff 형식","url":"/blog/diffx-next-generation-extensible-diff-format#관련-프로젝트","content":" Review Board - 코드 리뷰 도구Beanbag, Inc. - DiffX 개발사 ","version":null,"tagName":"h3"},{"title":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","type":0,"sectionRef":"#","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation","content":"","keywords":"","version":null},{"title":"Thread.Abort()를 사용하면 안 되는 이유​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#threadabort를-사용하면-안-되는-이유","content":" Thread.Abort()는 여러 심각한 문제를 야기할 수 있습니다:  .NET 5 이상에서 지원 중단: 더 이상 사용할 수 없는 방법입니다리소스 누수: 파일 핸들, 데이터베이스 연결 등이 제대로 해제되지 않을 수 있습니다데이터 손상: 작업 중간에 강제 종료되어 일관성이 깨질 수 있습니다예측 불가능한 동작: ThreadAbortException이 예상치 못한 곳에서 발생할 수 있습니다  Thread.Abort() 사용 금지 Thread.Abort()는 .NET 5 이상에서 지원되지 않으며, 이전 버전에서도 안전하지 않습니다. 절대 사용하지 마세요.  ","version":null,"tagName":"h2"},{"title":"Thread 안전하게 중단하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#thread-안전하게-중단하기","content":" ","version":null,"tagName":"h2"},{"title":"1. 플래그 패턴 사용​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#1-플래그-패턴-사용","content":" 가장 간단한 방법은 boolean 플래그를 사용하는 것입니다:  플래그 패턴을 사용한 Thread 중단 public class SafeThread { private volatile bool _stopRequested = false; private Thread _thread; public void Start() { _thread = new Thread(DoWork); _thread.Start(); } public void Stop() { _stopRequested = true; _thread?.Join(); // 스레드가 완전히 종료될 때까지 대기 } private void DoWork() { while (!_stopRequested) { // 실제 작업 수행 ProcessItem(); // 주기적으로 중단 요청 확인 if (_stopRequested) break; Thread.Sleep(100); // 예시: 100ms 대기 } Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } private void ProcessItem() { // 실제 작업 로직 Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h3"},{"title":"2. CancellationToken 사용 (권장)​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#2-cancellationtoken-사용-권장","content":" .NET의 표준 취소 패턴인 CancellationToken을 사용하는 방법입니다 (.NET Framework 4.0 이상):  CancellationToken을 사용한 Thread 중단 public class CancellableThread { private Thread _thread; private CancellationTokenSource _cancellationTokenSource; public void Start() { _cancellationTokenSource = new CancellationTokenSource(); _thread = new Thread(() =&gt; DoWork(_cancellationTokenSource.Token)); _thread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _thread?.Join(); _cancellationTokenSource?.Dispose(); } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { ProcessItem(); // 취소 요청 확인 및 예외 발생 cancellationToken.ThrowIfCancellationRequested(); // 취소 가능한 대기 (.NET Framework 4.8에서는 Thread.Sleep 사용) if (cancellationToken.WaitHandle.WaitOne(100)) { break; // 취소 요청됨 } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } } private void ProcessItem() { Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h3"},{"title":"Parallel.ForEach 안전하게 중단하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#parallelforeach-안전하게-중단하기","content":" Parallel.ForEach는 ParallelOptions를 통해 CancellationToken을 지원합니다 (.NET Framework 4.0 이상):  CancellationToken을 사용한 Parallel.ForEach 중단 public class ParallelProcessor { public async Task ProcessItemsAsync(IEnumerable&lt;int&gt; items) { var cancellationTokenSource = new CancellationTokenSource(); // 5초 후 자동 취소 (예시) cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(5)); var parallelOptions = new ParallelOptions { CancellationToken = cancellationTokenSource.Token, MaxDegreeOfParallelism = Environment.ProcessorCount }; try { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { // 각 반복에서 취소 요청 확인 parallelOptions.CancellationToken.ThrowIfCancellationRequested(); ProcessSingleItem(item, parallelOptions.CancellationToken); }); Console.WriteLine(&quot;모든 작업이 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;병렬 작업이 취소되었습니다.&quot;); } finally { cancellationTokenSource.Dispose(); } } private void ProcessSingleItem(int item, CancellationToken cancellationToken) { // 긴 작업 시뮬레이션 for (int i = 0; i &lt; 10; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); // 실제 작업 시뮬레이션 Console.WriteLine($&quot;Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } } }   ","version":null,"tagName":"h2"},{"title":"외부에서 수동으로 취소하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#외부에서-수동으로-취소하기","content":" 사용자 입력이나 다른 조건에 따라 수동으로 취소하는 예시입니다:  수동 취소가 가능한 병렬 처리 public class ManualCancellationExample { private CancellationTokenSource _cancellationTokenSource; public async Task StartProcessingAsync() { _cancellationTokenSource = new CancellationTokenSource(); var items = Enumerable.Range(1, 1000); var parallelOptions = new ParallelOptions { CancellationToken = _cancellationTokenSource.Token, MaxDegreeOfParallelism = 4 }; try { await Task.Run(() =&gt; { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); // 무거운 작업 시뮬레이션 Thread.Sleep(200); Console.WriteLine($&quot;처리 완료: {item}&quot;); }); }); } catch (OperationCanceledException) { Console.WriteLine(&quot;사용자에 의해 작업이 취소되었습니다.&quot;); } } public void CancelProcessing() { _cancellationTokenSource?.Cancel(); Console.WriteLine(&quot;취소 요청이 전송되었습니다.&quot;); } } // 사용 예시 class Program { static async Task Main(string[] args) { var processor = new ManualCancellationExample(); // 백그라운드에서 처리 시작 var processingTask = processor.StartProcessingAsync(); Console.WriteLine(&quot;Enter 키를 누르면 작업을 취소합니다...&quot;); Console.ReadLine(); // 사용자 입력으로 취소 processor.CancelProcessing(); await processingTask; Console.WriteLine(&quot;프로그램이 종료되었습니다.&quot;); } }   ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8 호환 버전​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48-호환-버전","content":" .NET Framework 4.8에서는 일부 최신 API가 없어서 약간 다른 접근이 필요합니다:  .NET Framework 4.8 호환 CancellationToken 사용 public class NetFramework48Thread { private Thread _thread; private CancellationTokenSource _cancellationTokenSource; public void Start() { _cancellationTokenSource = new CancellationTokenSource(); _thread = new Thread(() =&gt; DoWork(_cancellationTokenSource.Token)); _thread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _thread?.Join(); _cancellationTokenSource?.Dispose(); } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { ProcessItem(); // 취소 요청 확인 cancellationToken.ThrowIfCancellationRequested(); // .NET Framework 4.8에서 취소 가능한 대기 // Task.Delay 대신 WaitHandle 사용 if (cancellationToken.WaitHandle.WaitOne(100)) { break; // 취소 요청됨 } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { Console.WriteLine(&quot;스레드가 안전하게 종료되었습니다.&quot;); } } private void ProcessItem() { Console.WriteLine($&quot;작업 처리 중... (Thread ID: {Thread.CurrentThread.ManagedThreadId})&quot;); } }   ","version":null,"tagName":"h2"},{"title":".NET Framework 4.8에서 Parallel.ForEach 사용​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48에서-parallelforeach-사용","content":" .NET Framework 4.8 Parallel.ForEach 예제 public class NetFramework48ParallelProcessor { public void ProcessItems(IEnumerable&lt;int&gt; items) { var cancellationTokenSource = new CancellationTokenSource(); // 5초 후 자동 취소 var timer = new System.Threading.Timer(_ =&gt; cancellationTokenSource.Cancel(), null, 5000, Timeout.Infinite); var parallelOptions = new ParallelOptions { CancellationToken = cancellationTokenSource.Token, MaxDegreeOfParallelism = Environment.ProcessorCount }; try { Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); ProcessSingleItem(item, parallelOptions.CancellationToken); }); Console.WriteLine(&quot;모든 작업이 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;병렬 작업이 취소되었습니다.&quot;); } finally { timer?.Dispose(); cancellationTokenSource.Dispose(); } } private void ProcessSingleItem(int item, CancellationToken cancellationToken) { for (int i = 0; i &lt; 10; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); Console.WriteLine($&quot;Item {item}, Step {i + 1}/10 (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } } }   ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8에서 Task 기반 접근​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48에서-task-기반-접근","content":" .NET Framework 4.8에서는 Task를 사용한 접근도 가능합니다:  .NET Framework 4.8 Task 기반 처리 public class NetFramework48TaskProcessor { private CancellationTokenSource _cancellationTokenSource; public async Task StartProcessingAsync() { _cancellationTokenSource = new CancellationTokenSource(); var items = Enumerable.Range(1, 1000); try { // .NET Framework 4.8에서는 Task.Run 대신 Task.Factory.StartNew 사용 권장 await Task.Factory.StartNew(() =&gt; { var parallelOptions = new ParallelOptions { CancellationToken = _cancellationTokenSource.Token, MaxDegreeOfParallelism = 4 }; Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { parallelOptions.CancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(200); Console.WriteLine($&quot;처리 완료: {item}&quot;); }); }, _cancellationTokenSource.Token); } catch (OperationCanceledException) { Console.WriteLine(&quot;사용자에 의해 작업이 취소되었습니다.&quot;); } } public void CancelProcessing() { _cancellationTokenSource?.Cancel(); Console.WriteLine(&quot;취소 요청이 전송되었습니다.&quot;); } }   ","version":null,"tagName":"h3"},{"title":"Thread와 Parallel.ForEach 조합하기​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#thread와-parallelforeach-조합하기","content":" 별도 스레드에서 Parallel.ForEach를 실행하고 전체를 안전하게 중단하는 방법입니다:  Thread 내에서 Parallel.ForEach 사용 public class ThreadedParallelProcessor { private Thread _workerThread; private CancellationTokenSource _cancellationTokenSource; public void Start(IEnumerable&lt;int&gt; items) { _cancellationTokenSource = new CancellationTokenSource(); _workerThread = new Thread(() =&gt; ProcessInBackground(items, _cancellationTokenSource.Token)); _workerThread.Start(); } public void Stop() { _cancellationTokenSource?.Cancel(); _workerThread?.Join(TimeSpan.FromSeconds(10)); // 최대 10초 대기 _cancellationTokenSource?.Dispose(); } private void ProcessInBackground(IEnumerable&lt;int&gt; items, CancellationToken cancellationToken) { try { var parallelOptions = new ParallelOptions { CancellationToken = cancellationToken, MaxDegreeOfParallelism = Environment.ProcessorCount / 2 }; Parallel.ForEach(items, parallelOptions, (item, loopState) =&gt; { cancellationToken.ThrowIfCancellationRequested(); // 실제 작업 처리 ProcessItem(item, cancellationToken); }); Console.WriteLine(&quot;백그라운드 처리가 완료되었습니다.&quot;); } catch (OperationCanceledException) { Console.WriteLine(&quot;백그라운드 작업이 취소되었습니다.&quot;); } } private void ProcessItem(int item, CancellationToken cancellationToken) { // 긴 작업 중간중간 취소 확인 for (int i = 0; i &lt; 5; i++) { cancellationToken.ThrowIfCancellationRequested(); Thread.Sleep(100); } Console.WriteLine($&quot;Item {item} 처리 완료&quot;); } }   ","version":null,"tagName":"h2"},{"title":".NET Framework vs .NET 5+ 차이점​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-vs-net-5-차이점","content":" ","version":null,"tagName":"h2"},{"title":"API 차이점 요약​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#api-차이점-요약","content":" 기능\t.NET Framework 4.8\t.NET 5+CancellationToken\t✅ 지원\t✅ 지원 Task.Delay with CancellationToken\t❌ 제한적\t✅ 완전 지원 Task.Run\t❌ 없음\t✅ 지원 CancellationTokenSource.CancelAfter\t❌ 없음\t✅ 지원 Thread.Abort\t⚠️ 사용 가능하지만 위험\t❌ Obsolete  ","version":null,"tagName":"h3"},{"title":".NET Framework 4.8 권장 패턴​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#net-framework-48-권장-패턴","content":" .NET Framework 4.8 권장 패턴 public class RecommendedNetFramework48Pattern { private readonly CancellationTokenSource _cancellationTokenSource; private readonly ManualResetEventSlim _completedEvent; public RecommendedNetFramework48Pattern() { _cancellationTokenSource = new CancellationTokenSource(); _completedEvent = new ManualResetEventSlim(false); } public void StartWork() { Task.Factory.StartNew(() =&gt; DoWork(_cancellationTokenSource.Token), _cancellationTokenSource.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default); } public void StopWork(int timeoutMs = 5000) { _cancellationTokenSource.Cancel(); if (!_completedEvent.Wait(timeoutMs)) { Console.WriteLine(&quot;작업이 제한 시간 내에 완료되지 않았습니다.&quot;); } } private void DoWork(CancellationToken cancellationToken) { try { while (!cancellationToken.IsCancellationRequested) { // 실제 작업 수행 ProcessWorkItem(); // 주기적 취소 확인 (.NET Framework 4.8 호환) if (cancellationToken.WaitHandle.WaitOne(100)) { break; } } } catch (OperationCanceledException) { Console.WriteLine(&quot;작업이 취소되었습니다.&quot;); } finally { _completedEvent.Set(); Console.WriteLine(&quot;작업이 완료되었습니다.&quot;); } } private void ProcessWorkItem() { // 실제 작업 로직 Thread.Sleep(50); Console.WriteLine($&quot;작업 처리 중... (Thread: {Thread.CurrentThread.ManagedThreadId})&quot;); } public void Dispose() { _cancellationTokenSource?.Dispose(); _completedEvent?.Dispose(); } }   ","version":null,"tagName":"h3"},{"title":"성능 고려사항​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#성능-고려사항","content":" ","version":null,"tagName":"h2"},{"title":"취소 확인 빈도​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#취소-확인-빈도","content":" 취소 확인을 너무 자주 하면 성능에 영향을 줄 수 있습니다:  효율적인 취소 확인 private void OptimizedWork(CancellationToken cancellationToken) { const int checkInterval = 100; // 100번 작업마다 한 번씩 확인 int counter = 0; while (true) { // 실제 작업 DoSomeWork(); // 주기적으로만 취소 확인 if (++counter % checkInterval == 0) { cancellationToken.ThrowIfCancellationRequested(); } } }   ","version":null,"tagName":"h3"},{"title":"리소스 정리​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#리소스-정리","content":" 취소 시에도 리소스가 제대로 정리되도록 해야 합니다:  리소스 안전 정리 private void SafeResourceHandling(CancellationToken cancellationToken) { using var fileStream = new FileStream(&quot;data.txt&quot;, FileMode.Open); using var reader = new StreamReader(fileStream); try { while (!reader.EndOfStream) { cancellationToken.ThrowIfCancellationRequested(); var line = reader.ReadLine(); ProcessLine(line); } } catch (OperationCanceledException) { Console.WriteLine(&quot;파일 처리가 취소되었습니다.&quot;); // using 문에 의해 자동으로 리소스 정리됨 } }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#결론","content":" C#에서 Thread와 Parallel.ForEach를 안전하게 중단하는 핵심은 다음과 같습니다:  Thread.Abort() 사용 금지: .NET 5 이상에서 지원되지 않으며, .NET Framework에서도 안전하지 않습니다CancellationToken 활용: .NET Framework 4.0부터 지원되는 표준 취소 패턴으로 가장 권장되는 방법입니다플래그 패턴: 간단한 시나리오에서 사용할 수 있는 대안입니다프레임워크별 차이점 고려: .NET Framework 4.8과 .NET 5+ 간의 API 차이를 이해해야 합니다적절한 취소 확인: 성능과 반응성의 균형을 맞춰야 합니다리소스 정리: 취소 시에도 모든 리소스가 안전하게 해제되도록 해야 합니다  이러한 패턴들을 사용하면 리소스 누수나 데이터 손상 없이 멀티스레딩 작업을 안전하게 제어할 수 있습니다.  저희 팀에서 이 방법들을 도입한 후로는 사용자 취소 요청에 즉시 반응하는 안정적인 시스템을 구축할 수 있었어요. 특히 동료 개발자분이 제안해주신 CancellationToken 패턴 덕분에 코드도 훨씬 깔끔해졌습니다.  아직 개선할 부분이 많지만, 지속적으로 더 나은 방법을 찾아가겠습니다. 혹시 더 좋은 멀티스레딩 중단 방법이나 궁금한 점이 있으시면 언제든 댓글로 남겨주세요! 함께 고민해보면 좋겠어요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#참고-자료","content":" ","version":null,"tagName":"h2"},{"title":"공식 문서​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#공식-문서","content":" Thread.Abort Method - Microsoft Docs - Thread.Abort() 메서드 공식 문서 및 지원 중단 안내CancellationToken Struct - Microsoft Docs - CancellationToken 구조체 공식 문서Parallel.ForEach Method - Microsoft Docs - Parallel.ForEach 메서드 공식 문서Cancellation in Managed Threads - Microsoft Docs - 관리되는 스레드에서의 취소 패턴 가이드  ","version":null,"tagName":"h3"},{"title":"관련 기술 문서​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#관련-기술-문서","content":" Task-based Asynchronous Pattern (TAP) - Microsoft Docs - 비동기 프로그래밍 패턴Parallel Programming in .NET - Microsoft Docs - .NET 병렬 프로그래밍 가이드Best Practices for Managed Threading - Microsoft Docs - 관리되는 스레딩 모범 사례  ","version":null,"tagName":"h3"},{"title":"추가 학습 자료​","type":1,"pageTitle":"C#에서 Thread와 Parallel.ForEach 안전하게 중단하는 방법","url":"/blog/csharp-thread-parallel-foreach-safe-cancellation#추가-학습-자료","content":" Stephen Cleary's Blog - Async/Await Best Practices - 비동기 코드 모범 사례Eric Lippert's Blog - Cancellation - 취소 패턴에 대한 심화 설명 ","version":null,"tagName":"h3"},{"title":"Docker로 GDAL 간편하게 사용하기","type":0,"sectionRef":"#","url":"/blog/docker-gdal-geospatial-data-processing","content":"","keywords":"","version":null},{"title":"Docker에서 GDAL 이미지 찾기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker에서-gdal-이미지-찾기","content":" GitHub Container Registry에서 공식 GDAL 이미지를 제공합니다.    ghcr.io/osgeo/gdal 이미지를 선택하는 것이 좋습니다:  공식 이미지 선택 이유:  공식 지원: OSGeo에서 직접 관리하는 공식 이미지높은 신뢰성: 활발한 업데이트와 커뮤니티 지원다양한 버전: 여러 태그와 변형 버전 제공    ","version":null,"tagName":"h2"},{"title":"적절한 GDAL 이미지 선택하기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#적절한-gdal-이미지-선택하기","content":" Docker 이미지 선택 시 태그를 신중하게 고려해야 합니다.    ","version":null,"tagName":"h2"},{"title":"이미지 유형별 특징​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#이미지-유형별-특징","content":" 이미지 유형\t크기\t특징\t권장 용도ubuntu-full\t~1.5GB\t모든 드라이버 포함\t복잡한 데이터 처리 ubuntu-small\t~800MB\t주요 드라이버만 포함\t일반적인 용도 alpine-normal\t~200MB\tAlpine 기반, 대부분 드라이버\t균형잡힌 선택 alpine-small\t~20MB\t최소 드라이버만 포함\t경량화 우선  latest 이미지의 단점:  큰 용량: Ubuntu 기반으로 압축 상태에서도 936MB실행 시 용량: 압축 해제 후 수 GB의 디스크 공간 사용느린 다운로드: 네트워크 대역폭과 시간 소모  ","version":null,"tagName":"h3"},{"title":"Alpine Linux 기반 이미지 권장​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#alpine-linux-기반-이미지-권장","content":" Ubuntu가 필요하지 않다면 Alpine Linux 기반 이미지를 사용하는 것이 효율적입니다.    Alpine 이미지의 장점:  alpine-small: 약 20MB의 경량 크기빠른 다운로드: Ubuntu 대비 95% 용량 절약동일한 성능: GDAL 기능에 전혀 지장 없음보안 최적화: Alpine Linux의 보안 특화 설계  ","version":null,"tagName":"h3"},{"title":"버전 고정의 중요성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#버전-고정의-중요성","content":" 버전 관리 주의사항 프로덕션 환경에서는 특정 버전을 명시하는 것이 좋습니다: API 안정성: GDAL 버전 업데이트 시 매개변수 변경 가능성호환성 보장: 기존 스크립트와의 호환성 유지재현성: 동일한 환경에서의 일관된 결과  예시: ghcr.io/osgeo/gdal:alpine-small-3.9.0  ","version":null,"tagName":"h3"},{"title":"Docker GDAL 기본 사용법​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker-gdal-기본-사용법","content":" ","version":null,"tagName":"h2"},{"title":"Docker 실행 명령어 구조​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#docker-실행-명령어-구조","content":" Docker 실행 기본 구조 docker run [실행 파라미터] [도커이미지명:태그명] [컨테이너 안에서 실행할 명령들]   주요 실행 파라미터:  -it: 대화형 터미널 모드--rm: 컨테이너 종료 후 자동 삭제-v: 볼륨 마운트 (로컬 폴더와 컨테이너 폴더 연결)-w: 작업 디렉토리 설정-e: 환경 변수 설정  ","version":null,"tagName":"h3"},{"title":"볼륨 마운트 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#볼륨-마운트-설정","content":" Docker 컨테이너는 독립된 Linux 환경에서 실행됩니다. 로컬 파일에 접근하려면 볼륨 마운트가 필요합니다.  파일 시스템 분리:  컨테이너: 독립된 Linux 파일 시스템로컬: Windows 파일 시스템 (C:, D: 드라이브)해결책: 볼륨 마운트로 두 공간 연결  볼륨 마운트 문법 # Windows docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어] # macOS/Linux docker run -it --rm -v /home/user/data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   ","version":null,"tagName":"h3"},{"title":"실제 GDAL 도구 활용하기​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#실제-gdal-도구-활용하기","content":" ","version":null,"tagName":"h2"},{"title":"1. gdalinfo - 파일 정보 확인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-gdalinfo---파일-정보-확인","content":" 기본 파일 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /workspace/sample.tif   상세 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo -stats -hist -checksum /workspace/sample.tif     ","version":null,"tagName":"h3"},{"title":"2. gdal_translate - 파일 형식 변환​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-gdal_translate---파일-형식-변환","content":" TIFF를 PNG로 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of PNG /workspace/input.tif /workspace/output.png   압축 옵션과 함께 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co COMPRESS=LZW -co TILED=YES \\ /workspace/input.tif /workspace/compressed.tif   특정 밴드만 추출 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -b 1 -b 2 -b 3 /workspace/multispectral.tif /workspace/rgb.tif   ","version":null,"tagName":"h3"},{"title":"3. gdalwarp - 좌표계 변환 및 리프로젝션​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-gdalwarp---좌표계-변환-및-리프로젝션","content":" 좌표계 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:4326 /workspace/input.tif /workspace/wgs84.tif   리샘플링과 함께 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:3857 -r bilinear -tr 10 10 \\ /workspace/input.tif /workspace/webmercator.tif   여러 파일 모자이크 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp /workspace/tile1.tif /workspace/tile2.tif /workspace/tile3.tif \\ /workspace/mosaic.tif   ","version":null,"tagName":"h3"},{"title":"4. gdalbuildvrt - 가상 래스터 생성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#4-gdalbuildvrt---가상-래스터-생성","content":" 여러 파일을 하나의 VRT로 결합 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt /workspace/mosaic.vrt /workspace/*.tif   해상도별 오버뷰 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt -resolution highest /workspace/high_res.vrt /workspace/*.tif   ","version":null,"tagName":"h3"},{"title":"5. gdaldem - 지형 분석​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#5-gdaldem---지형-분석","content":" 경사도 계산 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem slope /workspace/dem.tif /workspace/slope.tif   음영기복도 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem hillshade -z 2 -s 1 /workspace/dem.tif /workspace/hillshade.tif   등고선 생성 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_contour -a elevation -i 10 /workspace/dem.tif /workspace/contours.shp   ","version":null,"tagName":"h3"},{"title":"6. gdal_calc.py - 래스터 계산​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#6-gdal_calcpy---래스터-계산","content":" NDVI 계산 (밴드 4: NIR, 밴드 3: Red) docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_calc.py -A /workspace/multispectral.tif --A_band=4 \\ -B /workspace/multispectral.tif --B_band=3 \\ --outfile=/workspace/ndvi.tif --calc=&quot;(A-B)/(A+B)&quot;   래스터 마스킹 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_calc.py -A /workspace/input.tif -B /workspace/mask.tif \\ --outfile=/workspace/masked.tif --calc=&quot;A*B&quot;   ","version":null,"tagName":"h3"},{"title":"벡터 데이터 처리 (OGR)​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#벡터-데이터-처리-ogr","content":" ","version":null,"tagName":"h2"},{"title":"1. ogrinfo - 벡터 파일 정보 확인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-ogrinfo---벡터-파일-정보-확인","content":" Shapefile 정보 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogrinfo /workspace/boundaries.shp   상세 정보와 속성 확인 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogrinfo -al -so /workspace/boundaries.shp   ","version":null,"tagName":"h3"},{"title":"2. ogr2ogr - 벡터 데이터 변환​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-ogr2ogr---벡터-데이터-변환","content":" Shapefile을 GeoJSON으로 변환 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON /workspace/output.geojson /workspace/input.shp   좌표계 변환과 함께 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON -t_srs EPSG:4326 \\ /workspace/wgs84.geojson /workspace/input.shp   속성 필터링 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ ogr2ogr -f GeoJSON -where &quot;POPULATION &gt; 100000&quot; \\ /workspace/large_cities.geojson /workspace/cities.shp   ","version":null,"tagName":"h3"},{"title":"실제 업무 시나리오​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#실제-업무-시나리오","content":" ","version":null,"tagName":"h2"},{"title":"시나리오 1: 위성영상 전처리 파이프라인​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-1-위성영상-전처리-파이프라인","content":" 1. 원본 영상 정보 확인 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /data/landsat8_raw.tif   2. 좌표계를 UTM으로 변환 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -t_srs EPSG:32652 -r cubic \\ /data/landsat8_raw.tif /data/landsat8_utm.tif   3. RGB 밴드만 추출하여 압축 docker run -it --rm -v c:\\satellite:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -b 4 -b 3 -b 2 -of GTiff -co COMPRESS=JPEG -co QUALITY=85 \\ /data/landsat8_utm.tif /data/landsat8_rgb.tif   ","version":null,"tagName":"h3"},{"title":"시나리오 2: DEM 데이터 분석​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-2-dem-데이터-분석","content":" 1. 여러 DEM 타일 병합 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalbuildvrt /data/merged_dem.vrt /data/dem_*.tif   2. 병합된 DEM을 단일 파일로 변환 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co COMPRESS=LZW \\ /data/merged_dem.vrt /data/merged_dem.tif   3. 경사도와 음영기복도 생성 docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem slope /data/merged_dem.tif /data/slope.tif docker run -it --rm -v c:\\dem:/data ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdaldem hillshade -z 2 /data/merged_dem.tif /data/hillshade.tif   ","version":null,"tagName":"h3"},{"title":"시나리오 3: 배치 처리 스크립트​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#시나리오-3-배치-처리-스크립트","content":" Windows 배치 파일 (process_images.bat) @echo off set IMAGE_NAME=ghcr.io/osgeo/gdal:alpine-small-3.9.0 set DATA_DIR=c:\\gis_data echo 이미지 처리 시작... for %%f in (%DATA_DIR%\\*.tif) do ( echo 처리 중: %%f docker run --rm -v %DATA_DIR%:/data %IMAGE_NAME% ^ gdal_translate -of GTiff -co COMPRESS=LZW &quot;%%f&quot; &quot;/data/compressed_%%~nf.tif&quot; ) echo 처리 완료!   ","version":null,"tagName":"h3"},{"title":"성능 최적화 팁​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#성능-최적화-팁","content":" ","version":null,"tagName":"h2"},{"title":"1. 메모리 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-메모리-설정","content":" 메모리 캐시 크기 설정 docker run -it --rm -v c:\\data:/workspace \\ -e GDAL_CACHEMAX=512 \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -wm 1024 /workspace/large_file.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"2. 멀티스레딩 활용​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-멀티스레딩-활용","content":" 멀티스레드 처리 docker run -it --rm -v c:\\data:/workspace \\ -e GDAL_NUM_THREADS=ALL_CPUS \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -multi /workspace/input.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"3. 타일링 최적화​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-타일링-최적화","content":" 타일 크기 최적화 docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=512 -co BLOCKYSIZE=512 \\ /workspace/input.tif /workspace/tiled.tif   ","version":null,"tagName":"h3"},{"title":"문제 해결 가이드​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#문제-해결-가이드","content":" ","version":null,"tagName":"h2"},{"title":"자주 발생하는 문제들​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#자주-발생하는-문제들","content":" 1. 권한 문제​  문제: 컨테이너에서 생성된 파일에 접근할 수 없음  해결책: 사용자 ID 매핑 사용  docker run -it --rm -v c:\\data:/workspace \\ --user $(id -u):$(id -g) \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   2. 메모리 부족​  문제: 대용량 파일 처리 시 메모리 부족  해결책:  Docker 메모리 제한 증가GDAL 캐시 크기 조정타일 단위 처리  docker run -it --rm -m 4g -v c:\\data:/workspace \\ -e GDAL_CACHEMAX=1024 \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 [명령어]   3. 좌표계 오류​  문제: 좌표계 정보가 없거나 잘못됨  해결책: 명시적 좌표계 지정  docker run -it --rm -v c:\\data:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalwarp -s_srs EPSG:4326 -t_srs EPSG:3857 \\ /workspace/input.tif /workspace/output.tif   ","version":null,"tagName":"h3"},{"title":"디버깅 팁​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#디버깅-팁","content":" 상세 로그 출력 docker run -it --rm -v c:\\data:/workspace \\ -e CPL_DEBUG=ON \\ ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo /workspace/problematic.tif   지원되는 형식 확인 docker run -it --rm ghcr.io/osgeo/gdal:alpine-small-3.9.0 \\ gdalinfo --formats   ","version":null,"tagName":"h3"},{"title":"고급 활용법​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#고급-활용법","content":" ","version":null,"tagName":"h2"},{"title":"1. Docker Compose 활용​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#1-docker-compose-활용","content":" docker-compose.yml version: '3.8' services: gdal: image: ghcr.io/osgeo/gdal:alpine-small-3.9.0 volumes: - ./data:/workspace working_dir: /workspace environment: - GDAL_CACHEMAX=512 - GDAL_NUM_THREADS=ALL_CPUS command: tail -f /dev/null # 컨테이너 유지   사용법 docker-compose up -d docker-compose exec gdal gdalinfo /workspace/sample.tif docker-compose down   ","version":null,"tagName":"h3"},{"title":"2. 별칭(Alias) 설정​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#2-별칭alias-설정","content":" Linux/macOS (.bashrc 또는 .zshrc) alias dgdal='docker run -it --rm -v $(pwd):/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0' alias dgdalinfo='dgdal gdalinfo' alias dgdaltranslate='dgdal gdal_translate' alias dgdalwarp='dgdal gdalwarp'   Windows (doskey 명령어) doskey dgdal=docker run -it --rm -v %cd%:/workspace ghcr.io/osgeo/gdal:alpine-small-3.9.0 $* doskey dgdalinfo=dgdal gdalinfo $*   ","version":null,"tagName":"h3"},{"title":"3. 사용자 정의 이미지 생성​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#3-사용자-정의-이미지-생성","content":" Dockerfile FROM ghcr.io/osgeo/gdal:alpine-small-3.9.0 # 추가 패키지 설치 RUN apk add --no-cache python3 py3-pip # Python 라이브러리 설치 RUN pip3 install numpy rasterio # 작업 디렉토리 설정 WORKDIR /workspace # 사용자 정의 스크립트 복사 COPY scripts/ /usr/local/bin/ # 실행 권한 부여 RUN chmod +x /usr/local/bin/*   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#결론","content":" Docker GDAL 사용의 핵심 장점:  설치 간소화: 복잡한 컴파일 과정 생략환경 독립성: 시스템 설정에 영향 없음일관된 결과: 운영체제 무관하게 동일한 실행 환경즉시 사용: 몇 분 만에 GDAL 활용 가능확장성: 필요에 따라 사용자 정의 이미지 생성 가능  Docker를 활용하면 GDAL 설치의 복잡함을 해결하고 지리공간 데이터 처리에 집중할 수 있습니다. 이 글에서 소개한 다양한 예제와 팁들을 활용하여 효율적인 GIS 워크플로우를 구축해보세요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"Docker로 GDAL 간편하게 사용하기","url":"/blog/docker-gdal-geospatial-data-processing#참고-자료","content":" GDAL 공식 문서GitHub Container Registry - osgeo/gdalGDAL Docker 이미지 소스코드Alpine Linux 공식 사이트Docker 공식 문서OGR 벡터 드라이버 목록GDAL 래스터 드라이버 목록 ","version":null,"tagName":"h2"},{"title":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","type":0,"sectionRef":"#","url":"/blog/lm-studio-local-ai-guide","content":"","keywords":"","version":null},{"title":"저희가 겪었던 AI API의 딜레마​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#저희가-겪었던-ai-api의-딜레마","content":" ","version":null,"tagName":"h2"},{"title":"1. 예상치 못한 비용 폭탄​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#1-예상치-못한-비용-폭탄","content":" 처음에는 &quot;API 비용이 얼마나 나올까?&quot;라고 생각했는데, 실제로는 상상을 초월했어요. 개발 중에 반복적으로 테스트하다 보니 하루에 수십 달러씩 나가더라고요.  팀장님이 &quot;이 속도로 가면 예산 초과할 것 같은데...&quot;라고 하시는 순간, 정말 머리가 하얘졌어요. 프로토타입 단계에서부터 이런 비용이면 실제 서비스는 어떻게 운영하지?  ","version":null,"tagName":"h3"},{"title":"2. 보안과 개인정보 우려​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#2-보안과-개인정보-우려","content":" 더 큰 고민은 보안이었어요. 고객 데이터를 외부 API로 전송해도 되는 건지 팀 내에서 계속 논의가 있었거든요.  특히 시니어 개발자분이 &quot;GDPR이나 개인정보보호법 관점에서 봤을 때 위험할 수 있어&quot;라고 하시면서, 대안을 찾아야 한다는 의견이 나왔어요.  ","version":null,"tagName":"h3"},{"title":"3. 의존성의 부담​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#3-의존성의-부담","content":" 인터넷이 끊기거나 API 서버에 문제가 생기면 저희 서비스도 함께 멈춰버린다는 점도 부담이었어요. &quot;이렇게 외부 서비스에 의존해도 될까?&quot;라는 고민이 계속 들었습니다.  ","version":null,"tagName":"h3"},{"title":"LM Studio와의 첫 만남​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#lm-studio와의-첫-만남","content":" ","version":null,"tagName":"h2"},{"title":"동료의 추천​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#동료의-추천","content":" 그때 저희 팀의 AI에 관심이 많은 동료분이 &quot;LM Studio라는 걸 찾았는데, 로컬에서 AI 모델을 돌릴 수 있다고 해요&quot;라고 알려주셨어요.  처음에는 &quot;진짜? 내 노트북에서 ChatGPT 같은 모델이 돌아간다고?&quot;라며 믿기지 않았죠. &quot;성능이 얼마나 나올까?&quot;라는 의구심도 있었고요.  ","version":null,"tagName":"h3"},{"title":"첫 설치와 실험​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#첫-설치와-실험","content":" LM Studio는 생각보다 설치가 간단했어요. lmstudio.ai에서 다운로드받아서 그냥 일반 프로그램처럼 설치하면 끝이더라고요.    처음 실행했을 때 &quot;이게 정말 AI 모델을 다운로드하는 프로그램이 맞나?&quot;라는 생각이 들 정도로 깔끔하고 직관적인 인터페이스였어요.  ","version":null,"tagName":"h3"},{"title":"첫 번째 모델 다운로드​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#첫-번째-모델-다운로드","content":" 동료분 조언에 따라 Llama 2 7B 모델부터 시작해봤어요. &quot;처음에는 작은 걸로 테스트해보세요&quot;라고 하시더라고요.    다운로드하는 동안 &quot;정말 이게 될까?&quot;라는 반신반의한 마음이었는데...  시스템 메모리 확인 필수 사용하는 시스템의 비디오 메모리에 따라 실행할 수 있는 모델의 용량이 제한됩니다. 모델을 다운로드하기 전에 시스템의 VRAM을 먼저 확인하세요.  ","version":null,"tagName":"h3"},{"title":"실제 테스트 결과와 놀라운 발견​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#실제-테스트-결과와-놀라운-발견","content":" ","version":null,"tagName":"h2"},{"title":"첫 번째 테스트: 기대 반 걱정 반​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#첫-번째-테스트-기대-반-걱정-반","content":" 4.68GB 크기의 DeepSeek R1-distill-qwen-7b 모델로 첫 테스트를 진행했어요.    한국어로 &quot;안녕&quot;을 입력했더니... 응답이 좀 이상하더라고요. 한국어 &quot;안녕!&quot;과 함께 알 수 없는 문자가 나왔어요. &quot;역시 로컬 모델은 한계가 있나?&quot;라는 생각이 들었죠.  ","version":null,"tagName":"h3"},{"title":"두 번째 시도: 더 나은 모델로​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#두-번째-시도-더-나은-모델로","content":" 포기하지 않고 동료분과 함께 더 최신 버전인 DeepSeek R1-0528 모델을 시도해봤어요.    이번에는 정말 깜짝 놀랐어요! 간단한 질문에 28.31초가 걸렸지만, 정상적인 한글 문장으로 답변이 나왔거든요. &quot;와, 진짜 내 노트북에서 AI가 답변을 만들어냈다!&quot;  속도는 아쉬웠지만, 오프라인 환경에서 로컬 노트북이 AI 답변을 생성한다는 점이 정말 신기했어요.  ","version":null,"tagName":"h3"},{"title":"저희 테스트 환경의 한계​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#저희-테스트-환경의-한계","content":"   저희가 테스트한 노트북은 100만원대의 평범한 AMD CPU 계열 내장그래픽이었어요. VRAM이 512MB에 불과해서 성능에 한계가 있었죠.  하지만 팀원 중에 고성능 그래픽카드를 가진 분이 테스트해보니 훨씬 빠른 속도로 동작하더라고요. &quot;이정도면 실제로 활용할 수 있겠는데?&quot;라는 생각이 들었어요.  ","version":null,"tagName":"h3"},{"title":"LM Studio의 핵심 장점들​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#lm-studio의-핵심-장점들","content":" ","version":null,"tagName":"h2"},{"title":"🔒 완벽한 개인정보 보호​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-완벽한-개인정보-보호","content":" 가장 마음에 든 점은 모든 데이터가 내 컴퓨터에서만 처리된다는 거예요. 더 이상 고객 데이터를 외부로 전송할 걱정이 없어졌죠.  팀장님도 &quot;이거면 보안 승인받기 훨씬 쉬울 것 같은데&quot;라고 하시면서 긍정적으로 반응해주셨어요.  ","version":null,"tagName":"h3"},{"title":"💰 비용 걱정 제로​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-비용-걱정-제로","content":" 초기 모델 다운로드 후에는 추가 비용이 전혀 발생하지 않아요. &quot;API 비용 걱정 없이 마음껏 테스트할 수 있겠네&quot;라는 생각에 정말 홀가분했어요.  ","version":null,"tagName":"h3"},{"title":"🌐 인터넷 독립성​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-인터넷-독립성","content":" 모델을 한번 다운로드하면 인터넷이 끊어져도 사용할 수 있어요. &quot;이제 외부 서비스 의존성 걱정은 없겠구나&quot;라는 안도감이 들었죠.  ","version":null,"tagName":"h3"},{"title":"🎨 개발자 친화적 인터페이스​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-개발자-친화적-인터페이스","content":" 복잡한 설정 없이도 OpenAI API와 호환되는 로컬 서버를 제공해요. 기존 코드를 거의 수정하지 않고도 연동할 수 있더라고요.  ","version":null,"tagName":"h3"},{"title":"시스템 요구사항과 현실적 고려사항​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#시스템-요구사항과-현실적-고려사항","content":" ","version":null,"tagName":"h2"},{"title":"최소 사양과 권장 사양​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#최소-사양과-권장-사양","content":" 실제 사용해본 결과 공식 권장사항은 다음과 같아요:  최소 사양:  macOS: M1/M2/M3 칩, macOS 13.6 이상Windows/Linux: AVX2 지원 CPU, 8GB RAM, 4GB 이상 VRAM  권장 사양:  RAM: 16GB 이상 (큰 모델의 경우 32GB 권장)GPU: NVIDIA RTX 시리즈 또는 Apple Silicon 칩저장공간: 모델 크기에 따라 10GB~100GB 이상  저희 경험상 성능이 좋을수록 응답 시간이 확실히 단축되더라고요.  ","version":null,"tagName":"h3"},{"title":"저희 팀의 활용 사례​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#저희-팀의-활용-사례","content":" ","version":null,"tagName":"h2"},{"title":"💻 프로토타입 개발​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-프로토타입-개발","content":" API 비용 걱정 없이 마음껏 테스트할 수 있어서 프로토타입 개발이 훨씬 수월해졌어요. &quot;이제 아이디어 검증을 자유롭게 할 수 있겠다&quot;는 생각이 들었어요.  ","version":null,"tagName":"h3"},{"title":"📝 문서 작성 도움​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-문서-작성-도움","content":" 기술 문서나 코드 주석 작성할 때 로컬 AI의 도움을 받고 있어요. 인터넷 없는 환경에서도 활용할 수 있어서 편리하더라고요.  ","version":null,"tagName":"h3"},{"title":"🔍 코드 리뷰 보조​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#-코드-리뷰-보조","content":" CodeLlama 모델을 사용해서 코드 리뷰나 버그 찾기에도 활용하고 있어요. 완벽하지는 않지만 보조 도구로는 충분히 유용해요.  ","version":null,"tagName":"h3"},{"title":"다른 도구들과의 비교​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#다른-도구들과의-비교","content":" 동료분과 함께 Ollama도 함께 비교해봤어요:  특징\tLM Studio\tOllama인터페이스\t그래픽(GUI)\t명령줄(CLI) 사용 편의성\t초보자도 쉽게 사용\t개발자 중심 모델 관리\t클릭으로 간편하게\t명령어로 관리  저희는 GUI를 선호해서 LM Studio가 더 맞았어요. 하지만 CLI를 좋아하는 팀원은 Ollama를 더 선호하더라고요.  ","version":null,"tagName":"h2"},{"title":"성능 최적화 팁과 노하우​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#성능-최적화-팁과-노하우","content":" ","version":null,"tagName":"h2"},{"title":"하드웨어 최적화​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#하드웨어-최적화","content":" 실제 사용하면서 터득한 팁들이에요:  GPU 가속 활용: NVIDIA 그래픽카드가 있다면 CUDA 가속을 꼭 활성화하세요메모리 관리: 다른 프로그램들을 종료하고 사용하면 성능이 확실히 좋아져요SSD 사용: 모델 로딩 시간이 확실히 단축됩니다  ","version":null,"tagName":"h3"},{"title":"모델 선택 전략​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#모델-선택-전략","content":" 팀에서 정한 모델 선택 기준이에요:  7B 모델부터 시작: 처음에는 작은 모델로 테스트양자화 모델 활용: Q4_K_M 같은 양자화 모델로 메모리 절약용도별 모델: 코딩, 채팅, 번역 등 목적에 맞게 선택  ","version":null,"tagName":"h3"},{"title":"주의사항과 한계점​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#주의사항과-한계점","content":" ","version":null,"tagName":"h2"},{"title":"라이선스 확인의 중요성​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#라이선스-확인의-중요성","content":" 라이선스 확인 필수 상업적 용도로 사용할 경우 각 모델의 라이선스를 반드시 확인하세요. 일부 모델은 상업적 사용이 제한될 수 있습니다.  팀에서 상업적 사용을 고려할 때 라이선스를 꼼꼼히 확인했어요. 생각보다 중요한 부분이더라고요.  ","version":null,"tagName":"h3"},{"title":"기타 실제 경험한 고려사항​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#기타-실제-경험한-고려사항","content":" 전력 소비: 고성능 GPU 사용 시 전기료가 생각보다 올라가요발열 관리: 긴 시간 사용하면 노트북이 뜨거워져서 쿨링팬이 계속 돌아가요성능 한계: 클라우드 서비스 대비 응답 속도는 여전히 아쉬워요  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#결론","content":" 저희 팀에서 LM Studio를 도입한 지 몇 달이 지났는데, 정말 만족하고 있어요. 특히 비용과 보안 문제를 동시에 해결해준 점이 가장 큰 장점이었어요.  물론 클라우드 서비스 대비 성능이나 편의성 면에서는 아직 아쉬운 부분들이 있어요. 하지만 개인정보 보호가 중요한 프로젝트나 비용을 절약해야 하는 상황에서는 정말 훌륭한 대안이라고 생각해요.  혹시 저희와 비슷한 고민을 하고 계신 분들이 있다면 한번 시도해보시길 추천드려요. 동료분이 알려주신 덕분에 저희 팀의 AI 활용 방식이 완전히 바뀌었거든요.  궁금한 점이나 실제 사용 경험을 공유하고 싶으시면 언제든 댓글로 남겨주세요! 함께 이야기해보면 좋겠어요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"LM Studio: 내 PC에서 AI 언어모델을 자유롭게 실행하는 방법","url":"/blog/lm-studio-local-ai-guide#참고-자료","content":" LM Studio 공식 홈페이지Hugging Face 모델 허브GGML/GGUF 포맷 가이드LM Studio 공식 문서로컬 LLM 성능 벤치마크 ","version":null,"tagName":"h2"},{"title":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","type":0,"sectionRef":"#","url":"/blog/microsoft-typescript-native-go-project-analysis","content":"","keywords":"","version":null},{"title":"저희가 겪었던 TypeScript의 현실적인 문제들​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#저희가-겪었던-typescript의-현실적인-문제들","content":" ","version":null,"tagName":"h2"},{"title":"1. 개발 시작부터 막히는 로딩 시간​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#1-개발-시작부터-막히는-로딩-시간","content":" 매일 아침 프로젝트를 열 때마다 느꼈던 답답함이 있었어요. VS Code에서 TypeScript 프로젝트를 열면 &quot;Initializing TypeScript...&quot;라는 메시지와 함께 거의 10초를 기다려야 했거든요.  팀원 중 한 분이 &quot;이거 매번 기다리는 시간만 계산해도 하루에 몇 분은 날아가는 것 같은데&quot;라고 하셨는데, 정말 공감이 갔어요.  ","version":null,"tagName":"h3"},{"title":"2. 빌드할 때마다 긴 대기 시간​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#2-빌드할-때마다-긴-대기-시간","content":" CI/CD 파이프라인에서도 문제였어요. TypeScript 컴파일과 타입 체크가 끝날 때까지 기다리는 시간이 점점 길어지더라고요.  개발팀장님이 &quot;빌드 시간이 너무 오래 걸려서 개발 속도가 떨어지고 있어. 뭔가 방법이 없을까?&quot;라고 하셨을 때 정말 마음이 무거웠어요.  ","version":null,"tagName":"h3"},{"title":"3. 메모리 사용량도 문제​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#3-메모리-사용량도-문제","content":" 노트북 메모리가 16GB인데도 TypeScript Language Server가 상당한 메모리를 잡아먹어서 다른 프로그램들이 느려지는 경우가 많았어요.  &quot;개발 도구가 개발을 방해하는 아이러니한 상황&quot;이라고 동료분이 농담 반 진담 반으로 말씀하셨는데, 정말 그랬어요.  ","version":null,"tagName":"h3"},{"title":"Microsoft TypeScript Native 프로젝트 발견​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#microsoft-typescript-native-프로젝트-발견","content":" ","version":null,"tagName":"h2"},{"title":"동료의 놀라운 소식​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#동료의-놀라운-소식","content":" 그때 저희 팀의 테크 리드분이 &quot;Microsoft에서 TypeScript를 Go로 재구현하는 프로젝트를 시작했다고 해. 성능이 엄청나게 좋아진다던데&quot;라고 알려주셨어요.  처음에는 &quot;Microsoft가 자기들이 만든 TypeScript를 다시 만든다고? 왜?&quot;라는 생각이 들었죠.  ","version":null,"tagName":"h3"},{"title":"공식 발표를 보고 놀란 점​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#공식-발표를-보고-놀란-점","content":" Microsoft 공식 블로그와 GitHub 레포지토리를 확인해보니 정말 대단한 프로젝트였어요:  빌드 시간 10배 단축에디터 응답 시간 8배 향상 (9.6초 → 1.2초)메모리 사용량 대폭 감소  &quot;이게 진짜라면 저희가 겪는 문제들이 모두 해결되겠는데?&quot;라는 생각에 정말 기대가 되었어요.  ","version":null,"tagName":"h3"},{"title":"Go 언어를 선택한 이유가 흥미로웠던 점​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#go-언어를-선택한-이유가-흥미로웠던-점","content":" ","version":null,"tagName":"h2"},{"title":"Microsoft의 전략적 선택​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#microsoft의-전략적-선택","content":" Microsoft TypeScript 팀의 Ryan Cavanaugh가 설명한 Go 선택 이유를 보니 정말 합리적이더라고요:  왜 Go인가?  구조적 타입 호환성: JavaScript의 동적 특성과 유사빠른 컴파일 속도: Go 자체가 컴파일이 빠름자동 가비지 수집: TypeScript의 메모리 모델과 잘 맞음교차 플랫폼 지원: 다양한 환경에서 동작  ","version":null,"tagName":"h3"},{"title":"다른 대안들과 비교한 이유​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#다른-대안들과-비교한-이유","content":" 왜 Rust나 C#이 아닌 Go인지도 설명되어 있었어요:  Rust: 너무 복잡하고 TypeScript의 직접적인 번역에 부적합C#: 객체 지향 패러다임 때문에 TypeScript 아키텍처 변경 필요C++: 메모리 관리 복잡성으로 개발 생산성 저하  &quot;Microsoft 엔지니어들이 정말 깊이 있게 고민했구나&quot;라는 생각이 들었어요.  ","version":null,"tagName":"h3"},{"title":"목표 성능 지표가 정말 인상적이었던 점​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#목표-성능-지표가-정말-인상적이었던-점","content":" ","version":null,"tagName":"h2"},{"title":"구체적인 개선 목표​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#구체적인-개선-목표","content":" Microsoft가 제시한 성능 목표를 보니 정말 야심찬 프로젝트더라고요:  항목\t현재 성능\t목표 성능\t개선 배율빌드 시간\t기준값\t기준값의 1/10\t10배 단축 에디터 응답 시간\t9.6초\t1.2초\t8배 향상 메모리 사용량\t기준값\t기준값의 50% 이하\t대폭 감소 타입 검사 속도\t기준값\t기준값의 1/5\t5배 향상  &quot;이 정도면 저희가 겪던 문제들이 정말 해결되겠는데?&quot;라는 생각에 기대가 컸어요.  ","version":null,"tagName":"h3"},{"title":"내부 벤치마크 결과​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#내부-벤치마크-결과","content":" Visual Studio Code에서 9.6초 걸리던 프로젝트 로딩이 1.2초로 단축되었다는 벤치마크 결과를 보고 정말 놀랐어요. &quot;이게 진짜라면 매일 아침 커피 마시며 기다릴 필요가 없겠네!&quot;  ","version":null,"tagName":"h3"},{"title":"개발 진행 상황을 직접 확인해본 경험​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#개발-진행-상황을-직접-확인해본-경험","content":" ","version":null,"tagName":"h2"},{"title":"GitHub 레포지토리 살펴보기​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#github-레포지토리-살펴보기","content":" 호기심에 GitHub 레포지토리를 직접 들어가봤어요. CI/CD 파이프라인이 정말 체계적으로 구축되어 있더라고요.  CI/CD 테스트 항목들:  lint - 코드 품질 검사test - 단위 테스트 및 통합 테스트build - 빌드 검증format - 코드 포맷팅baselines - 기준선 테스트 (가장 오래 걸림, 3분 30초)  총 실행 시간이 10분 31초인데, &quot;Microsoft가 정말 꼼꼼하게 품질 관리를 하고 있구나&quot;라는 생각이 들었어요.  ","version":null,"tagName":"h3"},{"title":"최근 커밋 활동​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#최근-커밋-활동","content":" 2025년 4월에도 &quot;Fix some bugs in tsc -w&quot; 관련 Pull Request가 올라오는 걸 보니 활발하게 개발이 진행되고 있는 것 같아서 안심이 되었어요.  ","version":null,"tagName":"h3"},{"title":"출시 일정과 저희 팀의 계획​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#출시-일정과-저희-팀의-계획","content":" ","version":null,"tagName":"h2"},{"title":"단계적 출시 계획​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#단계적-출시-계획","content":" Microsoft의 출시 계획을 보니 정말 신중하게 접근하고 있더라고요:  🚀 2025년 중반 - 미리보기 버전  명령줄 타입 검사 지원기존 워크플로우에 최소한의 변화개발자 피드백 수집  🎯 2025년 후반 - 완전 기능 버전  Visual Studio Code 완전 통합실시간 타입 검사모든 기능 지원  ","version":null,"tagName":"h3"},{"title":"저희 팀의 도입 계획​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#저희-팀의-도입-계획","content":" 팀 미팅에서 이 소식을 공유했더니 모든 분들이 관심을 보이셨어요.  팀장님: &quot;미리보기 버전이 나오면 테스트 프로젝트에서 먼저 써보자&quot; 시니어 개발자: &quot;안정성이 검증되면 점진적으로 도입해보는 게 좋겠네&quot;  저희도 2025년 하반기부터는 새로운 프로젝트에 적용해볼 계획이에요.  ","version":null,"tagName":"h3"},{"title":"기존 버전과의 호환성에 대한 안심​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#기존-버전과의-호환성에-대한-안심","content":" ","version":null,"tagName":"h2"},{"title":"이중 유지 관리 전략​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#이중-유지-관리-전략","content":" Microsoft가 기존 JavaScript 기반 TypeScript를 바로 폐기하지 않고 병행 유지한다고 해서 안심이 되었어요:  버전\t구현 언어\t상태\t지원 기간TypeScript 6.x\tJavaScript\t지속 유지\t최소 3년 TypeScript Native 7.x\tGo\t신규 출시\t장기 지원  &quot;기존 프로젝트들을 급하게 마이그레이션할 필요 없이 천천히 전환할 수 있겠네&quot;라는 생각에 부담이 덜했어요.  ","version":null,"tagName":"h3"},{"title":"다른 성능 도구들과의 관계​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#다른-성능-도구들과의-관계","content":" ","version":null,"tagName":"h2"},{"title":"보완적인 관계​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#보완적인-관계","content":" 동료분과 이야기해보니 TypeScript Native가 다른 도구들과 경쟁하기보다는 보완적인 관계가 될 것 같다는 의견이었어요:  SWC, esbuild: 번들링과 빌드 도구TypeScript Native: 타입 검사와 언어 서비스 개선  &quot;각자 역할이 다르니까 함께 쓰면 더 좋은 개발 환경이 될 것 같아&quot;라는 의견에 모두 동의했어요.  ","version":null,"tagName":"h3"},{"title":"저희 팀에게 기대되는 변화​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#저희-팀에게-기대되는-변화","content":" ","version":null,"tagName":"h2"},{"title":"일상적인 개발 경험 개선​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#일상적인-개발-경험-개선","content":" TypeScript Native가 도입되면 저희 일상이 어떻게 바뀔지 상상해봤어요:  아침에 프로젝트 열 때:  현재: &quot;로딩 중...&quot; 하며 커피 마시기 → 앞으로: 바로 개발 시작!  빌드할 때:  현재: 긴 대기 시간 → 앞으로: 빠른 피드백으로 개발 속도 향상  메모리 사용량:  현재: 노트북 팬 소리 → 앞으로: 더 쾌적한 개발 환경  ","version":null,"tagName":"h3"},{"title":"팀 생산성에 미칠 영향​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#팀-생산성에-미칠-영향","content":" 팀장님이 &quot;이 정도 성능 개선이면 우리 개발 속도가 정말 많이 빨라질 것 같은데&quot;라고 하시면서 기대하시더라고요.  특히 CI/CD 시간 단축으로 배포 주기도 빨라질 수 있을 것 같아서 기대돼요.  ","version":null,"tagName":"h3"},{"title":"우려되는 점들도 솔직히​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#우려되는-점들도-솔직히","content":" ","version":null,"tagName":"h2"},{"title":"초기 안정성 문제​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#초기-안정성-문제","content":" 새로운 도구다 보니 초기에는 버그나 예상치 못한 문제들이 있을 수 있겠죠. 시니어 개발자분이 &quot;미리보기 버전부터 차근차근 테스트해보자&quot;고 하신 이유도 그 때문인 것 같아요.  ","version":null,"tagName":"h3"},{"title":"학습 곡선​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#학습-곡선","content":" Go로 구현된다고 해서 저희가 Go를 배워야 하는 건 아니지만, 새로운 도구에 적응하는 시간은 필요할 것 같아요.  ","version":null,"tagName":"h3"},{"title":"생태계 적응 시간​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#생태계-적응-시간","content":" TypeScript 관련 도구들이 TypeScript Native를 완전히 지원하는 데까지는 시간이 걸릴 것 같아요.  ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#결론","content":" 저희 팀의 TypeScript 성능 문제를 겪으면서 Microsoft TypeScript Native 프로젝트를 알게 되었는데, 정말 혁신적인 시도라고 생각해요. 빌드 시간 10배 단축, 에디터 응답 시간 8배 향상이라는 목표가 달성된다면 개발자들의 일상이 완전히 바뀔 것 같아요.  물론 새로운 도구다 보니 초기에는 안정성이나 호환성 문제가 있을 수 있지만, Microsoft의 체계적인 접근 방식을 보면 신뢰할 만한 것 같아요. 특히 기존 버전을 병행 유지한다는 점에서 안심이 되고요.  저희 팀은 2025년 미리보기 버전부터 차근차근 테스트해보고, 안정성이 검증되면 점진적으로 도입할 계획이에요. 매일 아침 TypeScript 로딩을 기다리며 커피를 마시던 일상이 바뀔 날이 기대됩니다!  혹시 비슷한 성능 문제로 고민하고 계신 분들이 있다면 함께 지켜보면 좋겠어요. 동료분이 알려주신 덕분에 희망적인 소식을 알게 되었는데, 더 많은 개발자들과 이런 정보를 공유하고 싶어요.  궁금한 점이나 TypeScript 성능 관련 경험을 공유하고 싶으시면 언제든 댓글로 남겨주세요! 함께 이야기해보면 좋겠어요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"Microsoft TypeScript Native 프로젝트 분석: Go 기반 성능 혁신의 새로운 전환점","url":"/blog/microsoft-typescript-native-go-project-analysis#참고-자료","content":" Microsoft TypeScript Native GitHub RepositoryMicrosoft 공식 블로그 발표TypeScript Performance 가이드Go 언어 공식 문서 ","version":null,"tagName":"h2"},{"title":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","type":0,"sectionRef":"#","url":"/blog/oklch-color-space-web-design","content":"","keywords":"","version":null},{"title":"왜 새로운 색상 모델이 필요할까?​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#왜-새로운-색상-모델이-필요할까","content":" 다음 두 색상을 보세요:  hsl(240, 100%, 50%) (파란색)hsl(60, 100%, 50%) (노란색)  HSL에서는 둘 다 밝기(L)가 50%로 동일하지만, 실제로는 노란색이 훨씬 밝게 보입니다. 이것이 바로 기존 색상 모델의 한계입니다.    OKLCH는 이런 문제를 해결하기 위해 인간의 시각 인지 방식에 맞게 설계된 색상 공간입니다.  ","version":null,"tagName":"h2"},{"title":"OKLCH 기본 개념​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#oklch-기본-개념","content":" OKLCH는 세 가지 요소로 구성됩니다:  요소\t의미\t범위\t설명L\tLightness (밝기)\t0-1\t0은 검정, 1은 흰색 C\tChroma (채도)\t0-0.4+\t0은 무채색, 높을수록 선명 H\tHue (색상)\t0-360\t색상환의 각도 (빨강=30°, 파랑=250°)  /* OKLCH 문법 */ color: oklch(L C H); /* 예시: 밝은 파란색 */ color: oklch(0.7 0.25 250);   ","version":null,"tagName":"h2"},{"title":"기존 색상 모델과의 비교​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#기존-색상-모델과의-비교","content":" ","version":null,"tagName":"h2"},{"title":"RGB vs HSL vs OKLCH​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#rgb-vs-hsl-vs-oklch","content":" /* 같은 빨간색을 다른 방식으로 표현 */ .red-rgb { color: rgb(255, 65, 54); } .red-hsl { color: hsl(4, 100%, 61%); } .red-oklch { color: oklch(0.63 0.26 29); }     핵심 차이점:  RGB: 기계 중심적, 직관적이지 않음HSL: 인간 친화적이지만 지각적으로 부정확OKLCH: 인간의 시각 인지와 일치하는 정확성  ","version":null,"tagName":"h3"},{"title":"OKLCH의 3가지 핵심 장점​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#oklch의-3가지-핵심-장점","content":" ","version":null,"tagName":"h2"},{"title":"1. 🎯 지각적 균일성 (Perceptual Uniformity)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#1--지각적-균일성-perceptual-uniformity","content":" 문제: HSL에서 밝기 50%인 모든 색상이 실제로는 다르게 보임해결: OKLCH에서 같은 L값은 실제로 같은 밝기로 인지됨  /* HSL: 같은 밝기(50%)지만 실제로는 다르게 보임 */ .hsl-colors { --yellow: hsl(60, 100%, 50%); /* 매우 밝게 보임 */ --blue: hsl(240, 100%, 50%); /* 상대적으로 어둡게 보임 */ } /* OKLCH: 실제로 같은 밝기로 인지됨 */ .oklch-colors { --yellow: oklch(0.9 0.2 90); /* 지각적으로 같은 밝기 */ --blue: oklch(0.9 0.2 250); /* 지각적으로 같은 밝기 */ }   실용적 이점:  ✅ 일관된 색상 팔레트 생성✅ 정확한 접근성 대비율 계산✅ 자연스러운 색상 애니메이션  ","version":null,"tagName":"h3"},{"title":"2. 🌈 넓은 색영역 지원 (Wide Gamut)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#2--넓은-색영역-지원-wide-gamut","content":" sRGB vs P3 색영역:  sRGB: 1990년대 표준, 제한적인 색상 범위P3: 현대 디스플레이 표준, 25% 더 넓은 색상 범위  /* sRGB 범위 내의 일반적인 빨간색 */ .normal-red { background: rgb(255, 0, 0); } /* P3 색영역을 활용한 더 생생한 빨간색 */ .vivid-red { background: oklch(0.6 0.35 30); /* sRGB 범위를 넘어서는 값 */ }     지원 기기:  iPhone 7 이후 모든 iPhone2016년 이후 MacBook Pro최신 Android 플래그십 기기고급 모니터 (DCI-P3, Adobe RGB 지원)  ","version":null,"tagName":"h3"},{"title":"3. 🎨 직관적인 색상 조작​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#3--직관적인-색상-조작","content":" OKLCH는 각 요소를 독립적으로 조절할 수 있어 디자인 시스템 구축이 쉽습니다:  :root { /* 기본 브랜드 색상 */ --brand-primary: oklch(0.6 0.25 250); /* 밝기 변형 (색상과 채도는 유지) */ --brand-light: oklch(0.8 0.25 250); --brand-dark: oklch(0.4 0.25 250); /* 채도 변형 (색상과 밝기는 유지) */ --brand-vibrant: oklch(0.6 0.35 250); --brand-muted: oklch(0.6 0.1 250); /* 색상 변형 (밝기와 채도는 유지) */ --brand-warm: oklch(0.6 0.25 30); /* 빨간색 계열 */ --brand-cool: oklch(0.6 0.25 200); /* 청록색 계열 */ }   ","version":null,"tagName":"h3"},{"title":"실전 활용 사례​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#실전-활용-사례","content":" ","version":null,"tagName":"h2"},{"title":"🎨 완벽한 색상 팔레트 만들기​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-완벽한-색상-팔레트-만들기","content":" /* 지각적으로 균일한 무지개 색상 */ .rainbow-palette { --red: oklch(0.65 0.25 30); --orange: oklch(0.65 0.25 60); --yellow: oklch(0.65 0.25 90); --green: oklch(0.65 0.25 140); --blue: oklch(0.65 0.25 250); --purple: oklch(0.65 0.25 320); }   결과: 모든 색상이 동일한 밝기와 채도로 느껴져서 조화로운 팔레트 완성  ","version":null,"tagName":"h3"},{"title":"🌓 다크/라이트 모드 전환​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-다크라이트-모드-전환","content":" :root { /* 라이트 모드 */ --text: oklch(0.2 0 0); /* 거의 검정 */ --background: oklch(0.98 0 0); /* 거의 흰색 */ --accent: oklch(0.6 0.25 250); /* 브랜드 블루 */ } @media (prefers-color-scheme: dark) { :root { /* 다크 모드: 밝기만 반전, 색상은 유지 */ --text: oklch(0.98 0 0); --background: oklch(0.15 0 0); --accent: oklch(0.7 0.25 250); /* 다크 모드에서는 조금 더 밝게 */ } }   ","version":null,"tagName":"h3"},{"title":"🎬 자연스러운 색상 애니메이션​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-자연스러운-색상-애니메이션","content":" .button { background: oklch(0.6 0.2 250); transition: background-color 0.3s ease; } .button:hover { /* 채도만 증가시켜서 자연스러운 강조 효과 */ background: oklch(0.6 0.3 250); } .button:active { /* 밝기를 줄여서 눌린 효과 */ background: oklch(0.5 0.3 250); }     ","version":null,"tagName":"h3"},{"title":"브라우저 지원 및 사용법​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#브라우저-지원-및-사용법","content":" ","version":null,"tagName":"h2"},{"title":"현재 지원 현황 (2025년 기준)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#현재-지원-현황-2025년-기준","content":" 브라우저\t지원 버전\t시장 점유율Chrome\t111+\t✅ 95%+ Safari\t15.4+\t✅ 95%+ Firefox\t113+\t✅ 90%+ Edge\t111+\t✅ 95%+  ","version":null,"tagName":"h3"},{"title":"안전한 사용법 (Fallback 제공)​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#안전한-사용법-fallback-제공","content":" .element { /* 구형 브라우저용 fallback */ background: #3b82f6; /* 최신 브라우저용 OKLCH */ background: oklch(0.6 0.25 250); } /* 또는 @supports를 사용한 점진적 향상 */ @supports (color: oklch(0 0 0)) { .element { background: oklch(0.6 0.25 250); } }   ","version":null,"tagName":"h3"},{"title":"유용한 도구들​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#유용한-도구들","content":" ","version":null,"tagName":"h2"},{"title":"1. 🎨 OKLCH 색상 피커​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#1--oklch-색상-피커","content":" 직관적인 색상 선택 인터페이스실시간 RGB/HSL 변환접근성 대비율 확인  ","version":null,"tagName":"h3"},{"title":"2. 🔧 Colorjs.io​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#2--colorjsio","content":" 색상 변환 JavaScript 라이브러리다양한 색상 공간 지원색상 계산 및 조작 기능  ","version":null,"tagName":"h3"},{"title":"3. 📊 CSS 색상 변환기​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#3--css-색상-변환기","content":" 기존 색상을 OKLCH로 변환배치 변환 지원색상 팔레트 생성  ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"단계별 전환 방법​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#단계별-전환-방법","content":" 1단계: 주요 브랜드 색상부터 시작  /* 기존 */ --primary: #3b82f6; /* 변환 후 */ --primary: #3b82f6; /* fallback */ --primary: oklch(0.6 0.25 250); /* modern */   2단계: 색상 팔레트 체계화  /* 기존: 일관성 없는 색상들 */ --blue-100: #dbeafe; --blue-500: #3b82f6; --blue-900: #1e3a8a; /* 개선: OKLCH로 체계적인 팔레트 */ --blue-100: oklch(0.95 0.05 250); --blue-500: oklch(0.6 0.25 250); --blue-900: oklch(0.3 0.25 250);   3단계: 애니메이션 및 상호작용 개선  /* 더 자연스러운 hover 효과 */ .card:hover { background: oklch(from var(--card-bg) calc(l + 0.05) c h); }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#결론","content":" OKLCH는 웹 디자인의 색상 처리 방식을 근본적으로 개선하는 혁신적인 도구입니다:  ","version":null,"tagName":"h2"},{"title":"🎯 핵심 이점​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-핵심-이점","content":" 정확성: 인간의 시각 인지와 일치하는 색상 제어일관성: 지각적으로 균일한 색상 팔레트 생성미래성: 차세대 디스플레이 기술 완벽 지원효율성: 직관적인 색상 조작으로 개발 시간 단축  ","version":null,"tagName":"h3"},{"title":"🚀 지금 시작해야 하는 이유​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#-지금-시작해야-하는-이유","content":" 광범위한 브라우저 지원: 이미 95% 이상의 최신 브라우저에서 지원점진적 도입 가능: fallback을 통해 안전하게 전환 가능경쟁 우위: 더 정교하고 아름다운 색상 디자인으로 차별화접근성 향상: WCAG 기준을 더 쉽게 충족  OKLCH는 단순한 트렌드가 아닌 웹 디자인의 새로운 표준입니다. 지금 시작해서 더 나은 사용자 경험을 만들어보세요.    ","version":null,"tagName":"h3"},{"title":"참고 자료​","type":1,"pageTitle":"OKLCH 색상 공간: 웹 디자인의 새로운 표준","url":"/blog/oklch-color-space-web-design#참고-자료","content":" DaleSeo - CSS에서 OKLCH 색상 사용하기Velog - CSS RGB, HSL 그리고 OklchEvil Martians - OKLCH in CSS: why quit RGB &amp; HSLOKLCH 공식 사이트CSS Color Module Level 4 명세 ","version":null,"tagName":"h2"},{"title":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","type":0,"sectionRef":"#","url":"/blog/next-yak-nextjs-css-in-js","content":"","keywords":"","version":null},{"title":"next-yak가 해결하는 문제​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#next-yak가-해결하는-문제","content":" 기존 CSS-in-JS 라이브러리들의 주요 문제점:  런타임 성능 오버헤드  스타일 생성과 주입이 런타임에 발생JavaScript 번들 크기 증가 (styled-components: ~40KB)초기 렌더링 지연과 hydration 성능 저하  Server-Side Rendering 복잡성  서버와 클라이언트 간 스타일 동기화 문제추가적인 설정과 보일러플레이트 코드 필요React Server Components와의 제한적 호환성  next-yak는 이러한 문제들을 빌드 타임 CSS 추출을 통해 근본적으로 해결합니다.  ","version":null,"tagName":"h2"},{"title":"핵심 특징​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#핵심-특징","content":" ","version":null,"tagName":"h2"},{"title":"1. Zero-runtime 아키텍처​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#1-zero-runtime-아키텍처","content":" 빌드 타임에 모든 스타일을 정적 CSS로 변환하여 런타임 오버헤드를 제거합니다:  개발 시 작성하는 코드 import { styled } from 'next-yak'; const Button = styled.button` background: #007bff; color: white; padding: 12px 24px; border-radius: 6px; border: none; cursor: pointer; &amp;:hover { background: #0056b3; } `;   빌드 후 생성되는 코드 const Button = ({ children, ...props }) =&gt; ( &lt;button className=&quot;button-abc123&quot; {...props}&gt; {children} &lt;/button&gt; );   생성되는 CSS 파일 .button-abc123 { background: #007bff; color: white; padding: 12px 24px; border-radius: 6px; border: none; cursor: pointer; } .button-abc123:hover { background: #0056b3; }   ","version":null,"tagName":"h3"},{"title":"2. React Server Components 완벽 지원​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#2-react-server-components-완벽-지원","content":" Next.js 13+의 App Router와 Server Components에서 추가 설정 없이 작동합니다:  app/components/ServerButton.tsx import { styled } from 'next-yak'; const ServerButton = styled.button` background: linear-gradient(45deg, #fe6b8b 30%, #ff8e53 90%); border: 0; border-radius: 8px; color: white; padding: 12px 24px; font-weight: 500; `; export default function Page() { return ( &lt;ServerButton&gt; 서버에서 렌더링되는 버튼 &lt;/ServerButton&gt; ); }   ","version":null,"tagName":"h3"},{"title":"3. 동적 스타일링 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#3-동적-스타일링-최적화","content":" props를 통한 동적 스타일링도 빌드 타임에 최적화됩니다:  동적 스타일링 예제 import { styled, css } from 'next-yak'; const Alert = styled.div&lt;{ $variant: 'success' | 'warning' | 'error'; $size?: 'small' | 'large'; }&gt;` padding: ${props =&gt; props.$size === 'small' ? '8px 12px' : '16px 24px'}; border-radius: 6px; font-weight: 500; ${props =&gt; { switch (props.$variant) { case 'success': return css` background: #d4edda; color: #155724; border: 1px solid #c3e6cb; `; case 'warning': return css` background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; `; case 'error': return css` background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; `; } }} `;   ","version":null,"tagName":"h3"},{"title":"설치 및 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#설치-및-설정","content":" ","version":null,"tagName":"h2"},{"title":"패키지 설치​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#패키지-설치","content":" npm install next-yak   ","version":null,"tagName":"h3"},{"title":"Next.js 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#nextjs-설정","content":" next.config.js 파일에 next-yak 플러그인을 추가합니다:  next.config.js const { withYak } = require('next-yak/withYak'); /** @type {import('next').NextConfig} */ const nextConfig = { // 기존 설정들... }; module.exports = withYak(nextConfig);   ","version":null,"tagName":"h3"},{"title":"TypeScript 설정​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#typescript-설정","content":" TypeScript 프로젝트에서는 타입 정의를 추가합니다:  tsconfig.json { &quot;compilerOptions&quot;: { &quot;types&quot;: [&quot;next-yak&quot;] } }   ","version":null,"tagName":"h3"},{"title":"실무 활용 패턴​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#실무-활용-패턴","content":" ","version":null,"tagName":"h2"},{"title":"1. 컴포넌트 시스템 구축​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#1-컴포넌트-시스템-구축","content":" components/Button.tsx import { styled, css } from 'next-yak'; const sizes = { small: css` padding: 6px 12px; font-size: 14px; min-height: 32px; `, medium: css` padding: 8px 16px; font-size: 16px; min-height: 40px; `, large: css` padding: 12px 24px; font-size: 18px; min-height: 48px; `, }; const variants = { primary: css` background: #007bff; color: white; &amp;:hover:not(:disabled) { background: #0056b3; } `, outline: css` background: transparent; color: #007bff; border: 1px solid #007bff; &amp;:hover:not(:disabled) { background: #007bff; color: white; } `, }; export const Button = styled.button&lt;{ $size?: keyof typeof sizes; $variant?: keyof typeof variants; }&gt;` display: inline-flex; align-items: center; justify-content: center; border: none; border-radius: 6px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; &amp;:disabled { opacity: 0.6; cursor: not-allowed; } ${props =&gt; sizes[props.$size || 'medium']} ${props =&gt; variants[props.$variant || 'primary']} `;   ","version":null,"tagName":"h3"},{"title":"2. 반응형 레이아웃​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#2-반응형-레이아웃","content":" components/Grid.tsx import { styled } from 'next-yak'; export const Grid = styled.div&lt;{ $columns?: number }&gt;` display: grid; gap: 20px; padding: 20px; /* 모바일 */ grid-template-columns: 1fr; /* 태블릿 */ @media (min-width: 768px) { grid-template-columns: repeat(2, 1fr); gap: 30px; } /* 데스크톱 */ @media (min-width: 1024px) { grid-template-columns: repeat(${props =&gt; props.$columns || 3}, 1fr); gap: 40px; } `; export const GridItem = styled.div` background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: transform 0.2s ease; &amp;:hover { transform: translateY(-4px); } `;   ","version":null,"tagName":"h3"},{"title":"성능 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#성능-최적화","content":" ","version":null,"tagName":"h2"},{"title":"빌드 설정 최적화​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#빌드-설정-최적화","content":" next.config.js const { withYak } = require('next-yak/withYak'); const isDev = process.env.NODE_ENV === 'development'; const nextConfig = { // 기존 설정들... }; module.exports = withYak(nextConfig, { cssOptimization: { // 프로덕션에서만 최적화 활성화 minify: !isDev, removeDuplicates: !isDev, purgeUnused: !isDev, }, });   ","version":null,"tagName":"h3"},{"title":"성능 측정 결과​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#성능-측정-결과","content":" 실제 프로덕션 환경에서 측정한 성능 개선 결과:  메트릭\tstyled-components\tnext-yak\t개선율JavaScript 번들 크기\t245KB\t198KB\t19% 감소 First Contentful Paint\t1.2s\t0.9s\t25% 향상 Time to Interactive\t2.8s\t2.3s\t18% 향상 Cumulative Layout Shift\t0.15\t0.08\t47% 향상  ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"styled-components에서 마이그레이션​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#styled-components에서-마이그레이션","content":" 기존 styled-components 코드를 next-yak로 마이그레이션하는 방법:  // Before (styled-components) import styled from 'styled-components'; const Button = styled.button` background: ${props =&gt; props.primary ? 'blue' : 'white'}; color: ${props =&gt; props.primary ? 'white' : 'blue'}; `; // 사용법: &lt;Button primary&gt;Click me&lt;/Button&gt;   // After (next-yak) import { styled } from 'next-yak'; const Button = styled.button&lt;{ $primary?: boolean }&gt;` background: ${props =&gt; props.$primary ? 'blue' : 'white'}; color: ${props =&gt; props.$primary ? 'white' : 'blue'}; `; // 사용법: &lt;Button $primary&gt;Click me&lt;/Button&gt;   주요 변경사항:  props 이름에 $ 접두사 추가 (DOM에 전달되지 않는 props)import 구문 변경기본 API는 동일하게 유지  ","version":null,"tagName":"h3"},{"title":"점진적 마이그레이션 전략​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#점진적-마이그레이션-전략","content":" 혼합 사용 예제 // 기존 컴포넌트와 새 컴포넌트를 함께 사용 import StyledButton from './legacy/StyledButton'; // styled-components import { Button } from './components/Button'; // next-yak export default function MixedPage() { return ( &lt;div&gt; &lt;StyledButton&gt;기존 버튼&lt;/StyledButton&gt; &lt;Button $variant=&quot;primary&quot;&gt;새 버튼&lt;/Button&gt; &lt;/div&gt; ); }   ","version":null,"tagName":"h3"},{"title":"트러블슈팅​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#트러블슈팅","content":" ","version":null,"tagName":"h2"},{"title":"자주 발생하는 문제​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#자주-발생하는-문제","content":" 빌드 에러 해결  # 캐시 클리어 후 재설치 rm -rf .next node_modules package-lock.json npm install   타입 에러 해결  // 명시적 타입 정의로 해결 interface ButtonProps { $variant: 'primary' | 'secondary'; $size: 'small' | 'medium' | 'large'; } const Button = styled.button&lt;ButtonProps&gt;` /* 스타일 정의 */ `;   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#결론","content":" next-yak는 Next.js 프로젝트에서 CSS-in-JS의 성능 문제를 근본적으로 해결하는 실용적인 솔루션입니다.  핵심 이점:  성능: 런타임 오버헤드 완전 제거로 20% 이상 성능 향상호환성: React Server Components 완벽 지원개발자 경험: 기존 styled-components와 동일한 API확장성: 대규모 프로젝트에서도 안정적인 성능  특히 성능이 중요한 프로덕션 환경에서 기존 CSS-in-JS 라이브러리의 한계를 뛰어넘는 탁월한 대안입니다. 점진적 마이그레이션이 가능하므로 기존 프로젝트에서도 부담 없이 도입할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"next-yak: Next.js를 위한 러스트 기반 Zero-runtime CSS-in-JS","url":"/blog/next-yak-nextjs-css-in-js#참고-자료","content":" next-yak 공식 문서GitHub 저장소Next.js App Router 가이드React Server Components 문서 ","version":null,"tagName":"h2"},{"title":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","type":0,"sectionRef":"#","url":"/blog/shell-script-no-such-file-directory-fix","content":"","keywords":"","version":null},{"title":"저희가 겪었던 문제 상황​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#저희가-겪었던-문제-상황","content":" ","version":null,"tagName":"h2"},{"title":"당황스러웠던 첫 번째 에러​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#당황스러웠던-첫-번째-에러","content":" 팀에서 CI/CD 파이프라인을 구축하면서 Windows 개발 환경에서 배포 스크립트를 작성했어요. 로컬에서는 Git Bash로 테스트해서 잘 동작했는데, 리눅스 서버에 올리니까 이런 오류가 나오는 거예요:  line 1: #!/bin/sh: No such file or directory   처음에는 &quot;어? 권한 문제인가?&quot; 하면서 chmod +x도 해보고, 경로도 확인해봤는데 모든 게 정상이었어요. 정말 이상했죠.  ","version":null,"tagName":"h3"},{"title":"동료와 함께한 디버깅 과정​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#동료와-함께한-디버깅-과정","content":" 팀장님과 시니어 개발자분이 함께 원인을 찾아보자고 하셨어요. 처음에는 다음과 같은 것들을 시도해봤습니다:  # 파일이 정말 있는지 확인 ls -la deploy.sh # 권한 문제인지 확인 chmod +x deploy.sh # 직접 bash로 실행해보기 bash deploy.sh   그런데 이상하게도 bash deploy.sh로 직접 실행하면 동작하는데, ./deploy.sh로는 안 되는 거예요. &quot;이게 뭐지?&quot;라는 생각이 계속 들었어요.  ","version":null,"tagName":"h3"},{"title":"시니어 개발자의 조언​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#시니어-개발자의-조언","content":" 그때 시니어 개발자분이 &quot;제가 예전에 비슷한 문제를 겪어본 적이 있는데, 줄바꿈 문제일 수도 있어요&quot;라고 하시면서 이런 명령어를 알려주셨어요:  # 파일의 숨겨진 문자들을 보기 cat -v deploy.sh   실행해보니까 각 줄 끝에 ^M 이라는 이상한 문자가 붙어있더라고요! &quot;아, 이게 문제였구나!&quot;라는 생각에 정말 깨달음이 왔어요.  ","version":null,"tagName":"h3"},{"title":"왜 이런 문제가 발생하는지 알게 된 과정​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#왜-이런-문제가-발생하는지-알게-된-과정","content":" ","version":null,"tagName":"h2"},{"title":"운영체제별 줄바꿈 방식의 차이​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#운영체제별-줄바꿈-방식의-차이","content":" 시니어 개발자분이 친절하게 설명해주셨어요:  운영체제\t줄바꿈 문자\t16진수 표현\t설명Windows/DOS\t\\r\\n\t0D 0A\tCarriage Return + Line Feed Unix/Linux\t\\n\t0A\tLine Feed만 사용  &quot;Windows에서는 줄바꿈이 두 개 문자로 표현되는데, Linux에서는 하나만 쓰거든요. 그래서 shebang이 /bin/bash\\r로 인식되는 거예요&quot;라고 설명해주시니까 이해가 됐어요.  ","version":null,"tagName":"h3"},{"title":"문제를 확인하는 방법들​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#문제를-확인하는-방법들","content":" 동료분이 알려준 여러 가지 확인 방법들:  # 16진수로 파일 내용 확인 hexdump -C script.sh | head # 시각적으로 확인 cat -v script.sh # 더 자세한 정보 od -bc script.sh   이런 명령어들을 써보니 문제를 정확히 파악할 수 있었어요.  ","version":null,"tagName":"h3"},{"title":"여러 해결 방법을 시도해본 경험​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#여러-해결-방법을-시도해본-경험","content":" ","version":null,"tagName":"h2"},{"title":"1. dos2unix 명령어 (가장 효과적이었던 방법)​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#1-dos2unix-명령어-가장-효과적이었던-방법","content":" 시니어 개발자분이 &quot;가장 간단한 방법&quot;이라고 추천해주신 방법이에요:  # dos2unix 설치 sudo apt-get install dos2unix # 파일 변환 dos2unix deploy.sh   실행해보니까 정말 간단하게 해결되더라고요! &quot;이런 편리한 도구가 있었구나!&quot;라는 생각이 들었어요.  ","version":null,"tagName":"h3"},{"title":"2. sed 명령어로 직접 해결​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#2-sed-명령어로-직접-해결","content":" 팀 내 리눅스 고수분이 &quot;sed로도 할 수 있어요&quot;라고 알려주신 방법:  # 캐리지 리턴 문자 제거 sed -i 's/\\r$//' deploy.sh # 원본 파일 백업하면서 변환 sed -i.bak 's/\\r$//' deploy.sh   이 방법도 잘 동작했는데, &quot;sed 정말 만능이네요&quot;라고 감탄했던 기억이 있어요.  ","version":null,"tagName":"h3"},{"title":"3. vim에서 직접 변환​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#3-vim에서-직접-변환","content":" 에디터에서 바로 해결하는 방법도 배웠어요:  # vim으로 파일 열기 vim deploy.sh # 명령 모드에서 :set ff=unix :wq   &quot;에디터에서도 이런 게 되는구나!&quot; 하면서 또 하나 배웠죠.  ","version":null,"tagName":"h3"},{"title":"재발 방지를 위한 팀 차원의 대책​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#재발-방지를-위한-팀-차원의-대책","content":" ","version":null,"tagName":"h2"},{"title":"Git 설정으로 예방하기​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#git-설정으로-예방하기","content":" 이 문제를 겪고 나서 팀에서 재발 방지책을 논의했어요. 팀장님이 &quot;앞으로는 이런 문제가 없도록 Git 설정을 통일하자&quot;고 하셨어요:  # 팀 전체가 이 설정을 적용하기로 했어요 git config --global core.autocrlf false git config --global core.eol lf   ","version":null,"tagName":"h3"},{"title":".gitattributes 파일 생성​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#gitattributes-파일-생성","content":" 프로젝트 루트에 .gitattributes 파일을 만들어서 팀 차원에서 관리하기로 했어요:  # 모든 텍스트 파일은 LF 사용 * text=auto eol=lf # 스크립트 파일은 반드시 LF 사용 *.sh text eol=lf *.bash text eol=lf # Windows 배치 파일은 CRLF 사용 *.bat text eol=crlf *.cmd text eol=crlf   팀원분이 &quot;이렇게 하면 앞으로는 자동으로 처리되겠네요!&quot;라고 하시면서 모두 만족스러워했어요.  ","version":null,"tagName":"h3"},{"title":"VS Code 설정 통일​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#vs-code-설정-통일","content":" 저희 팀이 VS Code를 주로 사용해서 설정도 통일했어요:  { &quot;files.eol&quot;: &quot;\\n&quot;, &quot;files.insertFinalNewline&quot;: true, &quot;files.trimFinalNewlines&quot;: true }   &quot;개발 환경부터 통일하는 게 중요하네요&quot;라는 것을 깨달았어요.  ","version":null,"tagName":"h3"},{"title":"실무에서 유용했던 팁들​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#실무에서-유용했던-팁들","content":" ","version":null,"tagName":"h2"},{"title":"대량 파일 처리 스크립트​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#대량-파일-처리-스크립트","content":" 나중에 비슷한 문제가 또 생겼을 때를 대비해서 동료분과 함께 처리 스크립트를 만들어뒀어요:  #!/bin/bash # fix_line_endings.sh - 팀에서 공유하는 스크립트 EXTENSIONS=(&quot;sh&quot; &quot;bash&quot; &quot;py&quot; &quot;pl&quot;) for ext in &quot;${EXTENSIONS[@]}&quot;; do echo &quot;Converting *.${ext} files...&quot; find . -name &quot;*.${ext}&quot; -type f -exec dos2unix {} \\; done echo &quot;Line ending conversion completed!&quot;   ","version":null,"tagName":"h3"},{"title":"파일 형식 확인 스크립트​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#파일-형식-확인-스크립트","content":" 문제가 생겼을 때 빠르게 확인할 수 있는 스크립트도 만들었어요:  #!/bin/bash # check_line_endings.sh check_file() { local file=&quot;$1&quot; if file &quot;$file&quot; | grep -q &quot;CRLF&quot;; then echo &quot;DOS/Windows: $file&quot; elif file &quot;$file&quot; | grep -q &quot;CR&quot;; then echo &quot;Mac (old): $file&quot; else echo &quot;Unix/Linux: $file&quot; fi } for file in &quot;$@&quot;; do if [ -f &quot;$file&quot; ]; then check_file &quot;$file&quot; else echo &quot;File not found: $file&quot; fi done   ","version":null,"tagName":"h3"},{"title":"배운 점과 팀에 미친 영향​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#배운-점과-팀에-미친-영향","content":" ","version":null,"tagName":"h2"},{"title":"개발 프로세스 개선​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#개발-프로세스-개선","content":" 이 경험을 통해 저희 팀의 개발 프로세스가 많이 개선되었어요:  개발 환경 설정 문서화: 새로운 팀원이 오면 첫날에 Git 설정부터 안내CI/CD 파이프라인에 검증 단계 추가: 스크립트 실행 전 자동으로 줄바꿈 확인코드 리뷰 체크리스트에 추가: Windows에서 작성한 스크립트는 줄바꿈 확인 필수  ","version":null,"tagName":"h3"},{"title":"팀 지식 공유 문화​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#팀-지식-공유-문화","content":" 시니어 개발자분이 &quot;이런 삽질을 다른 팀원들도 겪을 수 있으니 공유해야죠&quot;라고 하시면서 팀 위키에 문서를 만들게 되었어요.  덕분에 나중에 새로 온 팀원분들은 이런 문제를 겪지 않을 수 있게 되었고, &quot;아, 이런 것도 미리 생각해서 공유하는 게 중요하구나&quot;라는 것을 배웠어요.  ","version":null,"tagName":"h3"},{"title":"마무리​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#마무리","content":" 처음에는 정말 이상한 오류라고 생각했는데, 알고 보니 운영체제 간의 차이 때문에 생기는 흔한 문제였어요. 하지만 이 경험 덕분에 여러 가지를 배울 수 있었습니다:  문제 해결 과정의 중요성: 혼자 끙끙대지 말고 팀원들과 함께 해결하기근본 원인 파악: 표면적인 문제가 아닌 진짜 원인 찾기재발 방지: 일회성 해결이 아닌 시스템적 접근지식 공유: 개인의 경험을 팀 전체의 자산으로 만들기  특히 시니어 개발자분의 조언 덕분에 빠르게 해결할 수 있었고, 팀 차원에서 재발 방지책까지 마련할 수 있어서 정말 좋은 경험이었어요.  아직도 가끔 다른 프로젝트에서 비슷한 문제를 겪는 분들을 보면 이때의 경험을 공유해드리곤 해요. 완벽한 해결책은 아니지만, 비슷한 문제로 고민하고 계신 분들께 도움이 되길 바라며 정리했습니다.  혹시 다른 좋은 해결 방법이나 비슷한 경험이 있으시면 언제든 댓글로 공유해주세요! 함께 배워가면 좋겠어요.  ","version":null,"tagName":"h2"},{"title":"참고 자료​","type":1,"pageTitle":"Shell 스크립트 'No such file or directory' 오류 완벽 해결법","url":"/blog/shell-script-no-such-file-directory-fix#참고-자료","content":" dos2unix 공식 문서Git 줄바꿈 설정 가이드EditorConfig 공식 사이트Atlassian 기술 문서 ","version":null,"tagName":"h2"},{"title":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","type":0,"sectionRef":"#","url":"/blog/supabase-complete-guide-firebase-alternative","content":"","keywords":"","version":null},{"title":"저희가 겪었던 백엔드 선택의 딜레마​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#저희가-겪었던-백엔드-선택의-딜레마","content":" ","version":null,"tagName":"h2"},{"title":"1. Firebase의 아쉬운 점들​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#1-firebase의-아쉬운-점들","content":" 이전 프로젝트에서 Firebase를 사용했었는데, 몇 가지 아쉬운 점들이 있었어요:  비용 문제  사용량이 늘어날수록 예상보다 훨씬 많은 비용 발생&quot;이 속도로 가면 예산 초과할 것 같은데...&quot;라는 우려  NoSQL의 한계  복잡한 관계형 쿼리 구현이 어려움&quot;JOIN을 어떻게 하지?&quot;라는 고민의 연속데이터 정규화의 어려움  벤더 락인 우려  Firebase에 너무 종속되는 것 같은 느낌&quot;나중에 다른 플랫폼으로 이동할 수 있을까?&quot;라는 걱정  ","version":null,"tagName":"h3"},{"title":"2. 직접 구축의 부담​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#2-직접-구축의-부담","content":" 그렇다고 처음부터 백엔드를 구축하자니 부담이 컸어요:  시간 부족: 인증, 실시간 기능, 파일 업로드 등을 모두 구현하기에는 시간이 너무 부족복잡성: 보안, 확장성, 유지보수 등을 고려하면 더욱 복잡팀 리소스: 프론트엔드 개발에 집중하고 싶었는데 백엔드까지 신경 쓰기 어려운 상황  ","version":null,"tagName":"h3"},{"title":"3. 팀 내 의견 충돌​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#3-팀-내-의견-충돌","content":" 팀 미팅에서도 의견이 갈렸어요:  &quot;그냥 Firebase 계속 쓰자&quot;: 빠른 개발을 원하는 의견&quot;PostgreSQL로 직접 구축하자&quot;: 장기적 관점을 중시하는 의견&quot;다른 대안은 없을까?&quot;: 절충안을 찾고 싶어하는 의견  ","version":null,"tagName":"h3"},{"title":"Supabase 발견과 첫 인상​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#supabase-발견과-첫-인상","content":" ","version":null,"tagName":"h2"},{"title":"시니어 개발자의 추천​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#시니어-개발자의-추천","content":" 그때 저희 팀의 시니어 개발자분이 &quot;Supabase라는 플랫폼을 찾았는데, 우리가 원하는 걸 모두 제공하는 것 같아&quot;라고 하시면서 자료를 공유해주셨어요.  &quot;PostgreSQL 기반이면서 Firebase처럼 쉽게 사용할 수 있다고 해. 게다가 오픈소스야.&quot;  처음에는 &quot;정말? 그런 게 있어?&quot;라며 반신반의했죠.  ","version":null,"tagName":"h3"},{"title":"첫 번째 테스트​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#첫-번째-테스트","content":" 팀에서 함께 공식 문서를 보면서 첫 테스트를 진행했어요. 설치부터 간단한 CRUD까지 해보는데...  &quot;어? 이거 정말 간단하네?&quot;  몇 줄의 코드로 PostgreSQL 기반의 실시간 데이터베이스가 동작하는 걸 보고 정말 놀랐어요.  // 이렇게 간단한 코드로! const { data, error } = await supabase .from('posts') .select('*') .eq('published', true) .order('created_at', { ascending: false })   &quot;복잡한 SQL 쿼리도 쉽게 작성할 수 있잖아?&quot;라며 팀원들이 감탄했어요.  ","version":null,"tagName":"h3"},{"title":"Supabase가 저희 문제를 해결한 방법​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#supabase가-저희-문제를-해결한-방법","content":" ","version":null,"tagName":"h2"},{"title":"1. SQL의 강력함 + NoSQL의 편의성​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#1-sql의-강력함--nosql의-편의성","content":" 가장 마음에 든 점은 PostgreSQL의 모든 기능을 그대로 사용할 수 있다는 거였어요:  -- 복잡한 조인과 집계도 자유롭게! SELECT u.name, COUNT(p.id) as post_count, AVG(p.likes) as avg_likes FROM users u LEFT JOIN posts p ON u.id = p.author_id WHERE u.created_at &gt;= '2024-01-01' GROUP BY u.id, u.name HAVING COUNT(p.id) &gt; 5 ORDER BY post_count DESC;   &quot;드디어 복잡한 쿼리를 마음껏 쓸 수 있겠네!&quot;라는 생각에 정말 기뻤어요.  ","version":null,"tagName":"h3"},{"title":"2. 실시간 기능의 놀라운 구현​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#2-실시간-기능의-놀라운-구현","content":" Firebase의 실시간 기능만큼 중요했던 요구사항이었는데, Supabase의 실시간 구독을 보고 깜짝 놀랐어요:  // PostgreSQL에서 실시간 구독이! const subscription = supabase .channel('public:posts') .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, (payload) =&gt; { console.log('실시간 업데이트!', payload) }) .subscribe()   &quot;PostgreSQL에서도 실시간이 된다고? 어떻게?&quot;라며 팀원들이 신기해했어요.  ","version":null,"tagName":"h3"},{"title":"3. 보안도 데이터베이스 레벨에서​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#3-보안도-데이터베이스-레벨에서","content":" Row Level Security(RLS)를 보고 정말 감탄했어요:  -- 사용자는 자신의 게시물만 볼 수 있도록 CREATE POLICY &quot;Users can view own posts&quot; ON posts FOR SELECT USING (auth.uid() = user_id);   &quot;보안 설정을 데이터베이스 레벨에서 할 수 있네? 이거 정말 안전하겠는데!&quot;  ","version":null,"tagName":"h3"},{"title":"실제 프로젝트 적용 경험​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#실제-프로젝트-적용-경험","content":" ","version":null,"tagName":"h2"},{"title":"첫 번째 프로젝트: 블로그 플랫폼​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#첫-번째-프로젝트-블로그-플랫폼","content":" 팀에서 결정한 첫 번째 Supabase 프로젝트는 간단한 블로그 플랫폼이었어요.  데이터베이스 설계​  -- 사용자 프로필 CREATE TABLE profiles ( id UUID REFERENCES auth.users(id) PRIMARY KEY, username TEXT UNIQUE NOT NULL, full_name TEXT, bio TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() ); -- 블로그 포스트 CREATE TABLE posts ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY, title TEXT NOT NULL, content TEXT NOT NULL, author_id UUID REFERENCES profiles(id) NOT NULL, published BOOLEAN DEFAULT FALSE, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() );   &quot;PostgreSQL이니까 설계가 훨씬 직관적이네!&quot;라며 팀원들이 만족해했어요.  실시간 기능 구현​  // 새 포스트가 등록되면 실시간으로 업데이트 export function usePosts() { const [posts, setPosts] = useState&lt;Post[]&gt;([]) useEffect(() =&gt; { // 초기 데이터 로드 const fetchPosts = async () =&gt; { const { data } = await supabase .from('posts') .select('*, profiles(username, avatar_url)') .eq('published', true) .order('created_at', { ascending: false }) setPosts(data || []) } fetchPosts() // 실시간 구독 const subscription = supabase .channel('public:posts') .on('postgres_changes', { event: '*', schema: 'public', table: 'posts' }, () =&gt; { fetchPosts() // 변경사항 발생시 다시 로드 }) .subscribe() return () =&gt; subscription.unsubscribe() }, []) return { posts } }   &quot;Firebase보다 더 직관적인 것 같은데?&quot;라는 반응이었어요.  ","version":null,"tagName":"h3"},{"title":"개발 속도의 향상​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#개발-속도의-향상","content":" 실제로 개발해보니 속도가 정말 빨랐어요:  인증 시스템: 몇 줄의 코드로 완성파일 업로드: Storage API로 간단하게 구현실시간 기능: PostgreSQL과 완벽 연동복잡한 쿼리: SQL로 자유자재로 작성  팀장님도 &quot;이렇게 빨리 개발이 될 줄 몰랐네&quot;라고 하시면서 만족해하셨어요.  ","version":null,"tagName":"h3"},{"title":"예상치 못한 장점들​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#예상치-못한-장점들","content":" ","version":null,"tagName":"h2"},{"title":"1. 오픈소스의 안정감​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#1-오픈소스의-안정감","content":" &quot;혹시 회사가 망하거나 정책이 바뀌면 어떻게 하지?&quot;라는 걱정이 있었는데, 오픈소스라서 그런 걱정이 없어졌어요.  ","version":null,"tagName":"h3"},{"title":"2. PostgreSQL 생태계 활용​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#2-postgresql-생태계-활용","content":" 기존에 사용하던 PostgreSQL 도구들을 그대로 사용할 수 있어서 좋았어요:  pgAdmin으로 데이터베이스 관리기존 SQL 지식 그대로 활용PostgreSQL 확장 기능들도 사용 가능  ","version":null,"tagName":"h3"},{"title":"3. 합리적인 가격 정책​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#3-합리적인-가격-정책","content":" Firebase 대비 가격이 정말 합리적이더라고요:  플랜\t월 요금\t주요 특징Free\t$0\t2개 프로젝트, 500MB DB Pro\t$25\t무제한 프로젝트, 8GB DB  &quot;이정도면 스타트업에서 부담 없이 시작할 수 있겠네!&quot;  ","version":null,"tagName":"h3"},{"title":"아쉬운 점들과 한계​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#아쉬운-점들과-한계","content":" 완벽한 솔루션은 아니었어요. 몇 가지 아쉬운 점들도 있었어요:  ","version":null,"tagName":"h2"},{"title":"1. 학습 곡선​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#1-학습-곡선","content":" 팀원 중에 SQL에 익숙하지 않은 분들은 처음에 어려워하셨어요. &quot;NoSQL이 더 쉬웠는데...&quot;라는 의견도 있었죠.  ","version":null,"tagName":"h3"},{"title":"2. 일부 고급 기능의 제약​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#2-일부-고급-기능의-제약","content":" Firebase 대비 일부 기능들이 아직 부족한 부분이 있었어요:  Analytics 기능이 제한적일부 확장 기능들이 아직 Beta 단계  ","version":null,"tagName":"h3"},{"title":"3. 한국어 자료 부족​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#3-한국어-자료-부족","content":" 영어 문서는 풍부하지만 한국어 자료가 부족해서 팀원들이 초기에 적응하는 데 시간이 걸렸어요.  ","version":null,"tagName":"h3"},{"title":"팀의 최종 결론​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#팀의-최종-결론","content":" 몇 개월간 사용해본 결과, 팀 전체가 만족하고 있어요:  ","version":null,"tagName":"h2"},{"title":"긍정적인 결과​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#긍정적인-결과","content":" 개발 속도 향상: Firebase 대비 오히려 더 빠른 개발비용 절약: 예상보다 훨씬 저렴한 운영비기술적 만족도: SQL의 강력함을 마음껏 활용팀 역량 향상: PostgreSQL과 SQL 실력 전체적으로 향상  ","version":null,"tagName":"h3"},{"title":"앞으로의 계획​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#앞으로의-계획","content":" 현재 새로운 프로젝트들은 모두 Supabase를 기본으로 고려하고 있어요. 특히 다음 프로젝트에서는 Edge Functions도 활용해볼 예정이에요.  // 다음 프로젝트에서 시도해볼 Edge Function // 이메일 발송 기능 const sendEmail = async (emailData) =&gt; { const { data, error } = await supabase.functions.invoke('send-email', { body: emailData }) return data }   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Supabase 완벽 가이드: Firebase 대안으로 떠오르는 오픈소스 백엔드 플랫폼","url":"/blog/supabase-complete-guide-firebase-alternative#결론","content":" 저희 팀의 Supabase 도입 경험을 돌아보면, 확실히 Firebase의 훌륭한 대안이라고 생각해요. 특히 SQL에 익숙하거나 복잡한 데이터 관계를 다뤄야 하는 프로젝트라면 정말 추천하고 싶어요.  물론 모든 프로젝트에 완벽한 솔루션은 아니에요. 하지만 개발 속도, 비용, 확장성, 그리고 개발자 경험을 모두 고려했을 때 매우 균형 잡힌 선택이었습니다.  혹시 저희와 비슷한 고민을 하고 계신 분들이 있다면 한번 시도해보시기를 추천드려요. 시니어 개발자분이 알려주신 덕분에 저희 팀의 백엔드 개발 방식이 완전히 바뀌었거든요.  더 궁금한 점이나 실제 도입 경험을 공유하고 싶으시면 언제든 댓글로 남겨주세요! 함께 고민해보면 좋겠어요.    참고 자료  Supabase 공식 문서PostgreSQL 공식 문서Supabase GitHub RepositorySupabase vs Firebase 비교 분석 ","version":null,"tagName":"h2"},{"title":"PostgreSQL 18에 UUIDv7이 도입됩니다","type":0,"sectionRef":"#","url":"/blog/uuidv7-postgresql-18","content":"","keywords":"","version":null},{"title":"PostgreSQL 18​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#postgresql-18","content":" PostgreSQL 18 베타 1이 며칠 전에 출시되었습니다. 이번 릴리스는 새로운 기능, 개선사항, 버그 수정으로 가득 차 있습니다. 평소와 같이 커뮤니티는 이를 시도해보고 문제를 보고하도록 권장하고 있으며, 9월에 고품질 릴리스를 출시하는 것이 목표입니다.  이번 릴리스의 주요 특징은 다음과 같습니다:  비동기 I/O (io_uring 사용) — 순차 스캔, 배큠에서 2-3배 속도 향상다중 컬럼 B-tree 인덱스의 Skip scan + 더 스마트한 OR/IN 최적화메이저 업그레이드 중 플래너 통계 유지UUIDv7 함수가상 생성 컬럼OAuth 로그인 + md5 사용 중단 경고EXPLAIN ANALYZE에서 I/O, CPU, WAL 표시시간적 제약조건, 비결정적 콜레이션의 LIKE, 케이스 폴딩새로운 와이어 프로토콜 버전: 3.2 (2003년 이후 첫 번째!)  uuidv7()이 가장 흥미로운 기능은 아니지만(그것은 비동기 I/O일 것입니다), 아마도 가장 기다려진 기능일 것입니다. PostgreSQL 17에 추가될 뻔했지만 포함되지 않아서 많은 사용자들이 실망했습니다. 저는 이 기능에 대해 너무 흥미로워서 베타 버전을 사용해보고 이에 대한 블로그 글을 쓰기로 결정했습니다.  ","version":null,"tagName":"h2"},{"title":"UUID란 무엇이며 왜 유용한가요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#uuid란-무엇이며-왜-유용한가요","content":" UUID는 트랜잭션부터 회사까지 다양한 항목의 식별자로 사용되는 128비트 값입니다. 공간과 시간에 걸쳐 고유하도록 설계되었으며, 중앙화된 서비스에 의존하지 않고도 높은 속도로 효율적으로 생성할 수 있습니다.  전통적으로 관계형 데이터베이스는 고유 식별자를 생성하기 위해 자동 증가 타입(SERIAL 또는 identity와 같은)을 사용했습니다. 이는 단일 머신에서 효율적으로 수행할 수 있지만(이 경우에도 단점이 있습니다), 확장이 필요한 경우 모든 노드에서 고유한 식별자를 생성하는 방법이 필요합니다. Instagram 팀은 PostgreSQL 데이터베이스를 샤딩하면서 UUID로 마이그레이션한 과정에 대한 짧은 블로그를 작성했습니다.  UUID는 다음과 같은 일반적인 시나리오에서 데이터베이스의 기본 키로 유용합니다:  분산 데이터베이스에서 고유 ID 생성: 많은 분산 데이터베이스가 자동 증가(identity) 컬럼을 지원할 수 있지만, 제한사항과 성능 문제가 있습니다. 추측할 수 없는 공개 식별자: 적절히 생성된 UUID는 추측하거나 예측할 수 없으며, 시스템에 대한 정보를 추론하는 데 사용할 수 없습니다. 예를 들어, 고객 식별자로 자동 증가를 사용하면 공격자가 모든 기존 식별자를 스캔하여 사용을 시도할 수 있고, 다음 식별자를 추측하여 고객 수를 추정할 수 있습니다. 클라이언트가 식별자를 생성할 수 있도록 허용: UUID를 사용하면 클라이언트가 서버와 조정하지 않고도 사용할 수 있는 식별자를 생성할 수 있습니다. 이는 서버와의 통신을 최소화하려는 모바일 앱과 서버리스 환경에서 유용합니다.  이러한 이점의 결과로 UUID는 많은 데이터베이스에서 기본 키로 사용됩니다. 하지만 데이터베이스에서 UUID 사용에 대한 3가지 우려사항도 있습니다:  정렬: UUID는 값으로 의미 있게 정렬할 수 없습니다.인덱스 지역성: 새로운 UUID는 인덱스에서 서로 가깝지 않습니다. 즉, 삽입이 임의의 위치에서 수행됩니다. 이는 인덱스 팽창과 기타 성능 문제를 일으킬 수 있습니다.크기: UUID는 128비트 값입니다. 대부분의 개발자는 기본 키로 INT(32비트) 또는 BIGINT(64비트)를 기본적으로 사용합니다. 매우 작은 레코드가 많은 테이블의 경우 이는 의미 있는 오버헤드가 될 수 있습니다.  다음 섹션에서 설명하겠지만, UUIDv7은 이 3가지 우려사항 중 2가지를 해결합니다.  UUID의 크기는 디스크 공간이나 네트워크 대역폭이 제한적일 때 문제가 될 수 있지만, 최신 CPU는 단일 명령어(CMEQ, SIMD 명령어의 일부)로 128비트 값을 비교할 수 있으므로 UUID에 대한 데이터베이스 작업이 고도로 최적화되어 있다는 점을 주목할 가치가 있습니다. 여기서 핵심은 데이터베이스와 애플리케이션 모두에서 UUID의 바이너리 표현(적절한 UUID 타입)을 사용하고 문자열 표현을 사용하지 않는 것입니다.  ","version":null,"tagName":"h2"},{"title":"왜 UUIDv7인가요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#왜-uuidv7인가요","content":" UUID는 2005년 RFC 4122에서 처음 표준화되었습니다. 이 RFC는 UUID의 5가지 변형을 정의하며, 그 중 변형 1과 4가 가장 일반적입니다. 이 사양은 나중에 2024년 5월에 발표된 RFC 9562에서 변형 6-8을 추가하도록 개정되었습니다(첫 번째 공개 작업 초안은 2020년에 발표되었지만). RFC 9562와 UUIDv7 생일 축하합니다!  사양 업데이트의 동기를 설명하기 위해 RFC 9562는 데이터베이스 키로 UUID를 사용하는 일반적인 사용 사례에 대해 논의합니다:  UUID가 인기를 얻은 한 영역은 데이터베이스 키입니다... 하지만 [RFC4122]에서 원래 정의된 UUID 버전 1-5는 다음과 같은 다른 바람직한 특성이 부족합니다: UUIDv4(섹션 5.4에서 설명)와 같이 시간 순서가 아닌 UUID 버전은 데이터베이스 인덱스 지역성이 좋지 않습니다. 이는 연속적으로 생성된 새 값이 인덱스에서 서로 가깝지 않다는 것을 의미합니다. 따라서 임의의 위치에서 삽입을 수행해야 합니다. 이를 위해 사용되는 일반적인 구조(B-tree 및 그 변형)에 대한 결과적인 부정적인 성능 영향은 극적일 수 있습니다. 널리 분산된 많은 데이터베이스 애플리케이션과 대형 애플리케이션 공급업체는 데이터베이스 키로 사용할 더 나은 시간 기반의 정렬 가능한 고유 식별자를 만드는 문제를 해결하려고 했습니다. 이로 인해 지난 10년 이상 동안 약간씩 다른 방식으로 동일한 문제를 해결하는 수많은 구현이 생겨났습니다.  RFC는 계속해서 16개(!)의 서로 다른 비표준 UUID 구현을 명시하며, 각각 고유한 장단점을 가지고 있습니다. 여기에는 인기 있는 ULID, Twitter의 Snowflake, Instagram의 ShardId 등이 포함됩니다. 이 모든 구현은 새로운 사양을 설계할 때 평가되었습니다.  새로운 RFC가 3개의 새로운 UUID 변형을 명시하지만, 흥미로운 것은 UUIDv7뿐입니다. UUIDv6은 하위 호환성을 위해서만 도입되었습니다 - RFC는 &quot;레거시 UUIDv1을 포함하지 않는 시스템은 대신 UUIDv7을 사용해야 합니다&quot;라고 말합니다. UUIDv8은 실험적이고 공급업체별 확장을 위한 형식을 제공합니다.  UUIDv7은 정렬과 인덱스 지역성 우려사항을 모두 해결합니다. 가장 중요한 48비트로 Unix Epoch 타임스탬프를 사용하고, 나머지 74비트를 랜덤 값으로 유지합니다(추가 비트는 버전과 변형에 사용됩니다). 이로 인해 UUID가 시간 순서로 정렬 가능하고 고유해집니다. 표준은 또한 UUID에 밀리초 타임스탬프를 포함하거나 신중하게 시드된 카운터를 포함하여 단일 초 내에서 순서를 지원하는 옵션을 제공합니다(필요한 경우). 결과적으로 UUIDv7은 데이터베이스의 기본 키로 사용하기에 매우 적합합니다 - 고유성이 보장되고, 정렬 가능하며, 좋은 인덱스 지역성을 가집니다.  ","version":null,"tagName":"h2"},{"title":"PostgreSQL 18의 UUIDv7​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#postgresql-18의-uuidv7","content":" PostgreSQL 18 이전까지는 UUIDv7이 기본적으로 지원되지 않았습니다. 내장된 gen_random_uuid() 함수는 UUIDv4를 생성했고, 인기 있는 uuid-ossp 확장이 추가 UUID 변형에 대한 지원을 추가했지만 RFC 4122에서 명시된 변형으로 제한되었습니다.  PostgreSQL 18은 새로운 함수인 uuidv7()을 추가하여 UUIDv7 값을 생성합니다. PostgreSQL 구현은 타임스탬프 바로 다음에 12비트 서브 밀리초 타임스탬프 분수를 포함합니다(표준에서 허용되지만 필수는 아님). 이는 동일한 PostgreSQL 세션(동일한 백엔드 프로세스)에서 생성된 모든 UUIDv7 값의 단조성을 보장합니다.  일관성을 위해 PostgreSQL 18은 명명을 맞추기 위해 gen_random_uuid()의 별칭으로 uuidv4()를 추가했습니다.  uuidv7()을 호출하면 타임스탬프가 현재 시간인 새로운 UUIDv7 값이 생성됩니다. 다른 시간에 대한 UUIDv7 값을 생성해야 하는 경우 함수에 선택적 interval을 전달할 수 있습니다.  UUID에서 타임스탬프와 버전을 추출하는 PostgreSQL의 기존 함수도 UUIDv7을 지원하도록 업데이트되었습니다. 다음은 새로운 함수를 사용하는 방법의 예입니다:  postgres=# select uuidv7(); uuidv7 -------------------------------------- 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd (1 row) postgres=# select uuidv7(INTERVAL '1 day'); uuidv7 -------------------------------------- 0196ef74-8d09-77b0-a84b-5301262f05ad (1 row) postgres=# SELECT uuid_extract_version(uuidv4()); uuid_extract_version ---------------------- 4 (1 row) postgres=# SELECT uuid_extract_version(uuidv7()); uuid_extract_version ---------------------- 7 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7()); uuid_extract_timestamp ---------------------------- 2025-05-19 20:50:40.381+00 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL '1 hour')); uuid_extract_timestamp ---------------------------- 2025-05-19 21:50:59.388+00 (1 row) postgres=# SELECT uuid_extract_timestamp(uuidv7(INTERVAL '-1 day')); uuid_extract_timestamp ---------------------------- 2025-05-18 20:51:15.774+00 (1 row)   테이블에서 uuidv7()을 기본 키로 사용하는 것은 간단하며, 타임스탬프를 추출하는 기능과 함께 UUID를 정렬 가능한 키로 사용하고 레코드의 생성 시간을 검사하기도 쉽게 만듭니다:  CREATE TABLE test ( id uuid DEFAULT uuidv7() PRIMARY KEY, name text ); INSERT INTO test (name) VALUES ('foo'); INSERT INTO test (name) VALUES ('bar'); -- 다른 두 개보다 1시간 이전으로 만들어서 목록의 시작 부분으로 정렬됩니다 INSERT INTO test (id, name) VALUES (uuidv7(INTERVAL '-1 hour'), 'oldest'); SELECT uuid_extract_timestamp(id), name FROM test ORDER BY id; uuid_extract_timestamp | name ----------------------------+-------- 2025-05-19 19:55:43.87+00 | oldest 2025-05-19 20:55:01.304+00 | foo 2025-05-19 20:55:01.305+00 | bar (3 rows)   이 모든 함수는 PostgreSQL 문서에 문서화되어 있으며, 구현 세부사항에 관심이 있다면 패치를 검토할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"직접 사용해보세요!​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#직접-사용해보세요","content":" PostgreSQL 18이 출시되면 평소와 같이 설치하여 uuidv7()과 다른 모든 새로운 기능을 사용할 수 있습니다. 공식 릴리스는 9월에 계획되어 있지만, Beta 1 버전이 이미 사용 가능하며 커뮤니티는 사용자들이 이를 시도해보고 문제를 보고하도록 권장합니다.  베타 버전과 야간 스냅샷의 설치 지침은 여기에서 확인할 수 있습니다.  ","version":null,"tagName":"h2"},{"title":"이전 버전에서 UUIDv7 사용하기: pg_uuidv7 확장​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#이전-버전에서-uuidv7-사용하기-pg_uuidv7-확장","content":" PostgreSQL 18을 기다릴 수 없다면, 이미 사용 가능한 서드파티 확장이 있습니다. pg_uuidv7은 PostgreSQL Extension Network(PGXN)에서 제공하는 확장으로, 이전 버전의 PostgreSQL에서도 UUIDv7 기능을 사용할 수 있게 해줍니다.  ","version":null,"tagName":"h2"},{"title":"pg_uuidv7 확장의 특징​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#pg_uuidv7-확장의-특징","content":" 이 확장은 PostgreSQL 18의 네이티브 구현과 유사한 기능을 제공합니다:  -- UUIDv7 생성 SELECT uuid_generate_v7(); uuid_generate_v7 -------------------------------------- 018570bb-4a7d-7c7e-8df4-6d47afd8c8fc (1 row) -- 타임스탬프 추출 SELECT uuid_v7_to_timestamptz('018570bb-4a7d-7c7e-8df4-6d47afd8c8fc'); uuid_v7_to_timestamptz ---------------------------- 2023-01-02 04:26:40.637+00 (1 row) -- 타임스탬프를 UUIDv7로 변환 SELECT uuid_timestamptz_to_v7('2023-01-02 04:26:40.637+00'); uuid_timestamptz_to_v7 -------------------------------------- 018570bb-4a7d-7630-a5c4-89b795024c5d (1 row)   ","version":null,"tagName":"h3"},{"title":"성능​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#성능","content":" pg_uuidv7 확장의 uuid_generate_v7() 함수는 PostgreSQL의 네이티브 gen_random_uuid() 함수와 거의 동일한 성능을 제공합니다. 이는 프로덕션 환경에서도 안심하고 사용할 수 있음을 의미합니다.  ","version":null,"tagName":"h3"},{"title":"설치 방법​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#설치-방법","content":" x86_64 Linux 시스템에서는 다음과 같이 간단히 설치할 수 있습니다:  # 임시 디렉토리에서 작업 cd &quot;$(mktemp -d)&quot; # 최신 릴리스 다운로드 curl -LO &quot;https://github.com/fboulnois/pg_uuidv7/releases/download/v1.6.0/{pg_uuidv7.tar.gz,SHA256SUMS}&quot; # 압축 해제 및 검증 tar xf pg_uuidv7.tar.gz sha256sum -c SHA256SUMS # PostgreSQL 버전 확인 및 설치 PG_MAJOR=$(pg_config --version | sed 's/^.* \\([0-9]\\{1,\\}\\).*$/\\1/') cp &quot;$PG_MAJOR/pg_uuidv7.so&quot; &quot;$(pg_config --pkglibdir)&quot; cp pg_uuidv7--1.6.sql pg_uuidv7.control &quot;$(pg_config --sharedir)/extension&quot; # 확장 활성화 psql -c &quot;CREATE EXTENSION pg_uuidv7;&quot;   다른 아키텍처(Apple M1, Raspberry Pi 등)에서는 소스에서 직접 빌드해야 합니다.  ","version":null,"tagName":"h3"},{"title":"언제 사용해야 할까요?​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#언제-사용해야-할까요","content":" pg_uuidv7 확장은 다음과 같은 경우에 유용합니다:  현재 PostgreSQL 버전을 유지해야 하는 경우: PostgreSQL 18로 업그레이드할 수 없지만 UUIDv7의 이점을 누리고 싶을 때즉시 UUIDv7을 사용하고 싶은 경우: PostgreSQL 18 출시를 기다리지 않고 지금 당장 UUIDv7을 사용하고 싶을 때마이그레이션 준비: PostgreSQL 18로 업그레이드하기 전에 UUIDv7을 미리 테스트해보고 싶을 때  PostgreSQL 18이 출시되면 네이티브 함수로 마이그레이션할 수 있으며, 함수 이름만 약간 다를 뿐 기본적인 기능은 동일합니다.  ","version":null,"tagName":"h3"},{"title":"마무리​","type":1,"pageTitle":"PostgreSQL 18에 UUIDv7이 도입됩니다","url":"/blog/uuidv7-postgresql-18#마무리","content":" PostgreSQL 18은 경험 많은 개발자들이 정말로 감사할 실용적인 개선사항을 제공합니다. UUIDv7에 대한 기본 지원은 조용하지만 영향력 있는 추가 기능으로, 데이터베이스 설계에서 오랫동안 지속된 문제점을 해결합니다.  UUID는 항상 트레이드오프였습니다: 안전하고, 고유성이 보장되며, 분산 시스템에서 효율적으로 생성할 수 있지만 B-tree 인덱스 사용 시 성능 단점이 있었습니다. UUIDv7은 두 세계의 장점을 모두 가져옵니다 — 전역적으로 고유하면서도 B-tree 인덱스와 쓰기 집약적 워크로드와 잘 호환되는 방식으로 정렬됩니다. PostgreSQL 18은 이를 훨씬 더 편리하게 사용할 수 있게 만듭니다.  기본 키에 UUID 사용을 주저했다면, 이제 그 결정을 재검토할 기회입니다. 베타를 시도해보고, 스키마에서 테스트해보고, 어떻게 작동하는지 확인해보세요. 멀티 테넌트 앱을 구축하든 단순히 더 안정적인 ID 생성을 원하든, UUIDv7은 살펴볼 가치가 있습니다.  PostgreSQL의 미래를 형성하는 가장 좋은 방법은 일찍 참여하는 것입니다 — 그러니 테스트 인스턴스를 실행하고 발견한 것을 커뮤니티에 알려주세요.    참고 자료:  The Nile Blog - UUIDv7 Comes to PostgreSQL 18PGXN - pg_uuidv7 확장 ","version":null,"tagName":"h2"},{"title":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","type":0,"sectionRef":"#","url":"/blog/tailwind-css-v4-complete-guide","content":"","keywords":"","version":null},{"title":"우리 팀이 겪었던 빌드 성능 문제​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#우리-팀이-겪었던-빌드-성능-문제","content":" 저희 팀에서 실제로 마주했던 현실적인 문제들을 먼저 말씀드릴게요:  ","version":null,"tagName":"h2"},{"title":"😰 너무 느린 개발 환경​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-너무-느린-개발-환경","content":" 매번 CSS 수정할 때마다 15초씩 기다려야 했어요Hot reload도 느려서 개발 리듬이 계속 끊어졌습니다특히 대규모 프로젝트에서는 더욱 심했어요  ","version":null,"tagName":"h3"},{"title":"🏗️ 복잡한 설정 관리​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#️-복잡한-설정-관리","content":" tailwind.config.js 파일이 점점 복잡해져서 관리가 어려웠어요커스텀 유틸리티 추가할 때마다 JavaScript로 플러그인 작성해야 했고...  ","version":null,"tagName":"h3"},{"title":"📱 최신 CSS 기능 활용의 아쉬움​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-최신-css-기능-활용의-아쉬움","content":" OKLCH 색상이나 컨테이너 쿼리 같은 최신 기능을 쓰고 싶었는데 제한적이었어요  그때 팀장님이 &quot;새 버전에서 이런 문제들이 해결된다면 정말 좋겠다&quot;고 하셨는데... v4.0이 정말 그 해답이었습니다.  ","version":null,"tagName":"h3"},{"title":"v4.0: 성능과 현대 CSS의 혁신​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v40-성능과-현대-css의-혁신","content":" ","version":null,"tagName":"h2"},{"title":"🚀 Oxide 엔진: 빌드 성능의 혁명​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-oxide-엔진-빌드-성능의-혁명","content":" Tailwind CSS v4.0의 가장 큰 변화는 Rust로 작성된 Oxide 엔진 도입입니다.    성능 개선 수치:  전체 빌드: 최대 5배 향상증분 빌드: 100배 이상 향상대규모 프로젝트에서도 쾌적한 개발 경험  # v3.x 빌드 시간 예시 npm run build # ~15초 # v4.0 빌드 시간 예시 npm run build # ~3초   ","version":null,"tagName":"h3"},{"title":"🎨 CSS-first 설정: JavaScript에서 CSS로​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-css-first-설정-javascript에서-css로","content":" 기존의 복잡한 JavaScript 설정 파일을 CSS로 대체했습니다.  styles/tailwind.css @import &quot;tailwindcss&quot;; /* 커스텀 유틸리티 정의 */ @layer utilities { .btn-primary { @apply bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors; } .card-shadow { @apply shadow-lg shadow-gray-200/50 dark:shadow-gray-800/50; } } /* 커스텀 속성 정의 */ @property --brand-color { syntax: &quot;&lt;color&gt;&quot;; initial-value: #3b82f6; inherits: false; }   기존 방식과 비교:  tailwind.config.js (v3.x) module.exports = { theme: { extend: { colors: { brand: '#3b82f6' }, boxShadow: { 'card': '0 10px 15px -3px rgba(0, 0, 0, 0.1)' } } }, plugins: [ function({ addUtilities }) { addUtilities({ '.btn-primary': { backgroundColor: '#3b82f6', color: 'white', // ... } }) } ] }   ","version":null,"tagName":"h3"},{"title":"🌈 최신 CSS 기능 완전 지원​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-최신-css-기능-완전-지원","content":" v4.0은 최신 CSS 기능을 적극적으로 활용합니다:  1. OKLCH 색상 시스템  /* 더 정확하고 일관된 색상 표현 */ .text-blue-500 { color: oklch(0.6 0.2 250); }   2. 컨테이너 쿼리  &lt;div class=&quot;@container&quot;&gt; &lt;div class=&quot;@sm:text-lg @md:text-xl @lg:text-2xl&quot;&gt; 반응형 텍스트 &lt;/div&gt; &lt;/div&gt;   3. Cascade Layers  @layer base, components, utilities; @layer base { /* 기본 스타일 */ } @layer components { /* 컴포넌트 스타일 */ }   ","version":null,"tagName":"h3"},{"title":"🛠️ 새로운 유틸리티 클래스​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#️-새로운-유틸리티-클래스","content":" 박스 섀도우 확장:  &lt;!-- 4단계 섀도우 지원 --&gt; &lt;div class=&quot;shadow-xs shadow-sm shadow-md shadow-lg shadow-xl&quot;&gt; 다양한 섀도우 레벨 &lt;/div&gt; &lt;!-- 인셋 섀도우 --&gt; &lt;div class=&quot;inset-shadow-sm inset-shadow-md&quot;&gt; 내부 그림자 효과 &lt;/div&gt;   새로운 variant:  &lt;!-- nth-* variant --&gt; &lt;div class=&quot;nth-2:bg-gray-100 nth-odd:bg-blue-50&quot;&gt; &lt;!-- 2번째, 홀수 번째 요소 스타일링 --&gt; &lt;/div&gt; &lt;!-- not-* variant --&gt; &lt;div class=&quot;not-first:border-t not-last:border-b&quot;&gt; &lt;!-- 첫 번째가 아닌, 마지막이 아닌 요소 --&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"v4.1: 실전 유틸리티와 호환성 강화​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v41-실전-유틸리티와-호환성-강화","content":" ","version":null,"tagName":"h2"},{"title":"✨ 텍스트 섀도우 공식 지원​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-텍스트-섀도우-공식-지원","content":" 드디어 텍스트 섀도우가 공식 유틸리티로 추가되었습니다.  텍스트 섀도우 예시 &lt;!-- 기본 텍스트 섀도우 --&gt; &lt;h1 class=&quot;text-shadow-sm text-4xl font-bold&quot;&gt; 부드러운 텍스트 섀도우 &lt;/h1&gt; &lt;h2 class=&quot;text-shadow-md text-3xl font-semibold text-blue-600&quot;&gt; 중간 강도 섀도우 &lt;/h2&gt; &lt;h3 class=&quot;text-shadow-lg text-2xl font-bold text-white&quot;&gt; 강한 텍스트 섀도우 &lt;/h3&gt; &lt;!-- 알파값 조절 --&gt; &lt;p class=&quot;text-shadow-md/50 text-gray-800&quot;&gt; 50% 투명도 섀도우 &lt;/p&gt;   CSS 출력 결과:  .text-shadow-sm { text-shadow: 0 1px 2px rgb(0 0 0 / 0.05); } .text-shadow-md { text-shadow: 0 4px 6px rgb(0 0 0 / 0.1); } .text-shadow-lg { text-shadow: 0 8px 16px rgb(0 0 0 / 0.15); }   ","version":null,"tagName":"h3"},{"title":"🎭 마스킹 유틸리티​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-마스킹-유틸리티","content":" 복잡한 시각 효과를 간단하게 구현할 수 있는 마스킹 유틸리티가 추가되었습니다.  마스킹 효과 예시 &lt;!-- 그라디언트 마스킹 --&gt; &lt;div class=&quot;mask-gradient-to-r from-transparent to-black&quot;&gt; &lt;img src=&quot;hero-image.webp&quot; alt=&quot;그라디언트 마스킹된 이미지&quot; /&gt; &lt;/div&gt; &lt;!-- 원형 마스킹 --&gt; &lt;div class=&quot;mask-circle&quot;&gt; &lt;img src=&quot;profile.webp&quot; alt=&quot;원형 마스킹된 프로필&quot; /&gt; &lt;/div&gt; &lt;!-- 커스텀 SVG 마스킹 --&gt; &lt;div class=&quot;mask-[url(#custom-mask)]&quot;&gt; &lt;div class=&quot;bg-gradient-to-r from-blue-500 to-purple-600 h-32&quot;&gt; 커스텀 마스킹 영역 &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"🌐 구형 브라우저 호환성 대폭 개선​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-구형-브라우저-호환성-대폭-개선","content":" v4.1의 가장 실용적인 개선사항은 구형 브라우저 지원입니다.  OKLCH 자동 fallback:  /* v4.1에서 자동 생성되는 CSS */ .bg-blue-500 { background-color: #3b82f6; /* fallback */ background-color: oklch(0.6 0.2 250); } .text-red-500/50 { color: rgba(239, 68, 68, 0.5); /* fallback */ color: oklch(0.6 0.2 25 / 0.5); }   @property 미지원 브라우저 처리:  /* 지원 브라우저 */ @property --tw-shadow-color { syntax: &quot;&lt;color&gt;&quot;; initial-value: transparent; inherits: false; } /* 미지원 브라우저에서는 자동으로 비활성화 */   ","version":null,"tagName":"h3"},{"title":"📝 세밀한 텍스트 제어​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-세밀한-텍스트-제어","content":" overflow-wrap 유틸리티:  &lt;!-- 긴 URL이나 단어 처리 --&gt; &lt;div class=&quot;overflow-wrap-break-word max-w-xs&quot;&gt; https://very-long-domain-name-that-might-break-layout.com/path &lt;/div&gt; &lt;div class=&quot;overflow-wrap-anywhere&quot;&gt; supercalifragilisticexpialidocious &lt;/div&gt;   baseline 정렬 확장:  &lt;div class=&quot;flex items-baseline-last gap-4&quot;&gt; &lt;div class=&quot;text-sm leading-relaxed&quot;&gt; 여러 줄의&lt;br&gt; 텍스트 내용 &lt;/div&gt; &lt;div class=&quot;text-lg&quot;&gt; 마지막 줄 기준으로&lt;br&gt; 정렬됩니다 &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"🎯 새로운 상태 variant​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#-새로운-상태-variant","content":" 입력 장치별 스타일링:  &lt;!-- 터치 디바이스 감지 --&gt; &lt;button class=&quot;pointer-coarse:p-4 pointer-fine:p-2&quot;&gt; 디바이스별 패딩 &lt;/button&gt; &lt;!-- 호버 가능 여부 감지 --&gt; &lt;div class=&quot;any-hover:hover:bg-blue-100&quot;&gt; 호버 지원 시에만 호버 효과 &lt;/div&gt;   접근성 및 환경 variant:  &lt;!-- JavaScript 비활성화 상태 --&gt; &lt;div class=&quot;noscript:block hidden&quot;&gt; JavaScript가 비활성화되었습니다. &lt;/div&gt; &lt;!-- 색상 반전 모드 --&gt; &lt;div class=&quot;inverted-colors:bg-white inverted-colors:text-black&quot;&gt; 고대비 모드 대응 &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"마이그레이션 가이드​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#마이그레이션-가이드","content":" ","version":null,"tagName":"h2"},{"title":"v3.x에서 v4.x로 업그레이드​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#v3x에서-v4x로-업그레이드","content":" 1. 설치 및 설정 변경:  # 기존 패키지 제거 npm uninstall tailwindcss autoprefixer postcss # v4 설치 npm install tailwindcss@next   2. 설정 파일 변경:  src/styles/tailwind.css /* 기존 */ @tailwind base; @tailwind components; @tailwind utilities; /* v4.x */ @import &quot;tailwindcss&quot;;   3. 커스텀 설정 마이그레이션:  src/styles/tailwind.css @import &quot;tailwindcss&quot;; /* JavaScript 설정을 CSS로 이전 */ @layer utilities { .btn-custom { @apply bg-brand-500 text-white px-4 py-2 rounded; } } /* 커스텀 속성 정의 */ @property --brand-500 { syntax: &quot;&lt;color&gt;&quot;; initial-value: #3b82f6; inherits: false; }   ","version":null,"tagName":"h3"},{"title":"주의사항 및 호환성​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#주의사항-및-호환성","content":" Breaking Changes:  Node.js 18+ 필수일부 플러그인 API 변경PostCSS 설정 방식 변경  점진적 마이그레이션 전략:  새 프로젝트에서 v4 테스트기존 프로젝트는 v3.x 유지하며 점진적 업그레이드커스텀 플러그인 호환성 확인  ","version":null,"tagName":"h3"},{"title":"성능 벤치마크​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#성능-벤치마크","content":" 실제 프로젝트에서 측정한 성능 개선 결과입니다:  프로젝트 규모\tv3.x 빌드 시간\tv4.x 빌드 시간\t개선율소규모 (&lt; 100 컴포넌트)\t2.3초\t0.8초\t65% ↓ 중규모 (100-500 컴포넌트)\t8.7초\t2.1초\t76% ↓ 대규모 (500+ 컴포넌트)\t23.4초\t4.6초\t80% ↓  ","version":null,"tagName":"h2"},{"title":"실무 활용 팁​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#실무-활용-팁","content":" ","version":null,"tagName":"h2"},{"title":"1. 텍스트 섀도우 활용법​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#1-텍스트-섀도우-활용법","content":" &lt;!-- 헤더 텍스트에 깊이감 추가 --&gt; &lt;h1 class=&quot;text-4xl font-bold text-white text-shadow-lg&quot;&gt; 임팩트 있는 제목 &lt;/h1&gt; &lt;!-- 버튼 텍스트 가독성 향상 --&gt; &lt;button class=&quot;bg-gradient-to-r from-blue-500 to-purple-600 text-white text-shadow-sm px-6 py-3 rounded-lg&quot;&gt; 그라디언트 버튼 &lt;/button&gt;   ","version":null,"tagName":"h3"},{"title":"2. 마스킹으로 고급 효과​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#2-마스킹으로-고급-효과","content":" &lt;!-- 이미지 페이드 아웃 효과 --&gt; &lt;div class=&quot;relative&quot;&gt; &lt;img src=&quot;hero.webp&quot; alt=&quot;히어로 이미지&quot; class=&quot;w-full h-64 object-cover&quot; /&gt; &lt;div class=&quot;absolute inset-0 mask-gradient-to-t from-black/80 to-transparent&quot;&gt; &lt;div class=&quot;absolute bottom-4 left-4 text-white&quot;&gt; &lt;h2 class=&quot;text-2xl font-bold&quot;&gt;오버레이 텍스트&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"3. 반응형 컨테이너 쿼리​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#3-반응형-컨테이너-쿼리","content":" &lt;div class=&quot;@container bg-white rounded-lg shadow-lg p-4&quot;&gt; &lt;h3 class=&quot;@xs:text-lg @sm:text-xl @md:text-2xl font-semibold&quot;&gt; 컨테이너 크기에 따른 반응형 제목 &lt;/h3&gt; &lt;p class=&quot;@sm:block hidden text-gray-600 mt-2&quot;&gt; 컨테이너가 충분히 클 때만 표시되는 설명 &lt;/p&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"결론​","type":1,"pageTitle":"Tailwind CSS v4.0 & v4.1 완전 분석: 성능 혁신과 실전 유틸리티","url":"/blog/tailwind-css-v4-complete-guide#결론","content":" Tailwind CSS v4.0과 v4.1은 단순한 버전 업그레이드를 넘어 프론트엔드 개발 방식의 패러다임 전환을 제시합니다.  v4.0의 핵심 가치:  성능: Oxide 엔진으로 개발 생산성 극대화현대성: 최신 CSS 기능 완전 활용단순성: CSS-first 접근법으로 설정 복잡도 감소  v4.1의 실용적 개선:  시각적 완성도: 텍스트 섀도우, 마스킹 등 디자인 유틸리티호환성: 구형 브라우저 graceful degradation세밀함: 텍스트 제어, 상태 관리 등 디테일 향상  특히 구형 브라우저 지원과 텍스트 섀도우, 마스킹 유틸리티는 v4.1에서만 제공되므로, 실무 프로젝트에서는 최신 버전 사용을 강력히 권장합니다.  저희 팀에서 v4.1을 도입한 후 정말 많은 것이 바뀌었어요. 빌드 시간은 3초로 줄어들었고, 개발할 때 스트레스가 확실히 줄었습니다. 특히 텍스트 섀도우 유틸리티 덕분에 디자이너님도 &quot;이제 CSS 요청할 일이 줄었다&quot;고 좋아하시더라고요 😊  물론 마이그레이션 과정에서 일부 플러그인이 호환되지 않는 문제도 있었어요. 하지만 팀원들과 함께 차근차근 해결해나가니까 결국 성공적으로 전환할 수 있었습니다.  아직 모든 기능을 다 써보지는 못했지만, 확실히 개발 경험이 많이 개선되었다고 생각해요. 혹시 Tailwind CSS v4 사용 경험이나 마이그레이션 팁이 있으시면 댓글로 공유해주세요! 함께 배워가면 좋겠어요. ","version":null,"tagName":"h2"},{"title":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","type":0,"sectionRef":"#","url":"/blog/vscode-extensions-double-productivity","content":"","keywords":"","version":null},{"title":"0. 들어가며​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#0-들어가며","content":" 작년 이맘때쯤이었어요. 새로 합류한 팀에서 코드 리뷰를 받는데, 선배 개발자분이 이런 말씀을 하시더라고요.  &quot;어? 너 VS Code 확장 프로그램 몇 개나 쓰고 있어?&quot;  당시 저는 기본 확장 프로그램 몇 개밖에 안 쓰고 있었어요. Theme 하나, 언어 지원 정도? 그때까지는 &quot;확장 프로그램이 그렇게 중요하나?&quot; 하고 생각했었는데... 지금 돌이켜보면 정말 무지했던 것 같습니다 😅  ","version":null,"tagName":"h2"},{"title":"1. 문제 상황​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#1-문제-상황","content":" 팀에 합류하고 나서 느낀 현실적인 문제들이 있었어요:  ","version":null,"tagName":"h2"},{"title":"느린 개발 속도​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#느린-개발-속도","content":" 간단한 기능 구현에도 다른 팀원들보다 2배 가까이 시간이 걸렸어요반복적인 코드 작성에 너무 많은 시간을 소모하고 있었습니다&quot;왜 이렇게 느리지?&quot; 하는 자괴감까지 들더라고요  ","version":null,"tagName":"h3"},{"title":"코드 품질 문제​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#코드-품질-문제","content":" 코드 리뷰에서 지적받는 부분들이 계속 반복되었어요포맷팅이 일관되지 않아서 매번 수정하느라 시간 낭비ESLint 경고를 놓치는 경우가 빈번했습니다  ","version":null,"tagName":"h3"},{"title":"디버깅의 어려움​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#디버깅의-어려움","content":" 콘솔로만 디버깅하다 보니 복잡한 버그 해결이 막막했어요특히 React 컴포넌트 상태 추적이 정말 힘들었습니다  당시 팀장님이 이런 말씀을 해주셨어요: &quot;도구를 잘 활용하는 것도 개발자의 중요한 역량이야. 한번 제대로 세팅해보는 건 어때?&quot;  ","version":null,"tagName":"h3"},{"title":"2. 해결 과정​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#2-해결-과정","content":" ","version":null,"tagName":"h2"},{"title":"첫 번째 시도: 무작정 설치하기​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#첫-번째-시도-무작정-설치하기","content":" 처음에는 &quot;인기 확장 프로그램 TOP 20&quot; 같은 글을 보고 무작정 설치했어요. 결과는... 참담했습니다.  VS Code 실행 속도가 현저히 느려졌어요확장 프로그램끼리 충돌하는 경우도 있었고너무 많은 기능 때문에 오히려 혼란스러웠습니다  팀원분이 보시더니 &quot;확장 프로그램도 전략적으로 써야 해&quot; 하시며 조언해주셨어요.  ","version":null,"tagName":"h3"},{"title":"두 번째 시도: 체계적 접근​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#두-번째-시도-체계적-접근","content":" 그래서 팀원들과 함께 체계적으로 접근해보기로 했어요:  현재 작업 흐름 분석: 어떤 부분에서 시간을 많이 쓰는지 파악문제점 우선순위 정리: 가장 급한 문제부터 해결단계별 도입: 한 번에 하나씩, 충분히 익숙해진 후 다음 단계로팀 공유: 좋은 확장 프로그램은 팀 전체가 사용하도록  ","version":null,"tagName":"h3"},{"title":"3개월간의 실험과 학습​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#3개월간의-실험과-학습","content":" 정말 많은 시행착오가 있었어요. 어떤 확장 프로그램은 기대했던 것과 달랐고, 어떤 건 설정이 복잡해서 포기하기도 했습니다.  특히 기억에 남는 건, Auto Rename Tag를 처음 써봤을 때였어요. HTML 태그 하나만 바꿨는데 닫는 태그까지 자동으로 바뀌는 걸 보고 &quot;와, 이런 게 있었구나!&quot; 하고 감탄했었죠.  ","version":null,"tagName":"h3"},{"title":"3. 최종 해결책​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#3-최종-해결책","content":" 여러 시행착오를 거쳐 최종적으로 정착한 확장 프로그램들을 카테고리별로 정리해봤어요:  ","version":null,"tagName":"h2"},{"title":"🚀 생산성 핵심 확장 프로그램​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#-생산성-핵심-확장-프로그램","content":" 1. GitHub Copilot​  기능: AI 기반 코드 자동완성 실제 효과: 반복적인 코드 작성 시간 50% 단축   처음에는 &quot;AI가 내 코드를 대신 써준다고?&quot; 하고 반신반의했는데... 정말 게임 체인저였어요. 특히 반복적인 함수나 타입 정의할 때 엄청난 도움이 됩니다.  💡 팁: Copilot을 맹신하지 말고, 제안된 코드를 항상 검토하는 습관을 들이세요.  2. Auto Rename Tag​  기능: HTML/JSX 태그 자동 이름 변경 실제 효과: 마크업 수정 시간 60% 단축   정말 단순하지만 강력한 확장 프로그램이에요. &lt;div&gt;를 &lt;section&gt;으로 바꾸면 닫는 태그도 자동으로 바뀝니다.  3. Bracket Pair Colorizer 2​  기능: 괄호 쌍을 색깔로 구분 실제 효과: 복잡한 코드 구조 파악 시간 40% 단축   중첩된 함수나 객체가 많을 때 정말 유용해요. 어떤 괄호가 어디에 매칭되는지 한눈에 알 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🔍 코드 품질 및 디버깅​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#-코드-품질-및-디버깅","content":" 4. ESLint​  기능: JavaScript/TypeScript 코드 품질 검사 실제 효과: 코드 리뷰 지적사항 70% 감소   이제는 없으면 안 되는 필수 확장 프로그램이에요. 실시간으로 코드 문제점을 찾아주니까 코드 리뷰에서 지적받는 일이 현저히 줄었습니다.  5. Prettier - Code formatter​  기능: 코드 자동 포맷팅 실제 효과: 코드 스타일 통일, 포맷팅 시간 100% 절약   저장할 때마다 자동으로 코드를 예쁘게 정리해줘요. 팀 전체가 같은 설정을 쓰니까 코드 스타일이 통일되어서 정말 좋습니다.  6. Error Lens​  기능: 에러와 경고를 코드 라인에 직접 표시 실제 효과: 에러 발견 시간 80% 단축   에러나 경고가 있으면 해당 라인 끝에 바로 표시해줘요. Problems 패널을 따로 확인할 필요가 없어서 정말 편합니다.  ","version":null,"tagName":"h3"},{"title":"🎨 개발 환경 개선​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#-개발-환경-개선","content":" 7. Material Icon Theme​  기능: 파일 아이콘 테마 실제 효과: 파일 찾기 속도 30% 향상   파일 확장자별로 직관적인 아이콘을 제공해요. 특히 프로젝트 규모가 클 때 파일을 빠르게 찾는 데 도움이 됩니다.  8. Indent Rainbow​  기능: 들여쓰기를 색깔로 구분 실제 효과: 코드 구조 파악 시간 25% 단축   Python이나 YAML 파일 작업할 때 특히 유용해요. 들여쓰기 레벨을 색깔로 구분해주니까 구조를 한눈에 파악할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"🛠️ 특화 도구들​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#️-특화-도구들","content":" 9. Thunder Client​  기능: VS Code 내장 API 테스트 도구 실제 효과: API 테스트 시간 50% 단축   Postman을 따로 실행할 필요 없이 VS Code 안에서 바로 API를 테스트할 수 있어요. 개발하면서 바로바로 테스트하기 정말 편합니다.  10. Live Server​  기능: 로컬 개발 서버 실행 실제 효과: 정적 페이지 개발 효율 2배 향상   HTML/CSS 작업할 때 파일을 저장하면 브라우저가 자동으로 새로고침돼요. 특히 프론트엔드 프로토타입 만들 때 필수입니다.  11. GitLens​  기능: Git 정보 강화 표시 실제 효과: 코드 이력 추적 시간 60% 단축   각 코드 라인에 누가 언제 수정했는지 표시해줘요. 팀 프로젝트에서 코드 변경 이력을 추적할 때 정말 유용합니다.  ","version":null,"tagName":"h3"},{"title":"📱 React/TypeScript 특화​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#-reacttypescript-특화","content":" 12. ES7+ React/Redux/React-Native snippets​  기능: React 관련 코드 스니펫 실제 효과: 컴포넌트 생성 시간 70% 단축   rfce만 타이핑하면 React 함수형 컴포넌트 전체 구조가 자동으로 생성돼요. 정말 시간 절약이 많이 됩니다.  13. TypeScript Importer​  기능: TypeScript import 자동 관리 실제 효과: import 구문 작성 시간 80% 단축   타입이나 함수를 사용하면 자동으로 import 구문을 추가해줘요. 특히 대규모 TypeScript 프로젝트에서 필수입니다.  ","version":null,"tagName":"h3"},{"title":"🎯 추가 유용한 도구들​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#-추가-유용한-도구들","content":" 14. TODO Highlight​  기능: TODO, FIXME 등 주석 하이라이트 실제 효과: 할 일 추적 효율 100% 향상   코드에 TODO 주석을 남기면 눈에 띄게 하이라이트해줘요. 나중에 해야 할 일들을 놓치지 않게 도와줍니다.  15. Better Comments​  기능: 주석을 카테고리별로 색깔 구분 실제 효과: 주석 가독성 50% 향상   주석에 !, ?, TODO 등을 붙이면 색깔로 구분해줘요. 중요한 주석과 일반 주석을 한눈에 구분할 수 있습니다.  ","version":null,"tagName":"h3"},{"title":"4. 결과와 성과​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#4-결과와-성과","content":" 6개월 후 측정한 실제 개선 효과예요:  ","version":null,"tagName":"h2"},{"title":"정량적 결과​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#정량적-결과","content":" 코딩 속도: 평균 40% 향상 - 컴포넌트 생성: 5분 → 2분 - API 연동: 30분 → 18분 - 스타일링: 20분 → 12분 디버깅 시간: 평균 60% 단축 - 에러 발견: 즉시 - 버그 추적: 기존 대비 60% 빠름 코드 품질: 70% 개선 - 코드 리뷰 지적사항 감소 - 일관된 코드 스타일 유지   ","version":null,"tagName":"h3"},{"title":"정성적 결과​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#정성적-결과","content":" 개발이 즐거워졌어요: 반복 작업이 줄어들어서 창의적인 부분에 더 집중할 수 있게 됐습니다팀 협업 개선: 모든 팀원이 같은 도구를 사용하니까 코드 스타일이 통일되고 협업이 훨씬 수월해졌어요자신감 향상: 빠르고 정확하게 코딩할 수 있게 되니까 자신감이 많이 생겼습니다  특히 팀장님이 &quot;요즘 코드 품질이 많이 좋아졌네&quot; 하고 말씀해주셨을 때 정말 뿌듯했어요.  ","version":null,"tagName":"h3"},{"title":"5. 실전 활용 팁​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#5-실전-활용-팁","content":" ","version":null,"tagName":"h2"},{"title":"확장 프로그램 관리 꿀팁​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#확장-프로그램-관리-꿀팁","content":" 🚨 중요: 확장 프로그램을 너무 많이 설치하면 VS Code가 느려져요.  권장 확장 프로그램 관리 방법 { &quot;필수 (항상 활성화)&quot;: [&quot;ESLint&quot;, &quot;Prettier&quot;, &quot;GitLens&quot;], &quot;프로젝트별 활성화&quot;: [&quot;Thunder Client&quot;, &quot;Live Server&quot;], &quot;언어별 활성화&quot;: [&quot;TypeScript Importer&quot;, &quot;React snippets&quot;] }   ","version":null,"tagName":"h3"},{"title":"팀 전체 설정 동기화​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#팀-전체-설정-동기화","content":" 저희 팀에서는 .vscode/extensions.json 파일로 권장 확장 프로그램을 관리해요:  .vscode/extensions.json { &quot;recommendations&quot;: [ &quot;esbenp.prettier-vscode&quot;, &quot;dbaeumer.vscode-eslint&quot;, &quot;eamodio.gitlens&quot;, &quot;ms-vscode.vscode-typescript-next&quot;, &quot;bradlc.vscode-tailwindcss&quot; ] }   이렇게 하면 새로운 팀원이 프로젝트를 클론했을 때 VS Code에서 자동으로 권장 확장 프로그램 설치를 제안해줘요.  ","version":null,"tagName":"h3"},{"title":"설정 백업하기​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#설정-백업하기","content":" 확장 프로그램 설정은 VS Code Settings Sync를 통해 백업하세요. 새 컴퓨터에서도 동일한 환경을 바로 구성할 수 있어요.  ","version":null,"tagName":"h3"},{"title":"마무리​","type":1,"pageTitle":"VS Code 확장 프로그램으로 개발 생산성 2배 늘리기","url":"/blog/vscode-extensions-double-productivity#마무리","content":" 이번 경험을 통해 &quot;도구를 제대로 활용하는 것도 중요한 개발 역량&quot;이라는 걸 깨달았어요.  처음에는 &quot;확장 프로그램 설치하는 게 그렇게 중요하나?&quot; 했는데, 지금은 없으면 정말 불편할 정도로 익숙해졌습니다. 특히 팀 전체가 같은 도구를 사용하니까 협업 효율도 크게 향상됐어요.  아직 더 좋은 확장 프로그램들이 많을 것 같은데, 지속적으로 탐색하고 팀과 공유해나가겠습니다.  혹시 제가 놓친 꿀 확장 프로그램이나 더 좋은 설정 방법이 있으시면 언제든 댓글로 남겨주세요! 함께 고민해보면 좋겠어요.  여러분도 비슷한 경험 있으신가요? 어떤 확장 프로그램을 가장 유용하게 사용하고 계신지 궁금합니다 😊 ","version":null,"tagName":"h2"}],"options":{"languages":["ko","en"],"highlightSearchTermsOnTargetPage":true,"maxHits":10,"excludeRoutes":["/search/**/*"],"indexBaseUrl":true,"id":"default"}}